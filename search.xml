<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LevelDB学习笔记-3-LRUCache</title>
      <link href="/posts/2854637860/"/>
      <url>/posts/2854637860/</url>
      
        <content type="html"><![CDATA[<blockquote><p>缓存可以更快的响应数据的请求，提高软件的运行效率，是一个很重要的概念。由于内存是有限的，我们不能将所有数据都进行缓存，只能缓存部分数据，也就意味着我们需要对缓存中的数据进行替换。最近最少使用（Least Recently Used, LRU）是使用最多的替换方法，无论是在操作系统层面，还是工程应用中。LevelDB的Cache缓存也采用了LRU方法，并且进行了性能优化，支持多线程操作，以及每个数据条目都有生命周期管理。</p></blockquote><span id="more"></span><h3 id="思路总览">1. 思路总览</h3><p>LeetCode中的LRU题目的解法是采用哈希表（unordered_map）和一个双向链表，哈希表解决索引问题，双向链表维护访问顺序。LevelDB的思想是一样的，但是对哈希表和双向链表都进行了优化。LevelDB自己实现了一个哈希表（采用开链法解决冲突），使用两个双向链表保存数据，其中所有正在被客户端使用的数据条目都存在 <strong>in-use</strong> 链表中，这些数据是无序的，因为他们不会被淘汰。而所有已经不再为客户端使用的条目都放在 <strong>lru</strong> 链表中，该链表是有序的，表头的元素是最近最少使用的（需要被淘汰的数据），表尾的元素是最新被使用过的元素。</p><h3 id="lruhanle">2. LRUHanle</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* value;  <span class="comment">// 支持存储任何类型的数据</span></span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*deleter)(<span class="keyword">const</span> Slice&amp;, <span class="keyword">void</span>* value);  <span class="comment">// 释放key,value空间的用户回调</span></span><br><span class="line">  LRUHandle* next_hash;  <span class="comment">// 开链法，解决哈希表中冲突问题</span></span><br><span class="line">  <span class="comment">// 双向链表</span></span><br><span class="line">  LRUHandle* next;</span><br><span class="line">  LRUHandle* prev;</span><br><span class="line">  <span class="keyword">size_t</span> charge;     <span class="comment">// 占用的空间</span></span><br><span class="line">  <span class="keyword">size_t</span> key_length; <span class="comment">// Key的长度，用于跟key_data联合使用</span></span><br><span class="line">  <span class="keyword">bool</span> in_cache;     <span class="comment">// 是否在缓存中</span></span><br><span class="line">  <span class="keyword">uint32_t</span> refs;     <span class="comment">// 被引用的次数（其中缓存也会让引用+1）</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash;     <span class="comment">// Key对应的hash值</span></span><br><span class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>];  <span class="comment">// Key的起始地址</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next_ is only equal to this if the LRU handle is the list head of an</span></span><br><span class="line">    <span class="comment">// empty list. List heads never have meaningful keys.</span></span><br><span class="line">    <span class="built_in">assert</span>(next != <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Slice</span>(key_data, key_length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LRUCache中最基本的数据单元，</p><ul><li>其中Key为Slice类（Google常用的一个对string的封装）</li><li>Value是一个void*指针，所以支持任何类型的数据</li><li>但也因为它是一个指针，LRUCache要负责管理其资源，必须传入明确的delete函数来释放对应的资源</li><li>refs表示有多少个线程在使用当前数据项，如果有2个线程，它的值就为3（包括Cache自身对其的引用）</li><li>因为Key是变长的，如果定义 <code>char key_data[100]</code> 就会造成空间的浪费。但是使用 <code>char* key_data</code> ，还需要在调用 <code>key_data = malloc()</code> ，这样LRUHandle与Key的空间也会不连续。LevelDB采用一个占位符的形式来实现，key_data保存key的起始地址，我们在为LRUHandle申请空间的时候，只需要申请 <code>sizeof(LRUHandle) - 1 + key.size()</code> 大小即可，其中的 <code>-1</code> 减去的是 <code>char key_data[1]</code> 的大小</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LRUHandle* e = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(LRUHandle) - <span class="number">1</span> + key.<span class="built_in">size</span>()));</span><br><span class="line">std::<span class="built_in">memcpy</span>(e-&gt;key_data, key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());  <span class="comment">// 将key的数据拷贝到key_data</span></span><br></pre></td></tr></table></figure><h3 id="handletable">3. HandleTable</h3><p>LevelDB实现的HashTable，比内置的HashTable速度快大约5%，并且内部实现逻辑比较简单，维护了一个LRUHandle的链表，并采用拉链法来解决hash冲突。其主要变量为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint32_t length_;   // hash链表长度</span><br><span class="line">uint32_t elems_;    // hash链表中当前元素个数</span><br><span class="line">LRUHandle** list_;  // hash链表指针</span><br></pre></td></tr></table></figure><p><img src="image-20220220165150048.png" alt="image-20220220165150048" style="zoom:50%;" /></p><h4 id="findpointer">3.1. FindPointer</h4><p>LevelDB的哈希表实现中，最优雅的写法就是用了二维指针，将链表的插入、修改、删除操作变得十分简单。FindPointer作为一个辅助函数，其功能就是找到对应Key的LRUHandle并且返回一个<strong>指向该LRUHandle的指针的指针</strong>，这里一定要明白这个指针的指针，如果有疑问，根据上面的图片，自己模拟下寻找的过程，就能更好的理解了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle** <span class="title">FindPointer</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)];</span><br><span class="line">  <span class="keyword">while</span> (*ptr != <span class="literal">nullptr</span> &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;<span class="built_in">key</span>())) &#123;</span><br><span class="line">  ptr = &amp;(*ptr)-&gt;next_hash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，这里有一个小技巧，当哈希表的大小时 <span class="math inline">\(2^n\)</span> 时，<code>hash &amp; (length_ -1)</code> 相当于 <code>hash % length_</code> ，并且速度要更快。</p><h4 id="resize">3.2. Resize</h4><p>对于一个哈希表，在扩容的时候有两个常见的选择：1）选用一个素数，这样可以保证最小的冲突；2）使用 <span class="math inline">\(2^n\)</span> ，这样可以使用 <code>hash &amp; (length_ -1)</code> 优化。LevelDB采用的就是后者，在Resize的时候，遍历原有的所有元素，重新哈希到对应的桶内，如果遇到冲突，采用头插法插入到对应桶的链表中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> new_length = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">while</span> (new_length &lt; elems_) &#123;</span><br><span class="line">    new_length *= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LRUHandle** new_list = <span class="keyword">new</span> LRUHandle*[new_length];</span><br><span class="line">  <span class="built_in">memset</span>(new_list, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(new_list[<span class="number">0</span>]) * new_length);</span><br><span class="line">  <span class="keyword">uint32_t</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; length_; i++) &#123;</span><br><span class="line">    LRUHandle* h = list_[i];</span><br><span class="line">    <span class="keyword">while</span> (h != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      LRUHandle* next = h-&gt;next_hash;</span><br><span class="line">      <span class="keyword">uint32_t</span> hash = h-&gt;hash;</span><br><span class="line">      LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="number">1</span>)];</span><br><span class="line">      h-&gt;next_hash = *ptr;</span><br><span class="line">      *ptr = h;</span><br><span class="line">      h = next;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(elems_ == count);</span><br><span class="line">  <span class="keyword">delete</span>[] list_;</span><br><span class="line">  list_ = new_list;</span><br><span class="line">  length_ = new_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20220220173442910.png" alt="image-20220220173442910" style="zoom:50%;" /></p><h4 id="insert">3.3. Insert</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Insert</span><span class="params">(LRUHandle* h)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = <span class="built_in">FindPointer</span>(h-&gt;<span class="built_in">key</span>(), h-&gt;hash);</span><br><span class="line">  LRUHandle* old = *ptr;</span><br><span class="line">  h-&gt;next_hash = (old == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;next_hash);</span><br><span class="line">  *ptr = h;</span><br><span class="line">  <span class="keyword">if</span> (old == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ++elems_;</span><br><span class="line">    <span class="keyword">if</span> (elems_ &gt; length_) &#123;</span><br><span class="line">      <span class="comment">// Since each cache entry is fairly large, we aim for a small</span></span><br><span class="line">      <span class="comment">// average linked list length (&lt;= 1).</span></span><br><span class="line">      <span class="built_in">Resize</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用FindPointer函数找到对应的位置，如果存在相同的Key/Hash，则将old替换为h，并且返回old。调用者释放不是nullptr的old元素。</p><h4 id="remove">3.4. Remove</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  LRUHandle** ptr = <span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">  LRUHandle* result = *ptr;</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *ptr = result-&gt;next_hash;</span><br><span class="line">    --elems_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在双指针的情况下，删除操作的核心其实只有一行代码：<code>*ptr = result-&gt;next_hash;</code></p><h4 id="lookup">3.5. Lookup</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRUHandle* <span class="title">Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="built_in">FindPointer</span>(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找操作也很简单，调用FindPointer找到对应的位置即可。</p><h3 id="lrucache">4. LRUCache</h3><p>LevelDB实现的LRUCache采用了两个双向链表（LRUHandle）加一个哈希表（HandleTable），两个双向链表将整个缓存分成两个不相交的集合：</p><ul><li>in_use链表：保存所有正在被客户端使用的数据</li><li>lru链表：保存所有已经不被客户端使用的数据</li></ul><p>为了更好的理解代码是如何实现的，我们先看一下Cache中的几个辅助函数：</p><h4 id="辅助函数">4.1. 辅助函数</h4><p>LevelDB中的双向链表都存在一个哨兵节点（在函数中为list），该节点本身步存储数据，其next指针指向最旧的Handle，prev指针指向最近被访问过的Handle。</p><p><img src="image-20220220181911788.png" alt="image-20220220181911788" style="zoom:50%;" /></p><ul><li>哨兵节点的prev指向了最后一个数据项</li><li>最后一个数据项的next指向哨兵节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Append</span><span class="params">(LRUHandle* list, LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make &quot;e&quot; newest entry by inserting just before *list</span></span><br><span class="line">  e-&gt;next = list;          <span class="comment">// 最后一个节点的next指向哨兵</span></span><br><span class="line">  e-&gt;prev = list-&gt;prev;    <span class="comment">// 哨兵的prev指向了原最后一个节点</span></span><br><span class="line">  e-&gt;prev-&gt;next = e;       <span class="comment">// 原最后一个节点的next指向e</span></span><br><span class="line">  e-&gt;next-&gt;prev = e;       <span class="comment">// 哨兵的prev更新为新的最后一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们提到了一个数据项e，只可能存在于 in_use 或 lru 中的一个，所以Remove的时候不需要传入list参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::LRU_Remove</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  e-&gt;next-&gt;prev = e-&gt;prev;</span><br><span class="line">  e-&gt;prev-&gt;next = e-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在改变数据项e的引用数量refs时，要注意两种情况：</p><ul><li>数据e的引用次数加一，但是之前没有被客户端使用，我们需要将其从 lru 链表中删除，添加到 in_use 链表中</li><li>数据e的引用次数减一，减少后没有客户端使用，我们需要将其从 in_use 链表中删除，添加到 lru 链表中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Ref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">1</span> &amp;&amp; e-&gt;in_cache) &#123;  <span class="comment">// If on lru_ list, move to in_use_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;in_use_, e);</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;refs++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Unref</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(e-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">  e-&gt;refs--;</span><br><span class="line">  <span class="keyword">if</span> (e-&gt;refs == <span class="number">0</span>) &#123;  <span class="comment">// Deallocate.</span></span><br><span class="line">    <span class="built_in">assert</span>(!e-&gt;in_cache);</span><br><span class="line">    (*e-&gt;deleter)(e-&gt;<span class="built_in">key</span>(), e-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;in_cache &amp;&amp; e-&gt;refs == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// No longer in use; move to lru_ list.</span></span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    <span class="built_in">LRU_Append</span>(&amp;lru_, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们插入一个相同Key的数据项时，需要将老的数据项从Cache中删除。但是，在多线程的环境下，我们还不能直接将其释放，因为可能其他的线程还持有该数据项的Handle。为了解决这个问题，LevelDB为每一个数据项设置了一个 <code>in_cache</code> 的参数，当我们要删除一个数据项时，删除函数需要做的就是：</p><ul><li>将该数据项从链表中移除（LRU_Remove）</li><li>将 in_cache 置位 false</li><li>释放引用（Unref）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LRUCache::FinishErase</span><span class="params">(LRUHandle* e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;in_cache);</span><br><span class="line">    <span class="built_in">LRU_Remove</span>(e);</span><br><span class="line">    e-&gt;in_cache = <span class="literal">false</span>;</span><br><span class="line">    usage_ -= e-&gt;charge;</span><br><span class="line">    <span class="built_in">Unref</span>(e);  <span class="comment">// 释放Cache所拥有的ref</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设只有一个客户端在操作数据项e，那么refs为2。调用 FinishErase 后，refs 变为了1。此时，客户端仍然需要调用 Release 函数释放它所拥有的Handle，refs变为0之后，对应的数据项e才被真正的释放掉。</p><h4 id="公共接口">4.2. 公共接口</h4><p><strong>a. Insert</strong></p><ul><li>加锁（支持多线程）</li><li>根据参数信息构造一个数据项LRUHandle</li><li>将数据项插入<strong>in_use</strong>链表</li><li>将数据项插入哈希表中，如果哈希表中存在相同的Key，则需要删除老的数据项</li><li>如果当前容量不足，则循环删除旧数据</li><li>返回数据项的Handle指针</li></ul><p><strong>b. Lookup</strong></p><ul><li>加锁（支持多线程）</li><li>调用哈希表的Lookup函数，看数据是否存在Cache中</li><li>如果存在，则调用Ref函数</li><li>返回数据项的Handle指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cache::Handle* <span class="title">LRUCache::Lookup</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  LRUHandle* e = table_.<span class="built_in">Lookup</span>(key, hash);</span><br><span class="line">  <span class="keyword">if</span> (e != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">Ref</span>(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>c. Release</strong></p><p>对应数据项的索引减一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Release</span><span class="params">(Cache::Handle* handle)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">Unref</span>(<span class="keyword">reinterpret_cast</span>&lt;LRUHandle*&gt;(handle));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>d. Erase</strong></p><p>将数据项从哈希表中删除，并且将数据项移出Cache</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Erase</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">uint32_t</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(key, hash));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>e. Prune</strong></p><p>遍历lru链表，将所有ref为1的数据项释放掉，即清楚所有的未使用缓存。</p><blockquote><p>参考该函数，我们也可以为每一个数据项添加一个时间，定时去清理所有到期的缓存</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRUCache::Prune</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (lru_.next != &amp;lru_) &#123;</span><br><span class="line">    LRUHandle* e = lru_.next;</span><br><span class="line">    <span class="built_in">assert</span>(e-&gt;refs == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> erased = <span class="built_in">FinishErase</span>(table_.<span class="built_in">Remove</span>(e-&gt;<span class="built_in">key</span>(), e-&gt;hash));</span><br><span class="line">    <span class="keyword">if</span> (!erased) &#123;  <span class="comment">// to avoid unused variable when compiled NDEBUG</span></span><br><span class="line">      <span class="built_in">assert</span>(erased);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shardedlrucache">5. ShardedLRUCache</h3><p>LRUCache的所有接口都会加锁，为了更少的锁持有时间以及更高的缓存命中率，LevelDB定义了多个LRUCache，分别处理不同hash取模后的缓存处理。LevelDB的内部采用了16个LRUCache，然后根据key的前四bits来选则不同的LRUCache</p><h3 id="参考内容">参考内容</h3><ul><li><a href="https://quant67.com/post/db/leveldb/lru-cache.html">leveldb 的缓存结构</a></li><li><a href="https://izualzhy.cn/leveldb-cache">leveldb笔记之11:LRUCache的实现 - Ying's Blog</a></li><li><a href="https://cloud.tencent.com/developer/article/1844910">【深入浅出leveldb】LRU与哈希表 - 云+社区 - 腾讯云</a></li><li><a href="https://segmentfault.com/a/1190000013758197">一个线程安全的 lrucache 实现 --- 读 leveldb 源码 - SegmentFault 思否</a></li><li><a href="http://gao-xiao-long.github.io/2016/05/13/leveldb-cache/">Leveldb1.2 source code analysis -- general module (Cache) - XiaoLong's Blog | XiaoLong's Blog</a></li><li><a href="http://kaiyuan.me/2017/06/12/leveldb-05/">leveldb 笔记五：LRUCache的实现 - Kaiyuan's Blog | May the force be with me</a></li><li><a href="https://zhuanlan.zhihu.com/p/370972240">漫谈 LevelDB 数据结构（三）：LRU 缓存（ LRUCache） - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/45914268">LevelDB源码解析29. 哈希表的实现 - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LevelDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LevelDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LevelDB学习笔记-2-Coding&amp;Arena</title>
      <link href="/posts/1755402587/"/>
      <url>/posts/1755402587/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Util文件夹中保存了LevelDB底层实现中的一些工具类，例如hash，status，coding等工具。这些代码实现简单，我们在阅读源码的时候可以从这里入手，读懂了这些Util工具函数，再去读主函数，可以更好的理解每一步的意义。</p></blockquote><span id="more"></span><h3 id="coding编码">1. Coding编码</h3><p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。如何却分大端与小端，我们只需要记住一句话“所有计算机的内部处理都是小端字节序，所有人类能看到的字节都是大端字节序（网络传输、文件存储等）。既然是LevelDB的源码，那么自然是计算机内部的处理逻辑，也就是按照小端字节序存储的。</p><p>LevelDB的数据分为两种：Fixed（固定大小）、Varint（变长）。对于一个uint32_t类型的整数，无论多大与多小，都需要4个字节来存储。而采用Varint存储，对于小数据我们可以只用1个字节即可。Varint的原理是使用一个bit来表示当前数字是否已经结束，其他的7bit表示数字，7bit能表示的最大数是127，因此小于128的数字都可以用一个字节表示。</p><p>如果使用1bit来作为标识，那么自然4个字节所能表示的数字就变小了，如果原数字是一个很大的数字，将其转换为Varint则可能需要5个字节。既然我们将一个定长的数字转换为变长的数字是为了节约存储空间，那么对于大数字反而需要更多的字节来存储，岂不是本末倒置了嘛。在现实的应用中，很小的概率会遇到所有数据全部为大数据的场景，相反，大多数场景都是以小数据为主的。所以，LevelDB采用Varint可以节省大量的空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint8_t</span>* <span class="keyword">const</span> buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recent clang and gcc optimize this to a single mov / str instruction.</span></span><br><span class="line">  buffer[<span class="number">0</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value);</span><br><span class="line">  buffer[<span class="number">1</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buffer[<span class="number">2</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">16</span>);</span><br><span class="line">  buffer[<span class="number">3</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(value &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">  <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">    *(ptr++) = v;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">14</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">7</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">14</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">28</span>)) &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">21</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = (v &gt;&gt; <span class="number">21</span>) | B;</span><br><span class="line">    *(ptr++) = v &gt;&gt; <span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="arena内存池">2. Arena内存池</h3><p>C++服务器开发过程中，最需要关注的就是内存，因为C++没有内存回收机制，我们要时刻关注内存的申请与释放。LevelDB数据首先写入内存中的MemTable中，对于小数据如果频繁的申请与释放内存会造成大量的内存碎片，一旦内存碎片的数量达到一定数量，我们下一次的申请内存操作将会由于没有连续的内存空间而申请失败，产生内存不够用的假象。</p><p>为了解决这个问题，我们通常需要提前申请一块大的空间作为内存池，对于后续的数据写入内存，由我们程序员进行内存的具体分配。LevelDB的内存池实现简单，它不像STL中的内存池那样复杂、容错性强，因为LevelDB的数据是不断写入的，MemTable中的数据满了之后，立即写入硬盘的SSTable中，所以我们就不必考虑内存的释放，所有的释放操作交给析构函数就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* alloc_ptr_;                <span class="comment">// 当前申请的内存块的指针</span></span><br><span class="line"><span class="keyword">size_t</span> alloc_bytes_remaining_;   <span class="comment">// 当前内存块剩余的bytes</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">char</span>*&gt; blocks_;          <span class="comment">// 记录所有已经分配的内存块</span></span><br><span class="line">std::atomic&lt;<span class="keyword">size_t</span>&gt; memory_usage_;   <span class="comment">// 总共申请的内存数目</span></span><br></pre></td></tr></table></figure><p>这里的 <code>memory_usage_</code> 是一个原子变量，可以在高并发的情况下准确的统计总体的内存使用量。</p><p>Area提供了三个公有接口：Allocate、AllocateAligned和MemoryUsage。</p><h3 id="allocate">3. Allocate</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The semantics of what to return are a bit messy if we allow</span></span><br><span class="line">  <span class="comment">// 0-byte allocations, so we disallow them here (we don&#x27;t need</span></span><br><span class="line">  <span class="comment">// them for our internal use).</span></span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result = alloc_ptr_;</span><br><span class="line">    alloc_ptr_ += bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Allocate函数首先判断当前Block剩余的bytes是否满足用户的需求，满足则直接分配，不满足的话，继续调用私有的AllocateFallback函数进行分配。</p><h4 id="allocatefallback">3.1. AllocateFallback</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// Object is more than a quarter of our block size.  Allocate it separately</span></span><br><span class="line">    <span class="comment">// to avoid wasting too much space in leftover bytes.</span></span><br><span class="line">    <span class="keyword">char</span>* result = <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We waste the remaining space in the current block.</span></span><br><span class="line">  alloc_ptr_ = <span class="built_in">AllocateNewBlock</span>(kBlockSize);</span><br><span class="line">  alloc_bytes_remaining_ = kBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* result = alloc_ptr_;</span><br><span class="line">  alloc_ptr_ += bytes;</span><br><span class="line">  alloc_bytes_remaining_ -= bytes;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到AllocateFallback就意味着 <code>bytes &gt; alloc_bytes_remaining_</code>，如果我们不考虑剩余内存 <code>alloc_bytes_remaining_</code> 的大小，每次都进行重新分配，那么剩余的内存就会产生大量的内存碎片。有的时候并不是剩余内存不够，而是用户需要的内存太大了，此时不仅存在大量的内存碎片，并且碎片还很大。</p><p>LevelDB在此处做了一个优化，设置了一个阈值1k（kBlockSize / 4），如果用户需要的内存大于1k，直接分配相应的内存；否则就申请一个新的Block进行分配。这样可以确保内存碎片的大小不会超过1k。</p><h4 id="allocatenewblock">3.2. AllocateNewBlock</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];</span><br><span class="line">  blocks_.<span class="built_in">push_back</span>(result);</span><br><span class="line">  memory_usage_.<span class="built_in">fetch_add</span>(block_bytes + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>*),</span><br><span class="line">                          std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AllocateNewBlock函数则直接调用了new函数申请内存空间，并且记录当前已使用的空间大小。</p><h3 id="allocatealigned">4. AllocateAligned</h3><p>LevelDB还提供了一种字节对齐的内存申请方法，计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以2,4,或8的 倍数的字节块来读写内存，如此一来就会对基本数据类型的合法地址作出一些限制，即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> align = (<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) &gt; <span class="number">8</span>) ? <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">void</span>*) : <span class="number">8</span>;</span><br><span class="line">  <span class="built_in"><span class="keyword">static_assert</span></span>((align &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;Pointer size should be a power of 2&quot;</span>);</span><br><span class="line">  <span class="keyword">size_t</span> current_mod = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : align - current_mod);</span><br><span class="line">  <span class="keyword">size_t</span> needed = bytes + slop;</span><br><span class="line">  <span class="keyword">char</span>* result;</span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    result = alloc_ptr_ + slop;</span><br><span class="line">    alloc_ptr_ += needed;</span><br><span class="line">    alloc_bytes_remaining_ -= needed;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// AllocateFallback always returned aligned memory</span></span><br><span class="line">    result = <span class="built_in">AllocateFallback</span>(bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(result) &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>align &amp; (align - 1)</code> 用于判断align是否为2的次方。因为2的次方如果转换为二进制是只有一个bit为1的，通过一次与运算，我们可以快速的消除最低位的1 <code>static_assert</code> 是一个静态断言，可以在编译的时候进行检查，确保当前系统指针的大小为2的次方 <code>(alloc_ptr_) &amp; (align - 1)</code> 是一个对align求余的快实现，效率比%运算符要高 <code>slop</code> 是实际是需要补齐的字节，由<code>align - current_mod</code>计算得到。</p>]]></content>
      
      
      <categories>
          
          <category> LevelDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LevelDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LevelDB学习笔记-1-初识</title>
      <link href="/posts/4256717381/"/>
      <url>/posts/4256717381/</url>
      
        <content type="html"><![CDATA[<blockquote><p>LevelDB是Google开源的持久化KV单机数据库，由Google传奇工程师Jeff Dean和Sanjay Ghemawat开发并开源，大神出品必属精品。如果我们将代码看做艺术品的话， LevelDB就属于一件精美的艺术品，值得我们仔细地去欣赏，用心地去感受。当你向一个高级程序员请教如何学习C++，他一定会推荐你去阅读LevelDB的源码，本文以及后续的文章主要用来记录源码学习中的心得体会和一些思考，帮助自己以及阅读文章的你成长为一名出色的工程师。</p></blockquote><span id="more"></span><h3 id="简介">1. 简介</h3><p>相信很多人接触的第一个Key-Value存储数据库是Redis，它是一个纯内存的数据库，存取数据非常的快，但是内存高昂的价格也是Redis不能完全作为数据库来使用的制约。通常都是使用Redis来作为一个缓存，将经常访问的热数据存储在内存之中，长期不被访问的冷数据则被淘汰掉。LevelDB作为一个Key-Value存储引擎，不同于数据库需要提供一个丰富完整的系统、查询语言、事务等特性，存储引擎只需要负责数据的读写即可。内存中放不下的数据，LevelDB就将其写入磁盘中，同时LevelDB保证了数据在磁盘中也可以被快速的读写。</p><p>为什么说磁盘中的数据读写性能很差呢？很大一部分原因是由于磁盘中的读写操作是随机的，磁盘在处理读取和写入请求时，首先根据请求的开始地址算出要处理的数据在磁盘上的位置，之后要进行以下几步工作：</p><ul><li>寻道：磁头移动到数据所在的柱面</li><li>旋转：盘片高速旋转，使磁头到达数据的起始位置</li><li>传输：磁头沿磁道从磁盘读取或写入数据</li></ul><p><img src="6af12fac.png" alt="img" style="zoom:67%;" /></p><p>如果是顺序写的话，只需要进行一次寻道和旋转即可；而随机写则需要进行多次的寻道和旋转，从而导致性能下降。传统的关系型数据库MySQL在将数据写入到磁盘中，并不仅仅只写入数据，还会写入对应的索引。也就是说MySQL是随机写入的，随机性能开销很大。而这也恰恰是LevelDB需要解决的问题，做到顺序的数据落盘。因此LevelDB具有很高的随机写，顺序读/写性能，但是随机读的性能很一般，也就是说，==LevelDB很适合应用在查询较少，而写很多的场景==。</p><h3 id="整体架构">2. 整体架构</h3><p>LevelDB是典型的LSM树(Log Structured-Merge Tree)实现，LSM树的核心思想就是放弃部分读的性能，换取最大的写入能力。为了实现这一特性，就需要尽量尽量减少随机写的次数，原因正如前文所说。对于每次写入操作，并不是直接写入磁盘，而是分成两步执行：1）写入日志；2）写入内存中的MemTable。</p><p><img src="leveldb-architecture.png" alt="leveldb-architecture" style="zoom:67%;" /></p><p>LevelDB的整体架构如上图所示，整体由如下几个组成部分：</p><h4 id="log文件">2.1. Log文件</h4><p>Log文件主要作用是系统发生故障时，能够保证不会丢失数据。LevelDB每次写操作都会首先通过 WAL（Write Ahead Log）的方式记录日志，然后再将数据写入MemTable。因为MemTable是存储在内存中的，如果发生意外导致机器宕机，内存中的数据是无法恢复的，LevelDB可以根据Log文件恢复内存中的MemTable，不会造成系统丢失数据。</p><blockquote><p>WAL日志是很多传统数据库例如MySQL采用的技术，详细解释可以参考<a href="https://zhuanlan.zhihu.com/p/24900322">数据库如何用 WAL 保证事务一致性？ - 知乎专栏</a>。 为什么增加了一步Log操作，性能反而会变高呢？因为Log的写入一直是在文件的末尾追加，而持久化数据库的数据是一个随机写入操作，顺序写会节省大量的磁盘悬臂来回寻址的过程，效率要高好几个量级。</p></blockquote><p>每个Log文件由多个block组成，每个block大小为32K，读取和写入以block为基本单位。下图所示的Log文件包含3个Block：</p><p><img src="log.png" alt="memtablesstable" /></p><h4 id="memtable">2.2. MemTable</h4><p>MemTable是在内存中存储数据的数据结构，其中保存的数据是按照Key的值进行排列的，可以是红黑树或者其他的平衡树，在LevelDB中使用的是跳表(SkipList)。跳表是红黑树的一种替代数据结构，具有更高的写入速度，而且实现起来更加简单。</p><p>当MemTable中的数据量超过设置的限定值 <code>write_buffer_size</code>(默认为 4MB) 时，就会创建一个新的MemTable来接收数据，原来的MemTable则被标记为Immutable MemTable，其内存结构和MemTable是完全一样的，区别仅仅在于它是只读的。Immutable MemTable中的数据会随后被写入磁盘中的 Level 0 中的SSTable进行持久化。</p><h4 id="sstable">2.3. SSTable</h4><p>SSTable是数据在硬盘中存储的文件结构，文件尾部追加了一块索引，记录key <span class="math inline">\(\to\)</span> offset，我们读取文件的时候是倒序读取的，所以优先会读取到这些索引信息。我们就可以根据读取到的索引信息快速锁定SSTable当中的数据而不用读取整个文件了，提高随机读的效率。</p><p>LevelDB在磁盘中的存储分为多个Level（写到这里突然明白了LevelDB是如何命名的，2333），SSTable是整个LevelDB存储数据的核心，其分布在多个Level中，Level 0的SSTable文件由Immutable MemTable直接Dump产生，其他Level的SSTable文件由其上一层的文件和本层文件归并产生，并且每一层设定了一个大小限制：</p><ul><li>Level 0：最多4个SSTabel</li><li>Level 1：总大小不超过10MB</li><li>Level 2：总大小不超过100MB</li><li>Level n：总大小不超过<span class="math inline">\(10^n\)</span>MB</li></ul><p>在这个限制条件下，Level 6 的存储限制已经达到了 1T，Level 7 则达到了 10T。</p><h4 id="manifest">2.4. Manifest</h4><p>SSTable的本质是一个key-value的序列表，并且其中的key是有序的。既然SSTable当中的key是有序的，那么显然就有最大值和最小值。我们把最大值和最小值记录下来就可以在查询的时候快速判断，我们要查询的key它可能在哪些SSTable当中，从而节省时间，加快效率。</p><p>Manifest文件记录各个SSTable各个文件的管理信息，比如该SST文件处于哪个Level，文件名称叫啥，最小key和最大key各自是多少，如下图所示：</p><p><img src="manifest.png" alt="manifest" /></p><h4 id="current">2.5. Current</h4><p>Current是一个指针，指向最后提交的Manifest文件。因为在实际运行当中Manifest文件不止一个，伴随着我们的压缩等操作，都会产生新的Manifest。我们需要一个指针记录下来当前最新的Manifest文件是哪一个，方便查找。并且Manifest当中的数据量并不小，所以我们不能全部都存放在内存当中，放在文件里用一个指针引用是最佳选择。</p><h3 id="写操作">3. 写操作</h3><p><img src="memtablesstable.png" alt="memtablesstable" /></p><p>LevelDB每次写操作都会首先通过 WAL（Write Ahead Log）的方式记录日志，然后将数据写入MemTable 。因为MemTable的底层实现是跳表，可以保证<span class="math inline">\(O(logn)\)</span>的时间复杂度进行数据的插入。当MemTable写入足够多的数据之后，就会将MemTable转化成Immutable MemTable，之后会新建一个空的MemTable应对后续的请求，当dump指令下达之后，会将Immutable MemTable写入成SSTable文件进行存储。</p><p>如前文提到的，Level 0中只能保存4个SSTable，当数量超出之后，LevelDB会执行Compaction压缩策略，这也是LevelDB设计的精彩之处，Google在Bigtable的论文中提出了三种压缩策略：</p><ul><li>Minor Compaction：这种策略十分简单，就是简单地把MemTable中的数据导入到SSTable。</li><li>Major Compaction：这种策略会合并不同Level之间的SSTable文件。</li><li>Full Compaction：这一种策略会将所有的SSTable文件合并。</li></ul><p>其中，Major Compaction是LevelDB分层机制的核心，除了Level 0之外的所有Level都是通过该策略生成的。当某个Level下的SSTable文件数目超过一定设置值后，LevelDB会从这个Level的SSTable中选择一个文件 (Level &gt; 0)，将其和下一层级Level + 1中的SSTable文件进行合并，并放在Level + 1中。</p><blockquote><p>这里需要注意的是Level 0的SSTable文件和其它Level的文件相比有特殊性，Level 0内的SSTable文件，可能存在key重叠，因为我们只是遍历Immutable MemTable的数据，顺序将其写入SSTable。LevelDB更新一条记录时，并不会进行查找替换，而是作为一条新数据写入MemTable，随后写入SSTable中，所以在Level 0中会存在key重叠的现象。对于其它Level的SSTable文件来说，因为他们是通过Compaction压缩策略生成的，该策略就是对已有的记录进行整理压缩，删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。</p></blockquote><p>如果在Level 0中，<strong>则需要将所有key值有重叠的文件都纳入到待合并的集合当中来</strong>。在挑选待合并集合的时候，LevelDB会记录本次触发压缩的最大key值，下一次会选择大于这个key值的文件开始执行压缩。相当于一种轮流机制，<strong>保证Level当中的每一个文件都有被合并的机会</strong>。</p><p>接下来就是从Level + 1当中选择文件了，选择的标准也很简单，将所有和待合并集合中key值有重叠的文件全部挑选出来进行合并。合并的过程本质上是一个多路归并的过程。</p><p>在归并的过程中LevelDB还会对已有的记录进行整理压缩，删除掉一些不再有效的KV数据。由于所有文件当中的key值都是有序的，从它们的头部开始，对于每一个key都会进行判断，是应该保留还是丢弃。判断的逻辑也很简单，对于某一个key而言，如果这个key在更低级的Level中出现过，那么说明有更新的value存在，我们需要进行抛弃。</p><p>当Compaction完成之后，所有参与归并的文件都已经没有用处了，可以进行删除。不论哪一种Compaction的发生，都会改变整个Level的结构，所以需要在每一次Compaction之后，生成一个新的Manifest文件，将此次Compaction带来的文件变动记录进去。最后，将Current指向新生成的Manifest。</p><h3 id="读操作">4. 读操作</h3><p>LevelDB的读取首先在内存中依次查找MemTable、Immutable MemTable，由于都是基于跳表实现的，所以查找效率很高。</p><p>如果没有找到，那么就会读取磁盘中的数据进行查找。LevelDB首先读取Manifest文件，根据Manifest文件中记录key的范围，可以猜测需要查找的key可能出现在哪些SSTable中，只需要查找这些即可，减少查找时间。</p><p>前面说到过LevelDB中同一个key可能存在多个KV对，怎么确定哪个是最新的呢？LevelDB在写入SSTable的时候遵循越晚写入的数据越新的原则，也就是说<strong>Level序号越小的数据越新</strong>。</p><h3 id="参考内容">5. 参考内容</h3><ul><li><a href="https://soulmachine.gitbooks.io/system-design/content/cn/key-value-store.html">Key-Value存储引擎</a></li><li><a href="https://www.cnblogs.com/techflow/p/12585774.html">分布式专题——详解Google levelDB底层原理</a></li><li><a href="https://microsoft.github.io/MLOS/notebooks/LevelDbTuning/">LevelDB parameter tuning using MLOS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LevelDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LevelDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己动手写一个Zsh主题</title>
      <link href="/posts/140195517/"/>
      <url>/posts/140195517/</url>
      
        <content type="html"><![CDATA[<p>之前自己的终端配置是 iTerm2 + Oh My Zsh，使用了<a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a>主题。最近想要重新折腾一遍终端的配置，换换主题和配色。看了很多人的配置，并没有太满意的配置，所以萌生了在大神写的基础上魔改一番，达到自己想要的效果。本文用来记录修改过程中，踩过的坑。</p><span id="more"></span><h3 id="期望效果">1. 期望效果</h3><p>在逛知乎的时候，看到 <a href="https://www.zhihu.com/question/36467150/answer/124076316">vim配色与terminal的背景不一样 - icymindx的回答 - 知乎</a> 这个回答之后，一眼就喜欢上了这个主题。搜索了一番，并没有找到该主题，所以就希望自己可以改一个出来。</p><p><img src="res.jpg" alt="preview" style="zoom:80%;" /></p><h3 id="准备工作">2. 准备工作</h3><p>图片中有一个西瓜的emoji表情，首先我就以 <code>emoji theme</code> 关键字进行搜索，虽然没有找到该主题。但是在 <a href="https://dev.to/laurieontech/adding-an-emoji-status-to-terminal-zsh-4cnd">Adding an Emoji Status to Terminal (ZSH)</a> 这篇文章中，找到了通过修改主题的配置文件来加入emoji的方法。接下来，就是需要找一个主题进行修改。</p><p>在 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">Oh My Zsh theme - GitHub</a> 进行了一番寻找，选择了<a href="https://blog.ysmood.org/my-ys-terminal-theme/">ys主题</a>进行修改，该主题也是一个双行的主题，并且配置十分简单，原本的效果如下所示：</p><p><img src="108255792-be1ede00-716d-11eb-8c26-f7ad7ab3c4f2.jpg" alt="ys" style="zoom:40%;" /></p><p>有了基础主题和目标主题之后，工作就变的简单了，看懂 ys 主题每个命令的含义，然后就可以进行修改了。开始动手之前，还需要先了解一下类 Unix 系统中命令行的一些基础知识。当我们打开一个终端之后， <code>user@machine:~$</code> 这样的部分就叫做命令行提示符（Prompt）。提示符就是提示你输入 Shell 命令用的，每次运行完一个命令后都会再显示一次提示符，等待下一个命令。 在 Shell 中使用 <code>$PS1</code>（Prompt String One） 环境变量来表示。所以我们需要修改的其实就是这个环境变量，可以加入一些特殊的转义字符，Shell 会将它们解析成相应的值。这些转义字符可以参考 <a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html">Zsh 文档</a>。</p><table><thead><tr class="header"><th><strong>转义字符</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr class="odd"><td>%n</td><td>当前用户名</td></tr><tr class="even"><td>%m</td><td>不带域名的本地主机名</td></tr><tr class="odd"><td>%M</td><td>完整的主机名</td></tr><tr class="even"><td>%#</td><td>普通用户显示一个 % 字符，超级用户显示 #</td></tr><tr class="odd"><td>%?</td><td>上一条命令的执行结果</td></tr><tr class="even"><td>%~</td><td>当前工作目录，并使用 ~ 符号替换目录中的 $HOME</td></tr></tbody></table><p>Zsh 提供了几种方便地设置文本颜色的方法：</p><table><colgroup><col style="width: 20%" /><col style="width: 80%" /></colgroup><thead><tr class="header"><th>命令</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>$fg[color]</td><td>设置文本颜色，color 的取值可以是black、red、green、yellow、blue、magenta、cyan、white、default等</td></tr><tr class="even"><td>$fg_bold[color]</td><td>设置文本为粗体同时设定文本颜色</td></tr><tr class="odd"><td>$reset_color</td><td>重置文本颜色为默认颜色</td></tr><tr class="even"><td>$bg[color]</td><td>设置背景颜色</td></tr></tbody></table><h3 id="进行修改">3. 进行修改</h3><p>首先看一下 zsh 的默认主题 <code>robbyrussell</code> 的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PROMPT=&quot;%(?:%&#123;$fg_bold[green]%&#125;➜ :%&#123;$fg_bold[red]%&#125;➜ )&quot;</span><br><span class="line">PROMPT+=&#x27; %&#123;$fg[cyan]%&#125;%c%&#123;$reset_color%&#125; $(git_prompt_info)&#x27;</span><br><span class="line"></span><br><span class="line">ZSH_THEME_GIT_PROMPT_PREFIX=&quot;%&#123;$fg_bold[blue]%&#125;git:(%&#123;$fg[red]%&#125;&quot;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_SUFFIX=&quot;%&#123;$reset_color%&#125; &quot;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_DIRTY=&quot;%&#123;$fg[blue]%&#125;) %&#123;$fg[yellow]%&#125;✗&quot;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_CLEAN=&quot;%&#123;$fg[blue]%&#125;)&quot;</span><br></pre></td></tr></table></figure><p>先看最重要的前两行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROMPT=&quot;%(?:%&#123;$fg_bold[green]%&#125;➜ :%&#123;$fg_bold[red]%&#125;➜ )&quot;</span><br></pre></td></tr></table></figure><p>如果熟悉C++的话，很容易理解这是一个三元表达式，<code>？</code> 在上一条命令执行成功时为 True，其他情况下为 False。在这里就是上一条命令成功的话输出绿色箭头，否则输出红色箭头。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROMPT+=&#x27; %&#123;$fg[cyan]%&#125;%c%&#123;$reset_color%&#125; $(git_prompt_info)&#x27;</span><br></pre></td></tr></table></figure><p>其中，<code>%&#123;$fg[cyan]%&#125;%c%&#123;$reset_color%&#125;</code> 表示输出蓝色的当前目录名，然后重置回默认颜色。<code>git_prompt_info</code> 是 oh-my-zsh 内置函数，功能是解析当前目录的 Git 仓库状态。这个函数后面我们会对齐进行修改。</p><p>另外的 <code>ZSH_THEME_GIT_PROMPT_*</code> 等命令定义了 git 的相关信息展示，整体的效果如下图：</p><p><img src="108254738-764b8700-716c-11eb-9a59-4deb8c8c6193.jpg" alt="robbyrussell" style="zoom:40%;" /></p><h4 id="ys主题代码修改">3.1 ys主题代码修改</h4><p>我们通过默认主题 <code>robbyrussell</code> 的代码，熟悉了下基本的语法，接下来就来进行 ys 主题代码的修改。</p><p>首先，确定我们需要什么信息，通过<a href="https://github.com/ohmyzsh/ohmyzsh/blob/master/themes/bira.zsh-theme">bira主题</a>的启发，可以将 <code>PROMPT</code> 定义为多个变量的组合形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PROMPT=&quot;$&#123;user_host&#125;: $&#123;current_dir&#125;$&#123;git_info&#125;$&#123;git_sha&#125;$&#123;time_info&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;emoji&#125;<span class="string">&quot;</span></span></span><br></pre></td></tr></table></figure><p>我们先定义简单的信息内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local user_host=&#x27;%&#123;$terminfo[bold]$fg[blue]%&#125;%n.mbp%&#123;$reset_color%&#125;&#x27;    # 蓝色的用户名.mbp</span><br><span class="line">local current_dir=&#x27;%&#123;$terminfo[bold]$fg[yellow]%&#125;%~ %&#123;$reset_color%&#125;&#x27;   # 黄色的当前文件夹路径 </span><br><span class="line">local time_info=&#x27;%&#123;$fg[white]%&#125;[%*]%&#123;$reset_color%&#125;&#x27;   # 白色的时间信息</span><br><span class="line">local emoji=&quot;🍉  &quot;</span><br></pre></td></tr></table></figure><p>对于 git 信息，参考了 <a href="https://www.zhihu.com/question/33277508/answer/205705091">oh my zsh 哪些主题比较好看、有特点？ - 木童的回答 - 知乎</a> 答主分享的 <a href="https://github.com/iplaces/astro-zsh-theme/blob/master/astro.zsh-theme">Astro主题</a> ，其效果图为：</p><p><img src="image-20210520132234693.png" alt="image-20210520132234693" style="zoom:50%;" /></p><p>但是，这里有一个小问题，无论有无修改，<code>git_sha</code> 部分都是红色的。我希望将其改成动态的，有修改时为红色，无修改时为绿色。Google搜索了一番，找到了答案 <a href="https://stackoverflow.com/questions/41474467/zsh-theme-dirty-color-and-suffix">Zsh theme: dirty color and suffix</a> 。可以通过对 oh-my-zsh 的内置函数 <code>git_prompt_info</code> 进行重写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">git_prompt_info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  local ref</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;$(command git config --get oh-my-zsh.hide-status 2&gt;/dev/null)&quot;</span> != <span class="string">&quot;1&quot;</span> ]]; then</span><br><span class="line">    ref=$(command git symbolic-ref HEAD <span class="number">2</span>&gt; <span class="regexp">/dev/</span><span class="literal">null</span>) || \</span><br><span class="line">    ref=$(command git rev-parse --short HEAD <span class="number">2</span>&gt; <span class="regexp">/dev/</span><span class="literal">null</span>) || <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    # Checks <span class="keyword">if</span> working tree is dirty</span><br><span class="line">    local STATUS=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    local FLAGS</span><br><span class="line">    FLAGS=(<span class="string">&#x27;--porcelain&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;$(command git config --get oh-my-zsh.hide-dirty)&quot;</span> != <span class="string">&quot;1&quot;</span> ]]; then</span><br><span class="line">      <span class="keyword">if</span> [[ $POST_1_7_2_GIT -gt <span class="number">0</span> ]]; then</span><br><span class="line">        FLAGS+=<span class="string">&#x27;--ignore-submodules=dirty&#x27;</span></span><br><span class="line">      fi</span><br><span class="line">      <span class="keyword">if</span> [[ <span class="string">&quot;$DISABLE_UNTRACKED_FILES_DIRTY&quot;</span> == <span class="string">&quot;true&quot;</span> ]]; then</span><br><span class="line">        FLAGS+=<span class="string">&#x27;--untracked-files=no&#x27;</span></span><br><span class="line">      fi</span><br><span class="line">      STATUS=$(command git status $&#123;FLAGS&#125; <span class="number">2</span>&gt; <span class="regexp">/dev/</span><span class="literal">null</span> | tail -n1)</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ -n $STATUS ]]; then</span><br><span class="line">      GIT_PROMPT_COLOR=<span class="string">&quot;$ZSH_THEME_GIT_PROMPT_DIRTY&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      GIT_PROMPT_COLOR=<span class="string">&quot;$ZSH_THEME_GIT_PROMPT_CLEAN&quot;</span></span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo <span class="string">&quot;$ZSH_THEME_GIT_PROMPT_PREFIX$&#123;ref#refs/heads/&#125;$GIT_PROMPT_COLOR$ZSH_THEME_GIT_PROMPT_SUFFIX&quot;</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>$STATUS</code> 变量的值，来控制 <code>GIT_PROMPT_COLOR</code> 对应的颜色，最终得到下图的结果：</p><p><img src="image-20210520133300826.png" alt="image-20210520133300826" style="zoom:50%;" /></p><p>还有一个小缺陷，就是两个命令之间太紧凑了，希望加一个空行来进行分割，一开始我是参考 <a href="https://unix.stackexchange.com/questions/53789/whats-the-newline-symbol-in-zshs-ps1">What's the newline symbol in zsh's PS1?</a> 在 PROMPT 中加入 <code>NEWLINE=$'\n'</code> 来实现的。但是这样做，在我们打开终端的时候也会产生一个换行，对于强迫症来说，这是不可忍受的。所以，我继续Google搜索解决方法，最终找到了一个特别NB的解法 <a href="https://stackoverflow.com/questions/20512957/zsh-new-line-prompt-after-each-command">zsh new line prompt after each command</a>，具体做法是在 <code>.zshrc</code> 文件中加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">precmd() &#123; precmd() &#123; echo &#125; &#125;</span><br></pre></td></tr></table></figure><p>这个真的是太trick了，当我们启动终端的时候，执行 <code>precmd()</code> 将其替换为 <code>precmd() &#123; echo &#125;</code> ，之后的每一条命令都会执行 <code>echo</code> 来进行换行，最终得到了我想要的效果。</p><p><img src="image-20210520141622412.png" alt="image-20210520141622412" style="zoom:50%;" /></p><h3 id="进阶操作">4. 进阶操作</h3><h4 id="字体颜色">4.1 字体颜色</h4><p>上文提到过 <code>$fg[color]</code> 只支持black、red、green、yellow、blue、magenta、cyan、white、default等选项。我希望能够使用更多的颜色，经过一番搜索，找到了我想要的答案 <a href="https://dev.to/yujinyuz/custom-colors-in-oh-my-zsh-themes-4h13">Custom colors in oh-my-zsh themes</a>。</p><p><img src="h70s2gr8ixj5v9sjwq7z.jpeg" alt="Alt Text" style="zoom:80%;" /></p><p>如上图所示，我们只需要使用 <code>$FG[&lt;0-255&gt;]</code> 就可以使用对应的颜色了。<font color='red'><strong>但是一定要确保 terminal 是支持 256-color 的。</strong></font></p><h4 id="显示python环境">4.2 显示Python环境</h4><p>当安装了Anaconda之后，默认会出现一个 (base) 的标识，这是因为conda会对 <code>PS1</code> 进行修改，我们要禁止这个修改操作<a href="https://stackoverflow.com/questions/36499220/anaconda-disable-prompt-change">Anaconda: disable prompt change</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> conda config --<span class="built_in">set</span> changeps1 False</span></span><br></pre></td></tr></table></figure><p>接下来，修改我们的主题配置文件，让conda的环境信息出现在我们指定的位置，参考 <a href="https://github.com/lyytaw/taw-ys.zsh-theme">taw-ys主题</a> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Python info</span><br><span class="line">local python_info=<span class="string">&#x27;$(python_prompt_info)&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">python_prompt_info</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;$(command -v python &gt; /dev/null 2&gt;&amp;1)&quot;</span> != <span class="string">&quot;1&quot;</span> ]]; then</span><br><span class="line">    PYTHON_VERSION=<span class="string">&quot;$(python -V 2&gt;&amp;1)&quot;</span></span><br><span class="line">    # remove space</span><br><span class="line">    PYTHON_VERSION=$&#123;PYTHON_VERSION/Python /Python&#125;</span><br><span class="line">    PYTHON_VERSION=$&#123;PYTHON_VERSION/ */&#125;</span><br><span class="line"></span><br><span class="line">    CONDA_DEFAULT_ENV_NAME=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;$CONDA_DEFAULT_ENV&quot;</span> ]; then</span><br><span class="line">      CONDA_DEFAULT_ENV_NAME=<span class="string">&quot;$CONDA_DEFAULT_ENV::&quot;</span></span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo <span class="string">&quot; %&#123;$fg[yellow]%&#125;($&#123;CONDA_DEFAULT_ENV_NAME&#125;$&#123;PYTHON_VERSION&#125;)%&#123;$reset_color%&#125;&quot;</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"># Clean, simple, compatible and meaningful.</span><br><span class="line"># Tested on Linux, Unix and Windows under ANSI colors.</span><br><span class="line"># It is recommended to use with a dark background.</span><br><span class="line"># Colors: black, red, green, yellow, *blue, magenta, cyan, and white.</span><br><span class="line">#</span><br><span class="line"># Mar 2013 Yad Smood</span><br><span class="line"></span><br><span class="line">typeset +H my_gray=&quot;$FG[247]&quot;</span><br><span class="line"></span><br><span class="line"># VCS</span><br><span class="line">YS_VCS_PROMPT_PREFIX=&quot;%&#123;$fg_bold[white]%&#125;[%&#123;$reset_color%&#125;%&#123;$fg_bold[cyan]%&#125;&quot;</span><br><span class="line">YS_VCS_PROMPT_PREFIX1=&quot; %&#123;$fg[white]%&#125;on%&#123;$reset_color%&#125; &quot;</span><br><span class="line">YS_VCS_PROMPT_PREFIX2=&quot;:%&#123;$fg[cyan]%&#125;&quot;</span><br><span class="line">YS_VCS_PROMPT_SUFFIX=&quot;&quot;</span><br><span class="line">YS_VCS_PROMPT_DIRTY=&quot; %&#123;$fg[red]%&#125;x&quot;</span><br><span class="line">YS_VCS_PROMPT_CLEAN=&quot; %&#123;$fg[green]%&#125;o&quot;</span><br><span class="line"></span><br><span class="line"># Git short sha</span><br><span class="line">local git_sha=&#x27;$(git_prompt_short_sha)&#x27;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_SHA_BEFORE=&quot;(&quot;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_SHA_AFTER=&quot;)%&#123;$reset_color%&#125;%&#123;$fg_bold[white]%&#125;]%&#123;$reset_color%&#125; &quot;</span><br><span class="line"></span><br><span class="line"># Git info</span><br><span class="line">local git_info=&#x27;$(git_prompt_info)&#x27;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_PREFIX=&quot;$YS_VCS_PROMPT_PREFIX&quot;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_SUFFIX=&quot;$YS_VCS_PROMPT_SUFFIX&quot;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_DIRTY=&quot;$YS_VCS_PROMPT_DIRTY&quot;</span><br><span class="line">ZSH_THEME_GIT_PROMPT_CLEAN=&quot;$YS_VCS_PROMPT_CLEAN&quot;</span><br><span class="line"></span><br><span class="line"># HG info</span><br><span class="line">local hg_info=&#x27;$(ys_hg_prompt_info)&#x27;</span><br><span class="line">ys_hg_prompt_info() &#123;</span><br><span class="line"># make sure this is a hg dir</span><br><span class="line">if [ -d &#x27;.hg&#x27; ]; then</span><br><span class="line">echo -n &quot;$&#123;YS_VCS_PROMPT_PREFIX1&#125;hg$&#123;YS_VCS_PROMPT_PREFIX2&#125;&quot;</span><br><span class="line">echo -n $(hg branch 2&gt;/dev/null)</span><br><span class="line">if [[ &quot;$(hg config oh-my-zsh.hide-dirty 2&gt;/dev/null)&quot; != &quot;1&quot; ]]; then</span><br><span class="line">if [ -n &quot;$(hg status 2&gt;/dev/null)&quot; ]; then</span><br><span class="line">echo -n &quot;$YS_VCS_PROMPT_DIRTY&quot;</span><br><span class="line">else</span><br><span class="line">echo -n &quot;$YS_VCS_PROMPT_CLEAN&quot;</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line">echo -n &quot;$YS_VCS_PROMPT_SUFFIX&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Virtualenv</span><br><span class="line">local venv_info=&#x27;$(virtenv_prompt)&#x27;</span><br><span class="line">YS_THEME_VIRTUALENV_PROMPT_PREFIX=&quot; %&#123;$fg[green]%&#125;&quot;</span><br><span class="line">YS_THEME_VIRTUALENV_PROMPT_SUFFIX=&quot; %&#123;$reset_color%&#125;%&quot;</span><br><span class="line">virtenv_prompt() &#123;</span><br><span class="line">[[ -n $&#123;VIRTUAL_ENV&#125; ]] || return</span><br><span class="line">echo &quot;$&#123;YS_THEME_VIRTUALENV_PROMPT_PREFIX&#125;$&#123;VIRTUAL_ENV:t&#125;$&#123;YS_THEME_VIRTUALENV_PROMPT_SUFFIX&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">local exit_code=&quot;%(?,,C:%&#123;$fg[red]%&#125;%?%&#123;$reset_color%&#125;)&quot;</span><br><span class="line"></span><br><span class="line"># Python info</span><br><span class="line">local python_info=&#x27;$(python_prompt_info)&#x27;</span><br><span class="line">function python_prompt_info() &#123;</span><br><span class="line">  if [[ &quot;$(command -v python &gt; /dev/null 2&gt;&amp;1)&quot; != &quot;1&quot; ]]; then</span><br><span class="line">    PYTHON_VERSION=&quot;$(python -V 2&gt;&amp;1)&quot;</span><br><span class="line">    # remove space</span><br><span class="line">    PYTHON_VERSION=$&#123;PYTHON_VERSION/Python /Python&#125;</span><br><span class="line">    PYTHON_VERSION=$&#123;PYTHON_VERSION/ */&#125;</span><br><span class="line"></span><br><span class="line">    CONDA_DEFAULT_ENV_NAME=&#x27;&#x27;</span><br><span class="line">    if [ -n &quot;$CONDA_DEFAULT_ENV&quot; ]; then</span><br><span class="line">      CONDA_DEFAULT_ENV_NAME=&quot;$CONDA_DEFAULT_ENV::&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo &quot; %&#123;$fg[yellow]%&#125;($&#123;CONDA_DEFAULT_ENV_NAME&#125;$&#123;PYTHON_VERSION&#125;)%&#123;$reset_color%&#125;&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Prompt format:</span><br><span class="line">#</span><br><span class="line"># PRIVILEGES USER @ MACHINE in DIRECTORY on git:BRANCH STATE [TIME] C:LAST_EXIT_CODE</span><br><span class="line"># $ COMMAND</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line"># % ys @ ys-mbp in ~/.oh-my-zsh on git:master x [21:47:42] C:0</span><br><span class="line"># $</span><br><span class="line"></span><br><span class="line">local user_host=&#x27;%&#123;$terminfo[bold]$fg[blue]%&#125;%n.mbp%&#123;$reset_color%&#125;&#x27;    # 蓝色的用户名.mbp</span><br><span class="line">local current_dir=&#x27;%&#123;$terminfo[bold]$fg[yellow]%&#125;%~ %&#123;$reset_color%&#125;&#x27;   # 黄色的当前文件夹路径</span><br><span class="line">local time_info=&#x27;%&#123;$fg[Silver]%&#125;[%*]%&#123;$reset_color%&#125;&#x27;   # 白色的时间信息</span><br><span class="line">local emoji=&quot;🍉  &quot;</span><br><span class="line"></span><br><span class="line">PROMPT=&quot;$&#123;user_host&#125;: $&#123;current_dir&#125;$&#123;git_info&#125;$&#123;git_sha&#125;$&#123;time_info&#125;$&#123;python_info&#125;</span><br><span class="line">$&#123;emoji&#125;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最终效果">5. 最终效果</h3><p><img src="image-20210520153705118.png" alt="image-20210520153705118" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zsh </tag>
            
            <tag> iterm2 </tag>
            
            <tag> terminal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务网格ServiceMesh介绍</title>
      <link href="/posts/451856931/"/>
      <url>/posts/451856931/</url>
      
        <content type="html"><![CDATA[<blockquote><p>服务网格（Service Mesh）是致力于解决服务间通讯的基础设施层。它负责在现代云原生应用程序的复杂服务拓扑来可靠地传递请求。实际上，Service Mesh 通常是通过一组轻量级网络代理（Sidecar proxy），与应用程序代码部署在一起来实现，而无需感知应用程序本身。</p></blockquote><span id="more"></span><h3 id="什么是服务网格">1. 什么是服务网格</h3>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务网格 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11实现的线程池</title>
      <link href="/posts/4145197150/"/>
      <url>/posts/4145197150/</url>
      
        <content type="html"><![CDATA[<blockquote><p>线程池可以帮助我们简单高效的实现高并发。并且大幅度的提高服务器的效率。</p></blockquote><span id="more"></span><h3 id="什么是线程池">1.什么是线程池</h3><p>在有些工作场景中，比如说服务器编程中，如果为每一个客户都分配一个新的工作线程，并且当工作线程与客户通信结束时，这个线程被销毁，这就需要频繁的切换工作线程，这会带来一些负担，最主要的是系统大的开销和系统资源不足问题。</p><p>线程池可以很好的帮助我们解决线程重复创建、销毁的问题。在程序启动的时候，我们预先创建一定数量的线程，并向外提供一个 commit 的接口，来提交任务。新提交的任务会被放进任务队列，然后条件变量会通知一个线程，当前任务队列不为空。被唤醒的线程就可以从任务队列中取出一个任务，并执行。</p><p>工作流程，如下图所示。</p><p><img src="image-20200322214436778.png" alt="image-20200322214436778" /></p><ul><li>Task Queue：任务队列，用户 commit 的任务都保存在这里。</li><li>Thread Pool：用一个数组来保存我们启动的线程。</li><li>Completed Tasks：当线程完成任务之后，我们需要告知提交者。</li></ul><h3 id="代码">2. 代码</h3><p>首先，我们先来看一下线程池需要什么数据成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> nums_;                      <span class="comment">// 线程数量</span></span><br><span class="line"> <span class="keyword">bool</span> stoped_;                   <span class="comment">// 是否停止</span></span><br><span class="line"> vector&lt;thread&gt; threads_;        <span class="comment">// 线程数组</span></span><br><span class="line"> queue&lt;Task&gt; tasks_;             <span class="comment">// 任务队列</span></span><br><span class="line"> mutex mutex_;                   <span class="comment">// 同步</span></span><br><span class="line"> condition_variable condition_;  <span class="comment">// 条件变量</span></span><br></pre></td></tr></table></figure><p>再来看一下构造函数的实现，在构造函数中，我们需要启动指定数量的线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> size)</span> : nums_(size), stoped_(false) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums_; ++i) &#123;</span><br><span class="line">    threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Task task;</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 阻塞等待任务的到来</span></span><br><span class="line">          UniqueLock <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;mutex_);</span><br><span class="line">          <span class="keyword">this</span>-&gt;condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stoped_ || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>();</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="comment">// 检查是否终止</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stoped_ &amp;&amp; <span class="keyword">this</span>-&gt;tasks.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">          <span class="comment">// 从任务队列中读取任务</span></span><br><span class="line">          task = <span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>());</span><br><span class="line">          <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>析构函数中，我们需要把线程关闭。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">  <span class="comment">// 设置停止标志，并且唤醒所有的线程</span></span><br><span class="line">  stoped_ = <span class="literal">true</span>;</span><br><span class="line">  condition_.<span class="built_in">notify_all</span>();</span><br><span class="line">  <span class="comment">// 关闭线程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，就是最重要的 commit 提交任务函数。这个函数需要满足以下两点要求：</p><ul><li>接受任务函数，以及任意数量参数</li><li>可以支持返回函数的运行结果</li></ul><p>对于第一点，我们需要实现一个模板函数，这里我们使用C++11中的<strong>变长参数模板</strong>来接受任意数量的参数。接下来最难的一点就是如何动态的确定函数的返回类型。得益于C++11的 <code>decltype</code> 以及 <code>future</code> 我们可以很容易的实现这一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> ReturnType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 返回类型</span></span><br><span class="line">  <span class="comment">// 创建一个函数来绑定变长的参数，这样就可以通过func()完成函数的调用</span></span><br><span class="line">  function&lt;<span class="built_in">ReturnType</span>()&gt; func = <span class="built_in">bind</span>(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...);</span><br><span class="line">  <span class="comment">// 接下来创建一个指向函数的指针</span></span><br><span class="line">  <span class="keyword">auto</span> task_ptr = make_shared&lt;packaged_task&lt;<span class="built_in">ReturnType</span>()&gt; &gt;(func);</span><br><span class="line">  <span class="comment">// 因为任务队列中的变量类型是function&lt;void()&gt;</span></span><br><span class="line">  <span class="comment">// 所以我们需要把提交的任务，转变成function&lt;void()&gt;</span></span><br><span class="line">  Task task = [task_ptr]() &#123; (*task_ptr)(); &#125;;</span><br><span class="line">  <span class="comment">// 接下来，把任务添加到队列中</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">UniqueLock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    tasks_.<span class="built_in">emplace</span>(<span class="built_in">move</span>(task));</span><br><span class="line">    condition_.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>future&lt;decltype(f(args))&gt;</code> 就是我们要返回的类型，它是一个 future 变量。</p><p>完整的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Task = function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line">  <span class="keyword">using</span> UniqueLock = unique_lock&lt;mutex&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ThreadPool</span><span class="params">(<span class="keyword">int</span> size)</span> : nums_(size), stoped_(false) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums_; ++i) &#123;</span><br><span class="line">      threads_.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>] &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">          Task task;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// 阻塞等待任务的到来</span></span><br><span class="line">            UniqueLock <span class="built_in">lock</span>(<span class="keyword">this</span>-&gt;mutex_);</span><br><span class="line">            <span class="keyword">this</span>-&gt;condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">this</span>-&gt;stoped_ || !<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 检查是否终止</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stoped_ &amp;&amp; <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 从任务队列中读取任务</span></span><br><span class="line">            task = <span class="built_in">move</span>(<span class="keyword">this</span>-&gt;tasks_.<span class="built_in">front</span>());</span><br><span class="line">            <span class="keyword">this</span>-&gt;tasks_.<span class="built_in">pop</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 执行任务</span></span><br><span class="line">          <span class="built_in">task</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">ThreadPool</span>() &#123;</span><br><span class="line">    <span class="comment">// 设置停止标志，并且唤醒所有的线程</span></span><br><span class="line">    stoped_ = <span class="literal">true</span>;</span><br><span class="line">    condition_.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="comment">// 关闭线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> ReturnType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));  <span class="comment">// 返回类型</span></span><br><span class="line">    <span class="comment">// 创建一个函数来绑定变长的参数，这样就可以通过func()完成函数的调用</span></span><br><span class="line">    function&lt;<span class="built_in">ReturnType</span>()&gt; func = <span class="built_in">bind</span>(forward&lt;F&gt;(f), forward&lt;Args&gt;(args)...);</span><br><span class="line">    <span class="comment">// 接下来创建一个指向函数的指针</span></span><br><span class="line">    <span class="keyword">auto</span> task_ptr = make_shared&lt;packaged_task&lt;<span class="built_in">ReturnType</span>()&gt; &gt;(func);</span><br><span class="line">    <span class="comment">// 因为任务队列中的变量类型是function&lt;void()&gt;</span></span><br><span class="line">    <span class="comment">// 所以我们需要把提交的任务，转变成function&lt;void()&gt;</span></span><br><span class="line">    Task task = [task_ptr]() &#123; (*task_ptr)(); &#125;;</span><br><span class="line">    <span class="comment">// 接下来，把任务添加到队列中</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">UniqueLock <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">      tasks_.<span class="built_in">emplace</span>(<span class="built_in">move</span>(task));</span><br><span class="line">      condition_.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task_ptr-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> nums_;                      <span class="comment">// 线程数量</span></span><br><span class="line">  <span class="keyword">bool</span> stoped_;                   <span class="comment">// 是否停止</span></span><br><span class="line">  vector&lt;thread&gt; threads_;        <span class="comment">// 线程数组</span></span><br><span class="line">  queue&lt;Task&gt; tasks_;             <span class="comment">// 任务队列</span></span><br><span class="line">  mutex mutex_;                   <span class="comment">// 同步</span></span><br><span class="line">  condition_variable condition_;  <span class="comment">// 条件变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="测试">3. 测试</h3><p>首先，我们来测试下是否是多线程在工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ostringstream oss;</span><br><span class="line">  oss &lt;&lt; this_thread::<span class="built_in">get_id</span>();</span><br><span class="line">  string stid = oss.<span class="built_in">str</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;tid=%s, hello world\n&quot;</span>, stid.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">  pool.<span class="built_in">commit</span>(func1);</span><br><span class="line">  pool.<span class="built_in">commit</span>(func1);</span><br><span class="line">  pool.<span class="built_in">commit</span>(func1);</span><br><span class="line">  pool.<span class="built_in">commit</span>(func1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20200322223736841.png" alt="image-20200322223736841" /></p><p>可以看到，确实是4个线程在工作。我们接着测试下 future 的威力。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> res = a * b;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">  <span class="keyword">auto</span> future = pool.<span class="built_in">commit</span>(multiply, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> result = future.<span class="built_in">get</span>();</span><br><span class="line">  cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20200322223940342.png" alt="image-20200322223940342" /></p><p>参考：</p><p><a href="https://github.com/mtrebi/thread-pool">Thread pool implementation using c++11 threads</a></p><p><a href="https://www.cnblogs.com/lzpong/p/6397997.html">基于C++11的线程池(threadpool),简洁且可以带任意多的参数</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现一个线程安全的队列</title>
      <link href="/posts/3147727553/"/>
      <url>/posts/3147727553/</url>
      
        <content type="html"><![CDATA[<blockquote><p>队列在我们写程序中经常遇到，它是一种先进先出的数据结构。C++中的STL提供了一个队列容器 <code>std::queue</code> 但这个容器并不是线程安全的，如果在多线程环境下使用队列，它是不能直接拿来用的。本文介绍几种实现线程安全的队列的方法。</p></blockquote><span id="more"></span><h3 id="阻塞队列">1. 阻塞队列</h3><p>顾名思义，阻塞队列就是把临界区加锁，给它保护起来。当我们把数据成功加入元素之后，通过条件变量通知。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockingQueue</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> lock_guard&lt;mutex&gt; LockGuard;</span><br><span class="line">  <span class="keyword">typedef</span> unique_lock&lt;mutex&gt; UniqueLock;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BlockingQueue</span>() : <span class="built_in">m_queue_</span>(), <span class="built_in">m_condition_</span>(), <span class="built_in">m_mutex_</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">BlockingQueue</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BlockingQueue</span>(<span class="keyword">const</span> BlockingQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  BlockingQueue&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> BlockingQueue&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="function">LockGuard <span class="title">lock</span><span class="params">(m_mutex_)</span></span>;</span><br><span class="line">    m_queue_.<span class="built_in">push_back</span>(x);</span><br><span class="line">    m_condition_.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(T&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="function">LockGuard <span class="title">lock</span><span class="params">(m_mutex_)</span></span>;</span><br><span class="line">    m_queue_.<span class="built_in">push_back</span>(<span class="built_in">move</span>(x));</span><br><span class="line">    m_condition_.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">UniqueLock <span class="title">lock</span><span class="params">(m_mutex_)</span></span>;</span><br><span class="line">    m_condition_.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !<span class="keyword">this</span>-&gt;m_queue_.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line">    <span class="built_in">assert</span>(!m_queue_.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">ret</span><span class="params">(move(m_queue_.front()))</span></span>;</span><br><span class="line">    m_queue_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_queue_.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  deque&lt;T&gt; m_queue_;</span><br><span class="line">  condition_variable m_condition_;</span><br><span class="line">  mutex m_mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="cas无锁队列">2. CAS无锁队列</h3><p>CAS（<strong>Compare And Swap</strong>）机制，翻译过来就是比较并替换。CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CAS</span><span class="params">(T* reg, T oldvalue, T newval)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (*reg == oldvalue) &#123;</span><br><span class="line">    *reg = newval;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  <span class="built_in">ListNode</span>(<span class="keyword">int</span> v) : <span class="built_in">val</span>(v), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockFreeQueue</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LockFreeQueue</span>() : <span class="built_in">head</span>(<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>)), <span class="built_in">tail</span>(head) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(x);</span><br><span class="line">    ListNode *p = tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (p-&gt;next) p = p-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (__sync_bool_compare_and_swap(&amp;p-&gt;next, <span class="literal">nullptr</span>, node) == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    __sync_bool_compare_and_swap(&amp;tail, p, node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode *node = head;</span><br><span class="line">    ListNode *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = head;</span><br><span class="line">    &#125; <span class="keyword">while</span> (__sync_bool_compare_and_swap(&amp;head, p, p-&gt;next) == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = node-&gt;next-&gt;val;</span><br><span class="line">    <span class="keyword">delete</span> node-&gt;next;</span><br><span class="line">    node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ListNode *head;</span><br><span class="line">  ListNode *tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发之无锁编程</title>
      <link href="/posts/1530832084/"/>
      <url>/posts/1530832084/</url>
      
        <content type="html"><![CDATA[<blockquote><p>多线程编程中最令人头疼的就是如何处理好同步的问题，因为同一个进程中的线程共享地址空间，所以对于全局变量和静态变量，每个线程都可能去修改它，作为一名优秀的程序员，我们就要想办法保证这个变量最后的结果是正确的。</p></blockquote><span id="more"></span><h3 id="多线程并发读写">1.多线程并发读写</h3><p>我们先通过一个简单的例子来理解多线程模式下变量是如何被修改的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    ++g_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    ++g_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * N; ++i) &#123;</span><br><span class="line">    ++g_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">clock_t</span> now = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="built_in">normal</span>();</span><br><span class="line">  <span class="keyword">clock_t</span> end = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_cnt);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;one thread total time = %.2f ms\n\n\n&quot;</span>,</span><br><span class="line">         <span class="number">1.0</span> * (end - now) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  g_cnt = <span class="number">0</span>;</span><br><span class="line">  now = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  end = <span class="built_in">clock</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_cnt);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;two thread total time = %.2f ms\n&quot;</span>,</span><br><span class="line">         <span class="number">1.0</span> * (end - now) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20200321223002894.png" alt="image-20200321223002894" /></p><p>通过上面的实验，两个线程对一个全局变量进行加一操作，正确结果应该是200 0000，但是由于++操作并不是原子的，所以导致结果错误，并且耗时是单线程的3倍。</p><p>接下来，我们给每次操作加上一个锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ++g_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="function">lock_guard&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    ++g_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20200321234528790.png" alt="image-20200321234528790" /></p><p>可以看到，时间飙升，是单线程的60倍。因为加了锁，没有获得锁的线程就会被阻塞，所以程序就会频繁的进行线程调度，我们知道线程之间的切换虽然比进程之间的要快很多，但还是有一定的开销。</p><h3 id="无锁编程">2.无锁编程</h3><p>要想了解无锁编程，首先需要了解的就是CAS（<strong>Compare And Swap</strong>）机制，翻译过来就是比较并替换。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p>只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p><p>为什么这样的操作在多线程环境下能做到同步呢？我们逐步分析一个多线程的实例。</p><p><img src="image-20200321235507256.png" alt="image-20200321235507256" /></p><p>假设在内存地址V中存储着值为10的变量。线程1想要把变量的值增加1，对于线程1来说，旧的预期值A=10，要修改的新值B=11。</p><p><img src="image-20200321235749057.png" alt="image-20200321235749057" /></p><p>在线程1要提交更新之前，线程2抢先一步，把内存地址V中的变量值率先改成了11。</p><p><img src="image-20200321235903164.png" alt="image-20200321235903164" /></p><p>线程1获得了控制权，在提交更新前，比较 A 的值与 V 的值不相等，提交失败。线程1重新获取内存地址V的当前值，并重新计算想要修改的新值，此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</p><p>最后线程1比较 A 的值和 V 的值相等，所以把 B 的值写入 V 中。</p><p>从思想上来说，Mutex 属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。</p><p>所以，我们可以把 g_cnt 改成原子变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">g_cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="image-20200322000557274.png" alt="image-20200322000557274" /></p><p>可以发现，时间减少了1倍。</p><h3 id="总结">3. 总结</h3><p>无锁编程最大的优势是什么？是性能提高吗？其实并不是，我们的测试代码中临界区非常短，只有一个语句，所以显得加锁解锁操作对程序性能影响很大，但在实际应用中，我们的临界区一般不会这么短，临界区越长，加锁和解锁操作的性能损耗越微小，无锁编程和有锁编程之间的性能差距也就越微小。</p><p>CAS的缺点：</p><ul><li>CPU开销较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</li><li>不能保证代码块的原子性</li></ul><p>CAS的优点：</p><ul><li>避免了死锁的产生。</li><li>代码更加清晰与简洁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写智能指针unique_ptr</title>
      <link href="/posts/2249257722/"/>
      <url>/posts/2249257722/</url>
      
        <content type="html"><![CDATA[<blockquote><p>拥抱智能指针，告别内存泄漏。智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p></blockquote><span id="more"></span><h3 id="什么是unique_ptr">1. 什么是unique_ptr</h3><p><code>std::unique_ptr</code> 实现了独占的思想，一个非空的 <code>std::unique_ptr</code> 永远拥有它指向的对象，并且无法被拷贝。因为，如果允许拷贝，那么就有两个 <code>std::unique_ptr</code> 指向相同的地方，每个指针都认为自己拥有销毁该对象的权利。</p><h3 id="成员函数">2. 成员函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get: 返回指向被管理对象的指针；</span><br><span class="line">get_deleter：返回用于析构被管理对象的删除器；</span><br><span class="line">swap：交换所管理的对象；</span><br><span class="line">reset：替换所管理的对象；</span><br><span class="line">release：返回一个指向被管理对象的指针，并释放所有权；</span><br><span class="line">operator bool：检查是否有关联的被管理对象；</span><br><span class="line">operator=：为unique_ptr赋值；</span><br><span class="line">operator*和operator-&gt;：解引用存储的对象指针。</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li><code>unique_ptr&lt;int&gt; p = new int</code> 是不合法的，不能将指针直接赋值给一个智能指针对象。</li><li>不能把一个原生指针交给两个智能指针对象管理，对其它智能指针也是如此。</li></ul><h3 id="代码实现">3. 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultDeleter</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* p)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;deleter!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = DefaultDeleter&gt;</span><br><span class="line">class unique_ptr &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">  Deleter m_del;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span> : m_ptr(ptr) &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">unique_ptr</span>() &#123; <span class="built_in">m_del</span>(m_ptr); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 禁止拷贝</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动构造</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; moving) <span class="keyword">noexcept</span> &#123; moving.<span class="built_in">swap</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; moving) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    moving.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取指针</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> *m_ptr; &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">  <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> m_ptr; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放指针</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(T* other = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_ptr != other) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m_ptr) <span class="built_in">m_del</span>(m_ptr);</span><br><span class="line">      m_ptr = other;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放指针的控制权，返回指针</span></span><br><span class="line">  <span class="function">T* <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    T* tmp = m_ptr;</span><br><span class="line">    m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 交换函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(unique_ptr&amp; other)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(m_ptr, other.m_ptr);</span><br><span class="line">    std::<span class="built_in">swap</span>(m_del, other.m_del);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP2.0详解</title>
      <link href="/posts/3313489728/"/>
      <url>/posts/3313489728/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在找实习的过程中，不止一次被问到 "你了解HTTP2.0么？"，"HTTP2.0相比于HTTP1.x有什么区别？"。如果你之前被问到过这个问题，想找一个完美的答案，希望这篇Blog可以帮助到你；如果你正在找实习的话， 请一定要看下本文。</p></blockquote><span id="more"></span><h3 id="什么是http协议">1. 什么是HTTP协议</h3><p>传输层的TCP协议为应用进程提供了端到端的通信服务。但不同的网络应用的应用进程之间，还需要有不同的通信规则。因此在传输层协议之上，还需要有应用层协议。每一个应用层协议都是没了解决某一类应用问题。</p><p>HTTP 协议就是一个应用层协议，它定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。</p><p><img src="image-20200302212613271.png" alt="image-20200302212613271" style="zoom:50%;" /></p><h3 id="http1.x的缺点">2. HTTP1.X的缺点</h3><p>任何事物都是螺旋上升的，计算机的发展也不例外。所以 HTTP2.0 的出现一定是为了弥补 HTTP1.X 的缺点。如果面试官单纯的问你是否了解 HTTP2.0，我们先回答 HTTP 协议是一个应用层协议以及它解决的问题，然后说 "HTTP2.0 是为了解决 HTTP1.X 的 ... 缺点"。任何一个面试官都会眼前一亮。那么让我们看一下 HTTP1.X 到底有哪些缺点。</p><ul><li><strong>HTTP1.0 连接无法复用</strong></li></ul><p>HTTP 协议首先要和服务器建立 TCP 连接（三次握手），如果连接无法复用，就意味着我们每请求一个文档就需要进行一次 TCP 连接的建立，这样的开销是十分巨大的。</p><p>HTTP1.0 需要在 request 中增加 ”Connection： keep-alive“ 才能支持长连接。而 HTTP1.1 默认支持。</p><p><img src="image-20200302215424085.png" alt="image-20200302215424085" style="zoom:50%;" /></p><ul><li>HTTP1.0一次只允许在一个TCP连接上发起一个请求，HTTP1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。</li><li>请求报文与响应报文首部信息冗余量大</li><li>数据未压缩，导致数据的传输量大</li></ul><h3 id="http2.0的改进">3. HTTP2.0的改进</h3><p>HTTP2.0 采用新的二进制格式传输，之前的 HTTP1.X 都是基于ASCII码。基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。</p><p><img src="image-20200302221626043.png" alt="image-20200302221626043" style="zoom:50%;" /></p><h4 id="多路复用">3.1. 多路复用</h4><p>由于 HTTP2.0 使用二进制格式传输，其中帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流是多个帧组成的数据流。所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。</p><p><img src="image-20200302221939041.png" alt="image-20200302221939041" style="zoom:50%;" /></p><h4 id="头部压缩">3.2. 头部压缩</h4><p>在 HTTP2.0 中，我们使用了HPACK（HTTP2头部压缩算法）压缩格式对传输的header进行编码，减少了header的大小。并在两端维护了索引表，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到对应的值。</p><h4 id="服务端推送">3.3. 服务端推送</h4><p>在 HTTP2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。可以想象一下，某些资源客户端是一定会请求的，这时就可以采取服务端push的技术，提前给客户端推送必要的资源，就可以相对减少一点延迟时间。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> HTTP2.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一个设计模式之单例模式</title>
      <link href="/posts/3544271113/"/>
      <url>/posts/3544271113/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单例模式（Singleton Pattern）是设计模式中最简单的形式之一，其目的是使得类的一个对象成为系统中的唯一实例。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象。</p></blockquote><span id="more"></span><h3 id="uml图">1. UML图</h3><p><img src="image-20200323163735417.png" alt="image-20200323163735417" /></p><p>单例模式只能创建一个实例，所以我们需要把它的构造函数私有化，这样就不能直接的创造一个对象。要想创建一个对象只能通过类的静态方法来实现。</p><p>所以一个单例模式的类应该设计为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 获取单例对象</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 释放内存</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteInstance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 打印</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Singleton address is %p\n&quot;</span>, <span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 禁止外部构造和析构</span></span><br><span class="line">  <span class="built_in">Singleton</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;Constructer\n&quot;</span>); &#125;</span><br><span class="line">  ~<span class="built_in">Singleton</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;Destructer\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 禁止拷贝和赋值</span></span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Singleton* instance_;  <span class="comment">// 唯一实例</span></span><br><span class="line">  <span class="keyword">static</span> mutex mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基于初始化的时机不同，有两种实现方式：饿汉式和懒汉式。</p><h3 id="饿汉式">2. 饿汉式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Singleton* Singleton::instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> instance_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式在程序一开始就构造函数初始化了，所以本身就线程安全的。</p><h3 id="懒汉式">3. 懒汉式</h3><p>为了避免内存浪费，懒汉式的思想是等到程序第一次需要调用 <code>Singleton</code> 的时候再初始化。所以程序一开始，我们需要把 <code>instance_</code> 置空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line">mutex Singleton::mutex_;  <span class="comment">// 线程安全</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (instance_ == <span class="literal">nullptr</span>) instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>getInstance()</code> 的时候，我们首先判断 <code>instance_</code> 是否为空。因为多了这一步判断，就有可能在多线程的环境下出现错误。比如线程A刚刚通过了 if 条件判断，此时被线程B抢占，由于线程A并没有对 instance_ 进行实例化，所以线程B通过了 if 判断，并实例化了一个 Singleton。当线程A获得了控制权后，又一次的进行实例化。显然，这违背了单例模式的初衷。所以，我们需要对临界区进行加锁控制。</p><h3 id="销毁实例">3. 销毁实例</h3><p>由于我们的实例是静态成员变量，并且是一个指针。所以它的生命周期是整个程序的。当程序结束的时候，我们需要手动对这个指针进行 delete ，它才会调用自己的析构函数。</p><p>我们可以手动添加一个 <code>deleteInstance()</code> 的方法，当程序结束的时候调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Singleton::deleteInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance_) &#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (instance_) &#123;</span><br><span class="line">      <span class="keyword">delete</span> instance_;</span><br><span class="line">      instance_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t3</span><span class="params">(func)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t4</span><span class="params">(func)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line">  t4.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  Singleton::<span class="built_in">deleteInstance</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20200323172721871.png" alt="image-20200323172721871" /></p><p>可以看到，成功的实行了析构函数。</p><p>但是，每次都需要手动调用，难免容易忘记而造成内存泄漏。所以我们需要一个自动释放内存的方法。可以通过增加一个内部类，在这个内部类的析构函数中，进行内存释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GC</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">GC</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> (instance_) &#123;</span><br><span class="line">        <span class="keyword">delete</span> instance_;</span><br><span class="line">        instance_ = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> GC gc;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton::GC Singleton::GC::gc; <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure><h3 id="局部静态变量重点推荐">4. 局部静态变量（重点推荐）</h3><p>这种方式很常见，实现非常简单，而且无需担心单例的销毁问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;Singleton address is %p\n&quot;</span>, <span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;Constructor\n&quot;</span>); &#125;</span><br><span class="line">  ~<span class="built_in">Singleton</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;Destructor\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>每日一个设计模式之观察者模式</title>
      <link href="/posts/816130158/"/>
      <url>/posts/816130158/</url>
      
        <content type="html"><![CDATA[<blockquote><p>观察者模式 (Observer Pattern) 又叫做发布-订阅模式。它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p></blockquote><span id="more"></span><h3 id="uml图">1. UML图</h3><p><img src="image-20200204221204579.png" alt="image-20200204221204579" /></p><p><strong>Subject 抽象主题</strong>，一般用一个抽象类或者一个接口实现。它把所有对观察者对象的引用保存在一个聚集里，每个主题都可以有任何数量的观察者。提供两个接口：<code>Attach</code> 增加观察者对象；<code>Detach</code> 删除观察者对象。</p><p><strong>Observer 抽象观察者</strong>，为所有的具体观察者定义一个接口，在得到主题的通知时更新自己。这个接口叫做更新接口。</p><p><strong>ConcreteSubject 具体主题</strong>，当具体主题的内部状态改变时，给所有登记过的观察者发出通知。</p><p><strong>ConcreteObserver 具体观察者</strong>，实现抽象观察者要求的更新接口，以便使本身的状态与主题的状态相协调。</p><hr /><p><strong>用观察者模式的动机是什么？</strong></p><p>将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象之间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。</p><p>观察者模式的关键对象是主题 Subject 和观察者 Observer，一个 Subject 可以有任意个依赖它的 Observer，一旦 Subject 的状态发生了改变，所有的 Observer 都可以得到通知。Subject 发出通知时并不需要知道谁是它的观察者，也就是说，具体观察者是谁，它根本不需要知道。而任何一个具体观察者不知道也不需要知道其他观察者的存在。</p><p><strong>什么场景需要使用？</strong></p><p>当一个对象的改变需要同时改变其他对象的时候。观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于对象，而不是依赖于具体。从而使得各自的变化都不会影响另一边的变化。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IObserver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISubject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attach</span><span class="params">(IObserver *)</span> </span>= <span class="number">0</span>;  <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Detach</span><span class="params">(IObserver *)</span> </span>= <span class="number">0</span>;  <span class="comment">// 注销观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 通知观察者</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IObserver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">float</span> price)</span> </span>= <span class="number">0</span>;  <span class="comment">// 更新价格</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> :</span> <span class="keyword">public</span> ISubject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;IObserver*&gt; _observers;</span><br><span class="line">    <span class="keyword">float</span> _price;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteSubject</span>() : _price(<span class="number">10</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPrice</span><span class="params">(<span class="keyword">float</span> p)</span> </span>&#123; _price = p; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(IObserver *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除一个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Detach</span><span class="params">(IObserver *observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _observers.<span class="built_in">remove</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知所有观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = _observers.<span class="built_in">begin</span>(); it != _observers.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            (*it)-&gt;<span class="built_in">Update</span>(_price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> :</span> <span class="keyword">public</span> IObserver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteObserver</span>(string name) : _name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">float</span> price)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; price: &quot;</span> &lt;&lt; price &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建主题、观察者</span></span><br><span class="line">    ConcreteSubject *pSubject = <span class="keyword">new</span> <span class="built_in">ConcreteSubject</span>();</span><br><span class="line">    IObserver *pObserver1 = <span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(<span class="string">&quot;Jack Ma&quot;</span>);</span><br><span class="line">    IObserver *pObserver2 = <span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(<span class="string">&quot;Pony&quot;</span>);</span><br><span class="line">    IObserver *pObserver3 = <span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(<span class="string">&quot;Yansong Li&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    pSubject-&gt;<span class="built_in">Attach</span>(pObserver1);</span><br><span class="line">    pSubject-&gt;<span class="built_in">Attach</span>(pObserver2);</span><br><span class="line">    pSubject-&gt;<span class="built_in">Attach</span>(pObserver3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改价格，通知观察者</span></span><br><span class="line">    pSubject-&gt;<span class="built_in">SetPrice</span>(<span class="number">12.5</span>);</span><br><span class="line">    pSubject-&gt;<span class="built_in">Notify</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===========================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注销观察者</span></span><br><span class="line">    pSubject-&gt;<span class="built_in">Detach</span>(pObserver3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更加价格，通知观察者</span></span><br><span class="line">    pSubject-&gt;<span class="built_in">SetPrice</span>(<span class="number">15.0</span>);</span><br><span class="line">    pSubject-&gt;<span class="built_in">Notify</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Jack Ma price: 12.5</span><br><span class="line">Pony price: 12.5</span><br><span class="line">Yansong Li price: 12.5</span><br><span class="line">===========================</span><br><span class="line">Jack Ma price: 15</span><br><span class="line">Pony price: 15</span><br></pre></td></tr></table></figure><h3 id="优缺点">3. 优缺点</h3><p><strong>优点</strong></p><ul><li>观察者和被观察者是抽象耦合的</li><li>建立一套触发机制</li></ul><p><strong>缺点</strong></p><ul><li>如果一个被观察者对象有很多的直接和间接的观察者，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>每日一个设计模式之原型模式</title>
      <link href="/posts/3012348372/"/>
      <url>/posts/3012348372/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原型模式 (Prototype Pattern) 属于创建型模式。它允许一个对象创建另外一个对象，而无需知道任何创建的细节。</p></blockquote><span id="more"></span><h3 id="uml图">1. UML图</h3><p><img src="image-20200201153436230.png" alt="image-20200201153436230" /></p><p>每一个具体的原型类 (ConcretePrototype) 都必须实现 <code>Clone()</code> 这个操作。</p><p><strong>为什么要实现一个克隆功能？</strong></p><p>假设我们现在有一个简历类，并且需要20份简历。那么最原始的做法就是我们 <code>new</code> 20份简历出来。这样做的缺点在于我们如要想要修改简历，那么20份简历之间是不同步的，每一份都要进行修改。这样的复杂操作显然不是我们想要的结果。</p><p>所以，我们希望能够从一个已有的对象创建出另一个对象。其实就是拷贝构造函数的功能。只不过使我们将其封装到了 <code>Clone()</code> 操作中。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Prototype</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Prototype</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Prototype* <span class="title">Clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resume</span> :</span> <span class="keyword">public</span> Prototype</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">    std::string _sex;</span><br><span class="line">    std::string _age;</span><br><span class="line">    std::string _time;</span><br><span class="line">    std::string _company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resume</span>(std::string name) : _name(name), _sex(<span class="string">&quot;&quot;</span>), _age(<span class="string">&quot;&quot;</span>), _time(<span class="string">&quot;&quot;</span>), _company(<span class="string">&quot;&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Resume</span>(<span class="keyword">const</span> Resume&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        _name = other._name;</span><br><span class="line">        _sex = other._sex;</span><br><span class="line">        _age = other._age;</span><br><span class="line">        _time = other._time;</span><br><span class="line">        _company = other._company;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Resume</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetPersonalInfo</span><span class="params">(std::string sex, std::string age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _sex = sex;</span><br><span class="line">        _age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetWorkExperience</span><span class="params">(std::string time, std::string company)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _time = time;</span><br><span class="line">        _company = company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _age &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; _sex &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; _time &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _company &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Resume* <span class="title">Clone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Resume</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resume *a = <span class="keyword">new</span> <span class="built_in">Resume</span>(<span class="string">&quot;Xiaoming&quot;</span>);</span><br><span class="line">    a-&gt;<span class="built_in">SetPersonalInfo</span>(<span class="string">&quot;male&quot;</span>, <span class="string">&quot;23&quot;</span>);</span><br><span class="line">    a-&gt;<span class="built_in">SetWorkExperience</span>(<span class="string">&quot;2018-2019&quot;</span>, <span class="string">&quot;ByteDance&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Resume *b = a-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">    b-&gt;<span class="built_in">SetWorkExperience</span>(<span class="string">&quot;2019-2020&quot;</span>, <span class="string">&quot;Microsoft&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Resume *c = a-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">    c-&gt;<span class="built_in">SetWorkExperience</span>(<span class="string">&quot;2020-2021&quot;</span>, <span class="string">&quot;Hulu&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a-&gt;<span class="built_in">Display</span>();</span><br><span class="line">    b-&gt;<span class="built_in">Display</span>();</span><br><span class="line">    c-&gt;<span class="built_in">Display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浅拷贝与深拷贝">3. 浅拷贝与深拷贝</h3><p>上面我们的数据类型都是 <code>string</code> 类型的，也就是 <strong>值类型</strong> 。如果我们的数据类型是一个指针或者引用，事情就不一样了。举个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">52</span>);</span><br><span class="line"><span class="keyword">int</span> *q = p;</span><br></pre></td></tr></table></figure><p><code>p</code> 和 <code>q</code> 拷贝的只是地址，在深一层的数值52并没有被拷贝。我们称这种拷贝为<strong>浅拷贝</strong>。</p><blockquote><p>浅拷贝：对字段进行逐位复制，如果字段是引用或者指针。则只能复制引用或指针，不能复制引用的对象或指向的对象。</p></blockquote><p>所以，我们要手动实现<strong>深拷贝</strong>。</p><h3 id="优点和缺点">4. 优点和缺点</h3><p><strong>优点</strong></p><ul><li>如果创建新的对象比较复杂，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li><li>简化对象的创建，无需理会创建过程。</li><li>可以在程序运行时（对象属性发生了变化）获得一份内容相同的实例，他们之间不会相互干扰。</li></ul><p><strong>缺点</strong></p><ul><li>在实现深拷贝时可能需要比较复杂的代码</li><li>需要为每一个类配备一个克隆方法，而且该克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一个设计模式之工厂模式</title>
      <link href="/posts/1985600068/"/>
      <url>/posts/1985600068/</url>
      
        <content type="html"><![CDATA[<blockquote><p>工厂模式 (Factory Pattern) 属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p></blockquote><span id="more"></span><h3 id="uml图">1. UML图</h3><p><img src="image-20200121103948074.png" alt="image-20200121103948074" /></p><p>我们可以看到工厂模式与简单工厂模式的区别在于，工厂模式多了一个 Factory 基类，通过继承的方法对每一个运算操作都设计了一个工厂类专门生产唯一的运算操作。那么这样做有什么好处呢？假如我们现在需要增加一个乘方的操作，如果是简单工厂模式的话，我们需要<strong>更改工厂类中的case判断语句</strong>，这也正好是简单工厂模式的最大优点 <strong>“在工厂类中包含必要的逻辑判断，根据客户端的选择条件动态实例化相关的类”</strong>。而简单工厂模式存在的问题也恰恰就在这里，我们修改原有的工厂类就等同于我们不但对扩展开放了，对修改也开放了，这就违背了 <strong>开放封闭原则</strong>。</p><p>然后，再看上面的工厂模式由于定义了一个用于创建对象的接口，让子类决定实例化哪一个类，使一个类的实例化延迟到了它的子类。因为无论我们创建加减乘除中的哪一个方法，他们都可以抽象为一个相同的方法，既然这个工厂类与分支耦合，那么我们就对它下手，根据依赖倒转原则，我们把工厂类抽象出一个接口，然后不同的子类根据自己的类型，实现这个接口。这样，当我们增加一个运算操作的时候，只需要增加一个运算类和一个工厂类就可以了，原有的代码不需要改动。这就完全符合了开放-封闭原则的精神。</p><h3 id="源码">2. 源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LeiFeng</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string <span class="keyword">_volunteer_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LeiFeng</span>(std::string type) : <span class="keyword">_volunteer_t</span>(type) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">LeiFeng</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Sweep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;扫地的&quot;</span> &lt;&lt; <span class="keyword">_volunteer_t</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Wash</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;洗衣的&quot;</span> &lt;&lt; <span class="keyword">_volunteer_t</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Buy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;买菜的&quot;</span> &lt;&lt; <span class="keyword">_volunteer_t</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> LeiFeng</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>() : LeiFeng::<span class="built_in">LeiFeng</span>(<span class="string">&quot;学生志愿者&quot;</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Student</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Volunteer</span> :</span> <span class="keyword">public</span> LeiFeng</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Volunteer</span>() : LeiFeng::<span class="built_in">LeiFeng</span>(<span class="string">&quot;社区志愿者&quot;</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单工厂模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> LeiFeng* <span class="title">CreateLeiFeng</span><span class="params">(std::string type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LeiFeng* lf = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;学生志愿者&quot;</span>) lf = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;社区志愿者&quot;</span>) lf = <span class="keyword">new</span> <span class="built_in">Volunteer</span>();</span><br><span class="line">        <span class="keyword">return</span> lf;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- 客户端 --------- */</span></span><br><span class="line">LeiFeng* student1 = SimpleFactory::<span class="built_in">CreateLeiFeng</span>(<span class="string">&quot;学生志愿者&quot;</span>);  <span class="comment">// 修改处</span></span><br><span class="line">LeiFeng* student2 = SimpleFactory::<span class="built_in">CreateLeiFeng</span>(<span class="string">&quot;学生志愿者&quot;</span>);  <span class="comment">// 修改处</span></span><br><span class="line">LeiFeng* student3 = SimpleFactory::<span class="built_in">CreateLeiFeng</span>(<span class="string">&quot;学生志愿者&quot;</span>);  <span class="comment">// 修改处</span></span><br><span class="line">student1-&gt;<span class="built_in">Buy</span>();</span><br><span class="line">student2-&gt;<span class="built_in">Sweep</span>();</span><br><span class="line">student3-&gt;<span class="built_in">Wash</span>();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IFactory</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IFactory</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> LeiFeng *<span class="title">CreateLeiFeng</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentFactory</span> :</span> <span class="keyword">public</span> IFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">LeiFeng *<span class="title">CreateLeiFeng</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Student</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolunteerFactory</span> :</span> <span class="keyword">public</span> IFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">LeiFeng *<span class="title">CreateLeiFeng</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Volunteer</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------- 客户端 --------- */</span></span><br><span class="line">IFactory *factory = <span class="keyword">new</span> <span class="built_in">VolunteerFactory</span>();  <span class="comment">// 修改处</span></span><br><span class="line">LeiFeng *volunteer1 = factory-&gt;<span class="built_in">CreateLeiFeng</span>();</span><br><span class="line">LeiFeng *volunteer2 = factory-&gt;<span class="built_in">CreateLeiFeng</span>();</span><br><span class="line">LeiFeng *volunteer3 = factory-&gt;<span class="built_in">CreateLeiFeng</span>();</span><br><span class="line">volunteer1-&gt;<span class="built_in">Buy</span>();</span><br><span class="line">volunteer2-&gt;<span class="built_in">Sweep</span>();</span><br><span class="line">volunteer3-&gt;<span class="built_in">Wash</span>();</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以看到，当我们需要要从学生志愿者切换到社区职员制的时候，工厂模式只需要修改一处代码：更换一个工厂即可。但是简单工厂模式就需要修改三处代码，因为我们需要传递一个 <code>type</code> 类型到简单工厂的内部提供判断逻辑。</p><h3 id="优点和缺点">3. 优点和缺点</h3><p><strong>优点</strong></p><p>工厂模式克服了简单工厂模式违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点，使得更换对象时，不需要做大的改动就可以实现，降低了客户程序与产品对象的耦合。</p><p><strong>缺点</strong></p><p>每增加一个产品，就需要增加一个产品工厂的类，增加了额外的代码量，使得系统冗杂。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一个设计模式之代理模式</title>
      <link href="/posts/1500535591/"/>
      <url>/posts/1500535591/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代理模式 (Proxy Pettern) 属于结构型模式，为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p></blockquote><span id="more"></span><h3 id="uml图">1. UML图</h3><p><img src="image-20200120230033817.png" alt="image-20200120230033817" /></p><p>Subject 类是一个共用接口，这样 RealSubject 和 Proxy 就具有相同的基本数据和基本方法，所以任何使用 RealSubject 的地方都可以通过使用 Proxy 代理来完成。</p><p>Proxy 中保存一个指向 RealSubject 的指针，这样就可以通过代理来代替实体。</p><p>什么时候需要用到代理模式呢？</p><p>我们回想生活中使用代理的场景，第一个想到的一定是网络代理。我们之所以需要使用网络代理，是因为我们访问某些网站很困难，所以需要代理来完成。另外一个场景比如说我们打官司，需要请一位律师做代理，因为律师比我们更加的专业，我们和法官进行交涉可能会说错话，但是律师不会。</p><p>总结一下，我们需要使用代理模式的两个情景：</p><ul><li>无法直接访问某个对象（无法访问Google）</li><li>不想直接访问某个对象（不想和法官交流）</li></ul><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> :</span> <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> :</span> <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Subject* _cs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>(Subject* cs) : _cs(cs) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _cs-&gt;<span class="built_in">Request</span>();  <span class="comment">// 调用真实的Request</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优点和缺点">3. 优点和缺点</h3><p><strong>优点</strong></p><ul><li>代理模式能将代理对象与真正被调用的对象分离，在一定程度上降低了系统的耦合度。</li><li>代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用。</li></ul><p><strong>缺点</strong></p><ul><li>通过代理模式引入了额外的代码，所以带来了额外的开销，访问时间减少。</li><li>增加了系统的复杂度。如果代理出错，整个系统就会崩溃。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一个设计模式之装饰模式</title>
      <link href="/posts/3293599324/"/>
      <url>/posts/3293599324/</url>
      
        <content type="html"><![CDATA[<blockquote><p>装饰模式 (Decorator Pattern) 属于结构型模式，它是作为现有类的一个包装。我们可以在不改变原始类的任何功能，利用装饰类动态地对原始类进行 “装饰” ，即增加新的功能。就增加功能来说，装饰模式比生成子类更为灵活。</p></blockquote><span id="more"></span><h3 id="uml图">1. UML图</h3><p><img src="image-20200118150748591.png" alt="image-20200118150748591" /></p><p>Component 是定义一个对象接口，可以给这些对象动态地添加职责。</p><p>ConcreteComponent 是定义了一个具体的对象。</p><p>Decorator 装饰抽象类，继承并聚合了 Component，从外类来扩展 Component 类的功能，但是对于 Component 来说并不需要知道 Decorator 的存在。</p><p>ConcreteDecorator 就是具体的装饰对象，负责对 Component 进行具体的装饰的功能。</p><h3 id="应用场景">2. 应用场景</h3><p>假如我们现在需要设计一个QQ秀系统，来进行不同服饰的系统。如果我们进行常规的设计，维护一个 Person 的类，每一个不同的函数进行不同的装饰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name) : _name(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;装扮的: &quot;</span> &lt;&lt; _name &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TShirts</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;T恤 &quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Jeans</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;牛仔裤 &quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Sneaker</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;球鞋 &quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Suit</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;西装 &quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Tie</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;领带 &quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Leather</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;皮鞋 &quot;</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们需要新增加一种装扮的时候，就要直接修改 Person 这个类，给它增加一个函数来完成相应的功能，这显然不是一种好的方法，违反了 “开放-封闭原则”。</p><p>考虑我们之前学习的简单工厂模式和策略模式，很容易想到使用一个服饰的抽象类，通过继承的方式来实现。</p><p><img src="image-20200118152251470.png" alt="image-20200118152251470" style="zoom:67%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Finery ts = <span class="keyword">new</span> <span class="built_in">TShirts</span>();</span><br><span class="line">Finery jeans = <span class="keyword">new</span> <span class="built_in">Jeans</span>();</span><br><span class="line">Finery sneaker = <span class="keyword">new</span> <span class="built_in">Sneaker</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">ts.<span class="built_in">show</span>();</span><br><span class="line">jeans.<span class="built_in">show</span>();</span><br><span class="line">sneaker.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><p>这样虽然可以满足需要，但是可以看到我们进行了3次 show 的调用，好比我们光着身子，当着大家的面，先穿T恤，再穿牛仔裤，最后穿上鞋子。</p><p>所以，我们的目标就是 <strong><font clor='red'>“把所需的功能按正确的顺序串联起来进行控制”</font></strong> 。最后调用一次 show 来输出所有信息。</p><h3 id="代码">3. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体对象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span> </span>&#123; <span class="comment">/* ...具体对象的操作 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> :</span> <span class="keyword">public</span> Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Component* _component;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Decorator</span>(Component* component) : _component(component) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_component != <span class="literal">nullptr</span>)</span><br><span class="line">            _component-&gt;<span class="built_in">Operation</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装饰类A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> :</span> <span class="keyword">public</span> Decorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string _addedState; <span class="comment">// 本类的独有数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Decorator::<span class="built_in">Operation</span>();</span><br><span class="line">        <span class="comment">// 执行本类的功能</span></span><br><span class="line">        _addedState = <span class="string">&quot;New State!&quot;</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> :</span> <span class="keyword">public</span> Decorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddedBehavior</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Operation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Decorator::<span class="built_in">Operation</span>();</span><br><span class="line">        <span class="comment">// 执行本类的功能</span></span><br><span class="line">        <span class="built_in">AddedBehavior</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优点和缺点">4. 优点和缺点</h3><p><strong>优点</strong></p><ul><li>装饰模式可以动态的添加更多功能的一种方式，而继承模式是静态的扩展功能，因为继承关系是开始时写好的。</li><li>把每个要装饰的功能放在了单独的类中，并让这个类包装它所要装饰的对象。</li><li>通过配置文件可以在运行时选择不同的装饰器，从而实现不同的行为。</li></ul><p><strong>缺点</strong></p><ul><li>产生很多的小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。</li><li>这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一个设计模式之策略模式</title>
      <link href="/posts/1354949446/"/>
      <url>/posts/1354949446/</url>
      
        <content type="html"><![CDATA[<blockquote><p>策略模式 (Strategy Pattern) 属于行为型模式。策略对应到计算机的世界当中就是算法，所以策略模式就是对算法的封装，把一系列的算法分别封装到对应的类中，使他们可以相互替换。</p></blockquote><span id="more"></span><h3 id="uml图">1. UML图</h3><p><img src="image-20191228103826781.png" alt="image-20191228103826781" /></p><p>通过上面的图，我们可以通过 Context 类的构造函数传参，调用 StrategyA、StrategyB、StrategyC 三种策略（算法）。定义了 <code>Strategy</code> 基类，通过虚函数继承的方式实现了多态。</p><h3 id="应用场景">2. 应用场景</h3><p>可能你已经感觉到了策略模式和简单工厂模式十分的相似，那么我们什么时候决定使用策略模式呢？</p><p>我们首先回顾一下简单工厂模式的工作原理，它是通过工厂函数创建了一个指向对应类的指针，并且把这个指针<strong>返回给客户端</strong>。所以客户端需要和：工厂对象、实例对象。这两种对象进行交互。</p><p>当我们使用策略模式的时候，客户端只需要和 Context 这一个类进行交互就可以了，降低了耦合度。Context 直接调用对应算法的类，客户端不需要知道具体的算法类。</p><p>另外一个区分点就是，我们只要在分析过程中听到需要在<strong>不同时间应用不同的业务规则</strong>，就可以考虑使用策略模式。如果，我们需要根据<strong>不同的时间应用不同的对象</strong>，就要考虑简单工厂模式。</p><p>策略模式还有一个优点就是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。</p><h3 id="代码">3. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象算法类，定义一个所有算法都必须实现的公共接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Strategy</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Strategy</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体算法A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> :</span> <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span>; <span class="comment">// 算法A的实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体算法B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> :</span> <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span>; <span class="comment">// 算法B的实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体算法C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyC</span> :</span> <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span>; <span class="comment">// 算法C的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是一个 Context 表示根据不同的上下文信息，我们需要使用不同的算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Context</span>(Strategy* strategy) : _strategy(strategy) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ContextInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy-&gt;<span class="built_in">AlgorithmInterface</span>();  <span class="comment">// 调用算法</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy* _strategy;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面 Context 类的写法存在一些问题，生成具体算法对象的操作需要客户端去完成。简单工厂模式里面，我们通过工厂类来帮助客户端创建对应的类，所以我们可以考虑在策略模式中应用这一思想，把简单工厂模式里面的判断逻辑移植到我们的 Context 类中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改Context的构造函数，传入一个类型判断标识</span></span><br><span class="line">Context::<span class="built_in">Context</span>(std::string type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( ... ) _strategy = <span class="keyword">new</span> <span class="built_in">ConcreteStrategyA</span>();</span><br><span class="line">    <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点">4. 缺点</h3><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行为型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一个设计模式之简单工厂模式</title>
      <link href="/posts/2716911451/"/>
      <url>/posts/2716911451/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单工厂模式 (Simple Factory Pattern) 属于创建型模式。顾名思义，工厂就是负责制造物品的，在面向对象的世界里，工厂自然就是生产对象、创造对象的。根据参数的不同返回不同类的实例。</p></blockquote><span id="more"></span><h3 id="uml图">1. UML图</h3><p><img src="SimpleFactory.png" alt="SimpleFactory" /></p><p>通过上面的图，我们可以通过 <code>SimpleFactory</code> 来生产出四种不同类型的对象。其中，我们将 <code>Operation</code> 进行了封装，并且通过虚函数实现了多态，每个子类继承 <code>Operation</code> ，实现了 <code>GetResult</code> 这个虚函数。</p><h3 id="应用场景">2. 应用场景</h3><p>上面提到过，简单工厂模式属于创建型的模式，也就是说在创建对象的时候，遇到了瓶颈才会选择的设计模式。那么什么时候我们会遇到创建对象的瓶颈呢？当然是我们不知道要创建什么对象的时候，也就是说对象的类型不能在编译期确定，需要等到运行的时候，动态决定应该创建什么类型的对象。这个时候，我们就可以使用简单工厂模式来进行设计。</p><h3 id="代码">3. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _OPERATION_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OPERATION_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Operation</span>() : _number_a(<span class="number">0</span>), _number_b(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Operation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        _number_a = a;</span><br><span class="line">        _number_b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> _number_a;</span><br><span class="line">    <span class="keyword">double</span> _number_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _number_a + _number_b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sub</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationSub</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _number_a - _number_b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationMul</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _number_a * _number_b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationDiv</span> :</span> <span class="keyword">public</span> Operation &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_number_b == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Math error: Attempted to divide by Zero\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> _number_a / _number_b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _OPERATION_H_H</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SIMPLE_FACTORY_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SIMPLE_FACTORY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;operation.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationFactory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Operation* <span class="title">CreateOperate</span><span class="params">(<span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">        Operation* oper = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) oper = <span class="keyword">new</span> <span class="built_in">OperationAdd</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) oper = <span class="keyword">new</span> <span class="built_in">OperationSub</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) oper = <span class="keyword">new</span> <span class="built_in">OperationMul</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>) oper = <span class="keyword">new</span> <span class="built_in">OperationDiv</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _SIMPLE_FACTORY_H_</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;simple_factory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">rechar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span> || ch == <span class="string">&#x27;\r&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num_a, num_b;</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input number a:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;num_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please select operation (+, -, *, /):\n&quot;</span>);</span><br><span class="line">    op = <span class="built_in">rechar</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input number b:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;num_b);</span><br><span class="line">    </span><br><span class="line">    Operation* oper = OperationFactory::<span class="built_in">CreateOperate</span>(op);</span><br><span class="line">    oper-&gt;<span class="built_in">set</span>(num_a, num_b);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> result = oper-&gt;<span class="built_in">GetResult</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Result is %lf\n&quot;</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点">4. 缺点</h3><ul><li>因为工厂类集中了所有的创建逻辑，所以一旦不能正常工作，整个系统都会受影响。</li><li>只适用于子类不多的情况，如果子类过多就会增加系统的复杂度和理解难度</li><li>系统扩展困难，因为如果要扩展一个子类，就要修改工厂的判断逻辑，需要重新编译整个系统。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码解析之heap</title>
      <link href="/posts/3758585424/"/>
      <url>/posts/3758585424/</url>
      
        <content type="html"><![CDATA[<blockquote><p>heap 并不属于 STL 容器组件，它是 priority_queue （优先队列）的底层实现机制。但是我们必须要了解 heap（堆）的机制，才能更好的了解 priority_queue（优先队列）的原理。</p></blockquote><span id="more"></span><h3 id="heap-概述">1. heap 概述</h3><p>优先队列允许用户以任何次序将任何元素推入容器内，但取出时一定是从优先级最高（也就数数值最大）的元素开始取。如果我们使用 array 或者 list 作为优先队列的底层实现，那么插入操作和取极值操作必然有一个操作的时间复杂度要达到 <span class="math inline">\(O(n)\)</span> 甚至是 <span class="math inline">\(O(n^2)\)</span> 级别的，显然这是我们无法接受的。你可能会想到 BST（二叉搜索树）来实现，因为 BST 的插入和取极值操作都是 <span class="math inline">\(O(logN)\)</span> 的。但是这样的话就有点小题大做了，因为 BST 的实现十分复杂。下面我们来看一看什么是 heap（堆）。</p><p>堆其实是一个<strong>完全二叉树</strong>，整棵树除了最底层的叶节点之外是填满的，同时最底层的叶节点是由左至右，不能有空隙的。正是由于它的没有空隙的性质，我们可以利用 array 来模拟一个完全二叉树。</p><p><img src="image-20191119222249619.png" alt="image-20191119222249619" style="zoom:50%;" /></p><p>这里使用一个小技巧，将 array 的 #0 元素保留，那么任意一个节点 <span class="math inline">\(i\)</span> <span class="math display">\[\begin{aligned}&amp;Left = 2*i \\ \\&amp;Right = 2*i + 1 \\ \\&amp;Father = \frac{i}{2}\end{aligned}\]</span> 但是 SGI STL 并没有使用这个小技巧，它的节点间关系为： <span class="math display">\[\begin{aligned}&amp;Left = 2*i + 1 \\ \\&amp;Right = 2*i + 2 \\ \\&amp;Father = \frac{i - 1}{2}\end{aligned}\]</span></p><p>我们现在有了数据结构，那么只需要一组 heap 算法来保证插入和删除元素之后继续保持完全二叉树的性质就OK了。另外，根据元素排列方式 heap 可以分为 max-heap 和 min-heap 两种，max-heap 的最大值在根节点，即位于底层 array 的开始处；min-heap 的最小值在根节点，即位于底层 array 的开始处。因为 STL 默认的是 max-heap 所以，接下来我们讨论的内容也是默认为 max-heap。</p><h3 id="heap-算法">2. heap 算法</h3><h4 id="push_heap-算法">2.1. push_heap 算法</h4><p>首先，我们将新元素放到 array 的末尾，然后判断这个新加入的元素是否会最大堆的条件，我们执行一个上溯的算法来判断是否符合条件：将新节点与其父节点进行比较，如果大于父节点，则父子对调，继续上溯。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">            _Distance __holeIndex, _Distance __topIndex, _Tp __value) &#123;</span><br><span class="line">  <span class="comment">// 找出父节点</span></span><br><span class="line">  _Distance __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123;</span><br><span class="line">    *(__first + __holeIndex) = *(__first + __parent);   <span class="comment">// 令洞值为父值</span></span><br><span class="line">    __holeIndex = __parent;                             <span class="comment">// 令父节点为洞节点</span></span><br><span class="line">    __parent = (__holeIndex - <span class="number">1</span>) / <span class="number">2</span>;                   <span class="comment">// 新洞节点的父节点</span></span><br><span class="line">  &#125;    </span><br><span class="line">  *(__first + __holeIndex) = __value;                   <span class="comment">// 令洞值为新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pop_heap-算法">2.2. pop_heap 算法</h4><p>与 push_heap 算法相反，pop_heap 算法是使用了自顶向下的调节。首先将根节点与最后一个叶子节点的值交换，交换后可能会破坏最大堆的性质（根节点的值小于左右子节点中的某一个），所以我们采用自顶向下的方法进行调节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(_RandomAccessIterator __first,  _RandomAccessIterator __last)</span> </span>&#123;</span><br><span class="line">  __pop_heap_aux(__first, __last, __VALUE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap_aux(_RandomAccessIterator __first, </span><br><span class="line">                           _RandomAccessIterator __last, _Tp*) &#123;</span><br><span class="line">  __pop_heap(__first, __last - <span class="number">1</span>, __last - <span class="number">1</span>,  _Tp(*(__last - <span class="number">1</span>)), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span>  __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">                        _RandomAccessIterator __result, _Tp __value, _Distance*) &#123;</span><br><span class="line">  *__result = *__first;      <span class="comment">// *(__last - 1) = *(first) 设定尾值为首值</span></span><br><span class="line">  __adjust_heap(__first, _Distance(<span class="number">0</span>), _Distance(__last - __first), __value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Distance</span>, <span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex, </span><br><span class="line">                    _Distance __len, _Tp __value) &#123;</span><br><span class="line">  <span class="comment">// __value 是最后一个叶子节点的值</span></span><br><span class="line">  <span class="comment">// __holeIndex = 0是根节点的位置</span></span><br><span class="line">  <span class="comment">// __len = last - first</span></span><br><span class="line">  _Distance __topIndex = __holeIndex;</span><br><span class="line">  _Distance __secondChild = <span class="number">2</span> * __holeIndex + <span class="number">2</span>;  <span class="comment">// 洞节点的右子节点</span></span><br><span class="line">  <span class="keyword">while</span> (__secondChild &lt; __len) &#123;</span><br><span class="line">    <span class="comment">// 比较左右两个节点，取最大的那个</span></span><br><span class="line">    <span class="keyword">if</span> (*(__first + __secondChild) &lt; *(__first + (__secondChild - <span class="number">1</span>)))</span><br><span class="line">      __secondChild--;  <span class="comment">// 右子节点 &lt; 左子节点，所以减一得到左子节点</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + __secondChild);  <span class="comment">// 更新洞值为最大值</span></span><br><span class="line">    __holeIndex = __secondChild;    <span class="comment">// 令子节点为洞节点</span></span><br><span class="line">    __secondChild = <span class="number">2</span> * (__secondChild + <span class="number">1</span>);  <span class="comment">// 找到新洞节点的右子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__secondChild == __len) &#123;  <span class="comment">// 只有左子节点</span></span><br><span class="line">    *(__first + __holeIndex) = *(__first + (__secondChild - <span class="number">1</span>)); <span class="comment">// 将左子节点的值赋给洞节点</span></span><br><span class="line">    __holeIndex = __secondChild - <span class="number">1</span>;   <span class="comment">// 调整洞节点为左子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意上述操作都是没有考虑原尾值的，此时位置相当于一个插入操作</span></span><br><span class="line">  <span class="comment">// 原尾值 value 插入到洞节点，上溯</span></span><br><span class="line">  __push_heap(__first, __holeIndex, __topIndex, __value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，pop_heap 之后，最大元素只是被置放于底部容器的最尾端，尚未被取走。如果要取其值，可以使用底部容器（vector）所提供的 <code>back()</code> 操作函数。如果要移除它，可以使用底部容器（vector）所提供的 <code>pop_back()</code> 操作函数。</p><h4 id="sort_heap-算法">2.3. sort_heap 算法</h4><p>既然每次 <code>pop_heap()</code> 可获得 heap 中键值最大的元素，如果持续对整个 heap 做 <code>pop_heap()</code> 操作，每次将操作范围从后向前缩减一个元素，当程序执行完毕时，我们便有了一个递增序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 每执行一次 pop_heap()，极值（在STL heap中为极大值）即被放在尾端。</span></span><br><span class="line"><span class="comment">// 扣除尾端再执行一次 pop_heap()，次极值又被放在新尾端。一直下去，最后即得排序結果。</span></span><br><span class="line">  <span class="keyword">while</span> (__last - __first &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">pop_heap</span>(__first, __last--);  <span class="comment">// 每执行 pop_heap() 一次，操作范围即退缩一格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="make_heap-算法">2.4. make_heap 算法</h4><p>这个算法用来将一段现有的数据转化为一个heap，即将一个迭代器对的内容构造成最大堆。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last)</span> </span>&#123;</span><br><span class="line">  __make_heap(__first, __last, __VALUE_TYPE(__first), __DISTANCE_TYPE(__first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __make_heap(_RandomAccessIterator __first,</span><br><span class="line">                 _RandomAccessIterator __last, _Tp*, _Distance*) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__last - __first &lt; <span class="number">2</span>) <span class="keyword">return</span>;   <span class="comment">// 如果长度小于2，不必排序直接退出</span></span><br><span class="line">  _Distance __len = __last - __first;</span><br><span class="line">  _Distance __parent = (__len - <span class="number">2</span>)/<span class="number">2</span>;  <span class="comment">// 这里减2，是因为区间为[first, last)</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 不断重排以parent为首的子树</span></span><br><span class="line">    <span class="comment">// __adjust_heap进行的操作是，从__parent开始不断的调整洞节点，最后再用__parent的值进行上溯</span></span><br><span class="line">    __adjust_heap(__first, __parent, __len, _Tp(*(__first + __parent)));</span><br><span class="line">    <span class="keyword">if</span> (__parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    __parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="priority_queue">3. priority_queue</h3><p><strong>priority_queue</strong>不属于容器，它和 queue、stack 一样属于配接器（adapter）。因为它们是以其他容器为底层容器实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, </span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> _<span class="title">Sequence</span> __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(<span class="title">vector</span>&lt;</span>_Tp&gt;),</span><br><span class="line">          <span class="class"><span class="keyword">class</span> _<span class="title">Compare</span></span></span><br><span class="line"><span class="class">          __<span class="title">STL_DEPENDENT_DEFAULT_TMPL</span>(<span class="title">less</span>&lt;</span><span class="keyword">typename</span> _Sequence::value_type&gt;) &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::value_type      value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::size_type       size_type;</span><br><span class="line">  <span class="keyword">typedef</span>          _Sequence                  container_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::reference       reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Sequence c;    <span class="comment">// 底层容器</span></span><br><span class="line">  _Compare comp;  <span class="comment">// 元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="keyword">const</span> _Compare&amp; __x)</span> :  c(), comp(__x) &#123;</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">priority_queue</span>(<span class="keyword">const</span> _Compare&amp; __x, <span class="keyword">const</span> _Sequence&amp; __s) </span><br><span class="line">    : <span class="built_in">c</span>(__s), <span class="built_in">comp</span>(__x) </span><br><span class="line">    &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; __x)</span> </span>&#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      c.<span class="built_in">push_back</span>(__x);  <span class="comment">// 先把元素放到最后</span></span><br><span class="line">      <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); <span class="comment">// 调整</span></span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">      c.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="注意">4. 注意</h4><p>我们可以看到 <code>priority_queue</code> 接受三个模板参数&lt;Type, Container, Compare&gt;，我们如果想定义一个最小堆的话，就要改变 Compare 的值，因为 Compare 是第三个参数，所以我们在指定的时候， Container 也要指定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; p;   <span class="comment">// 最小堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt; p;      <span class="comment">// 最大堆</span></span><br></pre></td></tr></table></figure><p><strong>为什么 greater 对应最小堆，less 对应最大堆？</strong></p><p>这个问题，当我们理解了 <code>push_heap</code> 函数的操作，就恍然大悟了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; *(__first + __parent) &lt; __value) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与它相对应的Compare版为</span></span><br><span class="line"><span class="keyword">while</span> (__holeIndex &gt; __topIndex &amp;&amp; __comp(*(__first + __parent), __value)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 __comp = less</span></span><br></pre></td></tr></table></figure><p><code>push_heap</code> 使用的上溯操作，我们先将待插入的值放到末尾，然后比较它的值和父节点的值。</p><blockquote><p>如果父节点 <strong>&lt;</strong> 插入值，那么插入值向上移动就相当于<strong>大值前移</strong>，所以是最大堆。</p><p>如果父节点 <strong>&gt;</strong> 插入值，那么插入值向上移动就相当于<strong>小值前移</strong>，所以是最小堆。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> STL源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码解析之deque</title>
      <link href="/posts/552638188/"/>
      <url>/posts/552638188/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vector 是单向开口的连续线性空间，deque 则视一种双向开口的连续线性空间。vector 当然也可以在头部进行插入，但是每一次插入的操作都需要将后面的元素向前移动一位，显然 O(n) 的时间复杂度是无法接受的。</p><p>另外 deque 没有所谓的容量观念，因为它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。换句话说，像 vector 那样 ”因旧空间不足而重新配置一块更大空间，然后负责元素、释放空间“ 这样的事情在 deque 是不会发生的。</p></blockquote><span id="more"></span><h3 id="deque-的中控器">1. deque 的中控器</h3><p>deque 的连续空间是逻辑上的，deque 是由一段一段连续空间组成的。一旦有必要在 deque 的前端或尾端增加新空间，便分配一段连续的空间上去。换句话说，deque 更像一个大大的链表。由于我们要维护一个整体连续的假象，这就要求迭代器的设计要十分复杂。因为迭代器要逻辑上使用起来是连续的，物理上却不是连续的，所以需要额外的东西来维护相应的信息。</p><p>deque 采用一块所谓的 map 作为主控，这里的 map 是一小块连续空间，其中每一个元素都是一个指针，指向另一段连续线性空间，称为缓冲区。这个缓冲区的大小是可以指定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Deque_base</span> &#123;</span></span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Tp** _M_map;</span><br><span class="line">  <span class="keyword">size_t</span> _M_map_size;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 map 就是一个指针，所指之物还是一个指针。</p><p><img src="image-20191112152940812.png" alt="image-20191112152940812" style="zoom:50%;" /></p><h3 id="deque-的迭代器">2. deque 的迭代器</h3><p>deque 是分段连续空间，维持其 ”整体连续“ 假象的任务，落在了迭代器的 <code>operator++</code> 和 <code>operator--</code> 两个操作符身上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Ref</span>, <span class="keyword">class</span> _<span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Deque_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp, <span class="keyword">const</span> _Tp&amp;, <span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_buffer_size() &#123; <span class="keyword">return</span> __deque_buf_size(<span class="built_in"><span class="keyword">sizeof</span></span>(_Tp)); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp** _Map_pointer;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator _Self;</span><br><span class="line">  </span><br><span class="line">  _Tp* _M_cur;    <span class="comment">// 指向缓冲区中的当前行元素</span></span><br><span class="line">  _Tp* _M_first;  <span class="comment">// 指向缓冲区的头</span></span><br><span class="line">  _Tp* _M_last;   <span class="comment">// 指向缓冲区的尾</span></span><br><span class="line">  _Map_pointer _M_node;  <span class="comment">// 指向中控中心</span></span><br><span class="line">  <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设我们产生一个元素型态为 int，缓冲区大小为 8 的 deque，经过某些操作后，deque 拥有 20 个元素，那么 deque 中的指针应该如下图所示</p><p><img src="image-20191112154115993.png" alt="image-20191112154115993" style="zoom:50%;" /></p><p>finish 所指的缓冲区中还剩下 4 个备用空间。deque 迭代器最关键的行为就是缓冲区的跳转，使用下面这个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _M_set_node(_Map_pointer __new_node) &#123;</span><br><span class="line">  _M_node = __new_node;</span><br><span class="line">  _M_first = *__new_node;</span><br><span class="line">  _M_last = _M_first + <span class="built_in">difference_type</span>(_S_buffer_size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deque-的数据结构">3. deque 的数据结构</h3><p>deque 除了维护一个指向 map 的指针外，也维护 start，finish 两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素。此外，它必须记录目前的 map 的大小。因为一旦 map 所提供的节点不足，就必须重新配置更大的一块 map。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> alloc &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> :</span> <span class="keyword">protected</span> _Deque_base&lt;_Tp, _Alloc&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types</span></span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Deque_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> pointer* _Map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _Tp** _M_map;</span><br><span class="line">  <span class="keyword">size_t</span> _M_map_size;  </span><br><span class="line">  iterator _M_start;</span><br><span class="line">  iterator _M_finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deque-的构造与内存管理">4. deque 的构造与内存管理</h3><p>我们先声明一个 deque</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">deque&lt;<span class="keyword">int</span>, alloc, 8&gt; <span class="title">ideq</span><span class="params">(<span class="number">20</span>, <span class="number">9</span>)</span></span>;  <span class="comment">// 缓冲区大小为8个元素，初始20个元素，每个元素的值为9</span></span><br></pre></td></tr></table></figure><p>deque 具有两个专属的空间配置器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;_Tp, _Alloc&gt;  _Node_alloc_type;</span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;_Tp*, _Alloc&gt; _Map_alloc_type;</span><br></pre></td></tr></table></figure><p>当我们初始化一个 deque 的时候，就会调用者两个空间配置器来配置空间。</p><p>接下来，我们看一看 <code>push_back</code> 的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type&amp; <span class="keyword">__t</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_M_finish._M_cur != _M_finish._M_last - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 最后一个缓冲区，还有两个（含）以上的元素备用空间</span></span><br><span class="line">    <span class="built_in">construct</span>(_M_finish._M_cur, <span class="keyword">__t</span>);</span><br><span class="line">    ++_M_finish._M_cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="comment">// 最后缓冲区只剩一个元素备用空间</span></span><br><span class="line">    _M_push_back_aux(<span class="keyword">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> deque&lt;_Tp,_Alloc&gt;::_M_push_back_aux(<span class="keyword">const</span> value_type&amp; <span class="keyword">__t</span>) &#123;</span><br><span class="line">  value_type __t_copy = <span class="keyword">__t</span>;</span><br><span class="line">  _M_reserve_map_at_back();    <span class="comment">// 若符合某种条件则必须重换一个map</span></span><br><span class="line">  *(_M_finish._M_node + <span class="number">1</span>) = _M_allocate_node();  <span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="built_in">construct</span>(_M_finish._M_cur, __t_copy);</span><br><span class="line">    _M_finish._M_set_node(_M_finish._M_node + <span class="number">1</span>);    <span class="comment">// 改变finish，令其指向新节点</span></span><br><span class="line">    _M_finish._M_cur = _M_finish._M_first;           <span class="comment">// 设定finish的状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的图展示了当我们 <code>push_back</code> 的时候，缓冲区只剩下一个元素备用空间，插入后的效果。</p><p><img src="image-20191112213513603.png" alt="image-20191112213513603" style="zoom:50%;" /></p><p>同样道理，我们来看一下 <code>push_front</code> 的源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; <span class="keyword">__t</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_M_start._M_cur != _M_start._M_first) &#123;    <span class="comment">// 第一缓冲区尚有备用空间</span></span><br><span class="line">    <span class="built_in">construct</span>(_M_start._M_cur - <span class="number">1</span>, <span class="keyword">__t</span>);</span><br><span class="line">    --_M_start._M_cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    _M_push_front_aux(<span class="keyword">__t</span>);    <span class="comment">// 无备用空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span>  deque&lt;_Tp,_Alloc&gt;::_M_push_front_aux(<span class="keyword">const</span> value_type&amp; <span class="keyword">__t</span>) &#123;</span><br><span class="line">  value_type __t_copy = <span class="keyword">__t</span>;</span><br><span class="line">  _M_reserve_map_at_front();    <span class="comment">// 若符合某种条件则必须重换一个map</span></span><br><span class="line">  *(_M_start._M_node - <span class="number">1</span>) = _M_allocate_node();</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    _M_start._M_set_node(_M_start._M_node - <span class="number">1</span>);</span><br><span class="line">    _M_start._M_cur = _M_start._M_last - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">construct</span>(_M_start._M_cur, __t_copy);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - <span class="number">1</span>))));</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面的图展示了，<code>push_front</code> 后的缓冲区</p><p><img src="image-20191112214556469.png" alt="image-20191112214556469" style="zoom:50%;" /></p><p>最后，我们来看一下两个至关重要的函数：<code>_M_reserve_map_at_back()</code> 和 <code>_M_reserve_map_at_front()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _M_reserve_map_at_back (size_type __nodes_to_add = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__nodes_to_add + <span class="number">1</span> &gt; _M_map_size - (_M_finish._M_node - _M_map))  <span class="comment">// 因为从0开始</span></span><br><span class="line">    _M_reallocate_map(__nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _M_reserve_map_at_front (size_type __nodes_to_add = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__nodes_to_add &gt; <span class="built_in">size_type</span>(_M_start._M_node - _M_map))</span><br><span class="line">    _M_reallocate_map(__nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add,</span><br><span class="line">                                          <span class="keyword">bool</span> __add_at_front)</span><br><span class="line">&#123;</span><br><span class="line">  size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + <span class="number">1</span>;</span><br><span class="line">  size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_nstart;</span><br><span class="line">  <span class="keyword">if</span> (_M_map_size &gt; <span class="number">2</span> * __new_num_nodes) &#123;</span><br><span class="line">    __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / <span class="number">2</span> </span><br><span class="line">                     + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (__new_nstart &lt; _M_start._M_node)</span><br><span class="line">      <span class="built_in">copy</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">copy_backward</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, </span><br><span class="line">                    __new_nstart + __old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size_type __new_map_size = </span><br><span class="line">      _M_map_size + <span class="built_in">max</span>(_M_map_size, __nodes_to_add) + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    _Map_pointer __new_map = _M_allocate_map(__new_map_size);</span><br><span class="line">    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / <span class="number">2</span></span><br><span class="line">                         + (__add_at_front ? __nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">copy</span>(_M_start._M_node, _M_finish._M_node + <span class="number">1</span>, __new_nstart);</span><br><span class="line">    _M_deallocate_map(_M_map, _M_map_size);</span><br><span class="line"></span><br><span class="line">    _M_map = __new_map;</span><br><span class="line">    _M_map_size = __new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _M_start._M_set_node(__new_nstart);</span><br><span class="line">  _M_finish._M_set_node(__new_nstart + __old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上，与 vector 比较类似，申请一块新的连续空间，将原来的 map 信息拷贝过来，然后释放原来的 map 空间</p>]]></content>
      
      
      <categories>
          
          <category> STL源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码解析之list</title>
      <link href="/posts/434547881/"/>
      <url>/posts/434547881/</url>
      
        <content type="html"><![CDATA[<blockquote><p>相比较于 vector 的连续线性空间， list 就显得复杂许多，它的好处是每次插入或删除一个元素，就配置或释放一个元素空间。因此 list 对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素删除，list 永远是常数时间。</p></blockquote><span id="more"></span><h3 id="list-的节点">1. list 的节点</h3><p>list 本身和 list 的节点是不同的结构，需要分开设计。以下是 STL list 的节点结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span> &#123;</span></span><br><span class="line">  _List_node_base* _M_next;</span><br><span class="line">  _List_node_base* _M_prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_node</span> :</span> <span class="keyword">public</span> _List_node_base &#123;</span><br><span class="line">  _Tp _M_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意这里有一个常见的面试题，就是 ListNode 中的 prev 和 next 指针可以不使用指针么？答案肯定是不可以的，因为如何不使用指针，而使用自身的话，<code>sizeof()</code> 操作就会无线循环下去。</p><h3 id="list-的迭代器">2. list 的迭代器</h3><p>list 不能够像 vector 一样以普通指针作为迭代器，因为它的空间不是连续的，自然不支持随机读的操作。另外由于 list 是一个双向链表，随意需要支持前后两个方向的移动，所以 list 提供的是 <code>Bidirectional Iterators</code>。</p><p>因为 vector 使用的是原生指针，天然具有加减等一系列能力。而 list 不使用原生指针，所以需要我们自己设计。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator_base</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>                     size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line"></span><br><span class="line">  _List_node_base* _M_node;    <span class="comment">// 指向list的节点</span></span><br><span class="line"></span><br><span class="line">  _List_iterator_base(_List_node_base* __x) : _M_node(__x) &#123;&#125;</span><br><span class="line">  _List_iterator_base() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _M_incr() &#123; _M_node = _M_node-&gt;_M_next; &#125;</span><br><span class="line">  <span class="keyword">void</span> _M_decr() &#123; _M_node = _M_node-&gt;_M_prev; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _M_node == __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> _List_iterator_base&amp; __x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _M_node != __x._M_node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Ref</span>, <span class="keyword">class</span> _<span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span> :</span> <span class="keyword">public</span> _List_iterator_base &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Ref,_Ptr&gt;             _Self;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</span><br><span class="line"></span><br><span class="line">  _List_iterator(_Node* __x) : _List_iterator_base(__x) &#123;&#125;</span><br><span class="line">  _List_iterator() &#123;&#125;</span><br><span class="line">  _List_iterator(<span class="keyword">const</span> iterator&amp; __x) : _List_iterator_base(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((_Node*) _M_node)-&gt;_M_data; &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_incr();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_incr();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; </span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_decr();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_M_decr();</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="list-的数据结构">3. list 的数据结构</h3><p>list 不仅是一个双向链表，而且还是一个环形链表。所以只需要一个指针，便可以完整表示整个链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_base</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  _List_node&lt;_Tp&gt;* _M_node;   <span class="comment">// 只需要一个指针，就可以表示整个环状双向链表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果让指针 node 指向刻意置于尾端的一个空白节点，node 便能符合 STL 对于前闭后开区间的要求。这么一来，以下几个函数便能轻易完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (_Node*)(_M_node-&gt;_M_next); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> _M_node; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _M_node-&gt;_M_next == _M_node; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  size_type __result = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), __result);</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> *(--<span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure><p><img src="image-20191112124539886.png" alt="image-20191112124539886" style="zoom: 33%;" /></p><h3 id="list-的构造与内存管理">4. list 的构造与内存管理</h3><p>list 缺省使用 alloc 作为空间配置器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_List_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type;</span><br><span class="line">  </span><br><span class="line">  _List_node&lt;_Tp&gt;* _M_get_node() &#123; <span class="keyword">return</span> _Alloc_type::<span class="built_in">allocate</span>(<span class="number">1</span>); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> _M_put_node(_List_node&lt;_Tp&gt;* __p) &#123; _Alloc_type::<span class="built_in">deallocate</span>(__p, <span class="number">1</span>); &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list 提供许多的构造函数，其中默认构造函数允许我们不指定任何参数做出一个空的 list 出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_List_base(<span class="keyword">const</span> allocator_type&amp;) &#123;</span><br><span class="line">  _M_node = _M_get_node();</span><br><span class="line">  _M_node-&gt;_M_next = _M_node;</span><br><span class="line">  _M_node-&gt;_M_prev = _M_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="keyword">const</span> allocator_type&amp; __a = <span class="built_in">allocator_type</span>()) : _Base(__a) &#123; &#125;</span><br></pre></td></tr></table></figure><p>当我们调用 <code>push_back()</code> 将新元素插入 list 尾端时，此函数调用 <code>insert</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">()</span> </span>&#123; <span class="built_in">insert</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">()</span>  </span>&#123; <span class="built_in">insert</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator __position, <span class="keyword">const</span> _Tp&amp; __x)</span> </span>&#123;</span><br><span class="line">  _Node* __tmp = _M_create_node(__x);   <span class="comment">// 产生一个节点，内容为x</span></span><br><span class="line">  __tmp-&gt;_M_next = __position._M_node;</span><br><span class="line">  __tmp-&gt;_M_prev = __position._M_node-&gt;_M_prev;</span><br><span class="line">  __position._M_node-&gt;_M_prev-&gt;_M_next = __tmp;</span><br><span class="line">  __position._M_node-&gt;_M_prev = __tmp;</span><br><span class="line">  <span class="keyword">return</span> __tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator __position)</span> </span>&#123;</span><br><span class="line">  _List_node_base* __next_node = __position._M_node-&gt;_M_next;</span><br><span class="line">  _List_node_base* __prev_node = __position._M_node-&gt;_M_prev;</span><br><span class="line">  _Node* __n = (_Node*) __position._M_node;</span><br><span class="line">  __prev_node-&gt;_M_next = __next_node;</span><br><span class="line">  __next_node-&gt;_M_prev = __prev_node;</span><br><span class="line">  _Destroy(&amp;__n-&gt;_M_data);</span><br><span class="line">  _M_put_node(__n);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>((_Node*) __next_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码解析之vector</title>
      <link href="/posts/2327191393/"/>
      <url>/posts/2327191393/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Vector 的数据安排以及操作方式，与 array 非常相似。两者的唯一差别在于空间的运用的灵活性。array 是静态空间，一旦配置了就不能改变，想要改变就需要客端自己实现配置新空间、将元素从旧空间搬到新空间、再把旧空间还给系统。vector 是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。换句话说，vector 将复杂琐碎的操作替我们实现了。</p></blockquote><span id="more"></span><h3 id="vector-的迭代器">1. vector 的迭代器</h3><p>通过上一篇文章的介绍，我们了解了什么是迭代器 Iterator 、以及迭代器的种类和如何工作的。vector 维护的是一个连续的线性空间。普通指针天然的符合要求，所以，vector 提供的是 Random Access Iterator。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;   <span class="comment">// vector的迭代器</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的源码很好的解释了我们平时写程序的时候，经常写的：<code>vector&lt;int&gt;::iterator</code></p><h3 id="vector-的数据结构">2. vector 的数据结构</h3><p>vector采用的数据结构非常简单：<strong>线性连续空间</strong>。用两个迭代器 <code>start</code> 和 <code>finish</code> 分别指向配置得来的连续空间中目前已经使用的范围，并以迭代器 <code>end_of_storage</code> 指向整块连续空间的尾端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  iterator start;</span><br><span class="line">  iterator finish;</span><br><span class="line">  iterator end_of_storage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="image-20191111155254398.png" alt="image-20191111155254398" style="zoom:50%;" /></p><h3 id="vector-的构造与内存管理">3. vector 的构造与内存管理</h3><p>我们通过平时的程序来理解内存管理。</p><p>首先，vector 缺省使用 alloc 作为空间配置器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// data_allocator::allocate(n) 表示配置n个空间</span></span><br></pre></td></tr></table></figure><p>接下来看 vector 的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, cosnt T&amp; value)</span> </span>&#123;</span><br><span class="line">  start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">  finish = start + n;</span><br><span class="line">  end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">  iterator result = data_allocator::<span class="built_in">allocate</span>(n);</span><br><span class="line">  <span class="built_in">uninitialized_fill_n</span>(result, n, x);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新版的 SGI STL 不需要这么复杂的3个函数，通过继承基类 vector_base 在基类的构造函数完成部分操作</span></span><br></pre></td></tr></table></figure><p>我们构造好一个 vector 之后，往往会使用 <code>push_back(x)</code> 来添加新的元素。这时会检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整 finish 的位置。如果没有备用空间，就需要扩充空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    <span class="built_in">construct</span>(finish, x);</span><br><span class="line">    ++finish;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert_aux是服务于insert函数的，push_back()相当于特例</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    <span class="comment">// 针对一般的insert，即在position处插入x</span></span><br><span class="line">    <span class="comment">// 首先需要把元素整体后移</span></span><br><span class="line">    <span class="comment">// 在备用空间起始处构造第一个元素</span></span><br><span class="line">    <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>); <span class="comment">// 将[positon, finish-2) 的元素整体后移</span></span><br><span class="line">    *position = x_copy;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没有备用空间了</span></span><br><span class="line">    <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span>*old_size : <span class="number">1</span>;</span><br><span class="line">    iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 将[start, position)原有的内容拷贝到新的 vector</span></span><br><span class="line">      new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">      <span class="comment">// 设置新position的新值</span></span><br><span class="line">      <span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">      ++new_finish;</span><br><span class="line">      <span class="comment">// 将原本[position, finish)的内容拷贝到新的 vector</span></span><br><span class="line">      new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">      <span class="comment">// roll back</span></span><br><span class="line">      <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">      data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">      <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 析构并释放原 vector</span></span><br><span class="line">  <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">deallocate</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调整迭代器指向新的vector</span></span><br><span class="line">  start = new_start;</span><br><span class="line">  finish = new_finish;</span><br><span class="line">  end_of_stroage = new_start + len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，所谓动态增加大小，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放空间。因此，对 vector 的任何操作，一旦引起空间重新配置，指向原 vector 的所有迭代器就都失效了。</p>]]></content>
      
      
      <categories>
          
          <category> STL源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码解析 </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码解析之迭代器iterator</title>
      <link href="/posts/3482955723/"/>
      <url>/posts/3482955723/</url>
      
        <content type="html"><![CDATA[<blockquote><p>迭代器（iterator）是一种抽象的设计概念，它提供一种方法，使之能够依序访问某个容器所含的各个元素，而又无需暴露该聚合物的内部表述方式。</p><p>试想一下，如果对每一个容器都定义一个 find 算法是不是显得和冗余呢？所以，我们需要<strong>把容器和算法解耦</strong>，定义一个泛型算法对每一个容器都适用。那么，现在的问题变成了<strong>算法如何访问容器内的数据</strong>，这个时候 <strong>迭代器（iterator）</strong> 就应运而生了。</p></blockquote><span id="more"></span><h3 id="什么是迭代器">1. 什么是迭代器</h3><p>迭代器其实是一种智能指针，而指针的最重要的作用就是读取内容和成员访问，所以，迭代器最重要的就是实现 <code>operator*</code> 和 <code>operator-&gt;</code> 的重载。</p><p>所以当我们知道一个容器的内部实现细节的时候，比如说 List，就可以自己动手写一个迭代器。但是，这样就无可避免的暴露了太多 List 的实现细节。</p><p>既然无可避免，干脆就把迭代器的开发工作交给 List 的设计者就好了，如此一来，所有实现细节反而得以封装起来不被使用者看到，这正是为什么每一种 STL 容器都提供有专属迭代器的缘故。</p><h3 id="迭代器相应型别">2. 迭代器相应型别</h3><p>在算法中运用迭代器时，很可能会用到其相应型别，即<strong>迭代器所指之物的型别</strong>。比如说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_impl</span><span class="params">(I iter, T t)</span> </span>&#123;</span><br><span class="line">  T tmp;  <span class="comment">// 这里的T就是我们推导出来的类型</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(I iter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里I是一个迭代器，比如 vector&lt;int&gt;::iterator</span></span><br><span class="line">  <span class="comment">// 但是，我们这里想要定义一个迭代器相应型别的变量，即 int tmp</span></span><br><span class="line">  <span class="comment">// 显然无法直接获得类型，那么我们可以利用 function template 的参数推导机制</span></span><br><span class="line">  <span class="comment">// 这里调用另一个函数  func_impl</span></span><br><span class="line">  <span class="built_in">func_impl</span>(iter, *iter);   <span class="comment">// *iter 我们可以得到iter指向对象的内容，参数推导机制将推导出来对应的类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的参数类型推导技巧虽然可用于 value type，但是如果我们现在想让 value type 作为函数的返回值类型，那么这个方法就无法做到了。我们需要其他办法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyIter</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;  <span class="comment">// 内嵌型别声明</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> I::value_type <span class="title">func</span><span class="params">(I iter)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// func() 的返回类型必须加上关键词typename，因为T是一个template参数，在它被编译器具体化之前，编译器</span></span><br><span class="line">  <span class="comment">// 对T一无所知。关键词typename的用意在于告诉编译器这是一个型别</span></span><br><span class="line">  <span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特性萃取机-traits">2.1. 特性萃取机 traits</h4><p>更具体一点，我们设计一个 “特性萃取机”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span>    <span class="comment">// traits意为“特性”</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个所谓的 <code>traits</code> 的作用为：如果 <code>I</code> 定义有自己的 <code>value_type</code>，那么通过这个 <code>traits</code> 的作用，萃取出来的 <code>value_type</code> 就是 <code>I::value_type</code>。先前的 <code>func</code> 我们就可以改写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::<span class="function">value_type <span class="title">func</span><span class="params">(I iter)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是多了这一层间接性，带来什么好处呢？好处就是 <code>traits</code> 可以拥有特化版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>I*&gt; &#123;    <span class="comment">// 原生指针虽然不是一种class，但是该版本可以得到它的value_type</span></span><br><span class="line">  <span class="keyword">typedef</span> I value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是请注意，针对 “指向常数对象的指针” <code>iterator_traits&lt;const int*&gt;::value_type</code> 得到什么结果呢？根据C++的类型推导原则，获得的是 const int 而非 int，但是这显然不是我们所期望的，所以我们可以定义另一版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> I*&gt; &#123;    <span class="comment">// 原生指针虽然不是一种class，但是该版本可以得到它的value_type</span></span><br><span class="line">  <span class="keyword">typedef</span> I value_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，我们可以定义一个 <strong>特性萃取机</strong></p><p><img src="image-20191110174517403.png" alt="image-20191110174517403" style="zoom:50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span><span class="keyword">const</span> I*&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type        value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference         reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="value-type">2.2. value type</h4><p>迭代器所指对象的型别，任何一个打算与STL算法有完美搭配的 class，都应该定义自己的 value type 内嵌型别。</p><h4 id="difference-type">2.3. difference type</h4><p>用来代表两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量。如果一个泛型算法提供计数功能，例如 STL 的 <code>count()</code> ，其返回值就必须使用迭代器的 <code>difference_type</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::<span class="function">difference_type <span class="title">count</span><span class="params">(I first, I last, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first == value)</span><br><span class="line">      ++n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reference-type">2.4. reference type</h4><p>如果说 p 是一个 iterator，那么 <code>*p</code> 的类型自然就是 <code>T&amp;</code>；同理如果 p 是一个 const iterator，那么 <code>*p</code> 的类型就是 <code>const T&amp;</code></p><h4 id="pointer-type">2.5. pointer type</h4><p>如果传回一个左值，令它代表 p 所指之物是可能的；那么传回一个左值，令它代表 p 所指之物的地址同样也是合理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Item&amp; <span class="keyword">operator</span>*()  &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">Item* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"><span class="comment">// Item&amp; 就是一个 reference type</span></span><br><span class="line"><span class="comment">// Item* 就是一个 pointer type</span></span><br></pre></td></tr></table></figure><h4 id="iterator-category">2.6. iterator category</h4><ul><li>Input Iterator：这种迭代器所指的对象，不允许外界改变。只读（read only）</li><li>Output Iterator：只写（write only）</li><li>Forward Iterator：允许读写</li><li>Bidirectional Iterator：可双向移动</li><li>Random Access Iterator：可以随意移动</li></ul><p>我们以 <code>advance()</code> 函数为例，该函数的作用的移动 Iterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_II</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 单向，逐一前进</span></span><br><span class="line">  <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_BI</span><span class="params">(BidirectionalIterator&amp; i, Distance n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 双向，逐一前进</span></span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (n--) --i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance_RAI</span><span class="params">(RandomAccessIterator&amp; i, Distance n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 双向，跳跃前进</span></span><br><span class="line">  i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当程序调用 <code>advance()</code> 时，应该选用哪一份函数定义呢？如果选择 <code>advance_II</code> 对 <code>Random Access Iterator</code> 而言极度缺乏效率，原本 O(1) 的操作变成了 O(N)。所以，最直观的想法，也是我们平时写程序的时候最常用的方法，用 if-else 判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_random_access_iterator</span>(i))</span><br><span class="line">    <span class="built_in">advance_II</span>(i, n);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">is_bidirectional_iterator</span>(i))</span><br><span class="line">    <span class="built_in">advance_BI</span>(i, n);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">advance_II</span>(i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是像这样在<strong><font color='red'>执行期</font></strong>才决定使用哪一个版本，会影响程序的效率。所以，我们最好在<strong><font color='red'>编译期</font></strong>就选择正确的版本。</p><p><strong><font color='red'>重载函数机制可以达成这个目标</font></strong></p><p>我们观察上面的3个 <code>advance_xx</code> 函数的2个参数都是<strong>型别未定</strong>的（template），要想形成重载，我们需要再加上一个参数来区分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们定义5个class</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span>       :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="comment">// 这些class只作为标记使用，所以不需要任何成员</span></span><br></pre></td></tr></table></figure><p>下面，我们来改写重载的 <code>advance</code> 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(InputIterator&amp; i, Distance n, input_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(BidirectionalIterator&amp; i, Distance n， bidirectional_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) <span class="keyword">while</span> (n--) ++i;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">while</span> (n--) --i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __advance(RandomAccessIterator&amp; i, Distance n, random_access_iterator_tag) &#123;</span><br><span class="line">  i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(InputIterator&amp; i, Distance n)</span> </span>&#123;</span><br><span class="line">  __advance(i, n, </span><br><span class="line">           iterator_traits&lt;InputIterator&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何一个迭代器，其类型永远应该落在 “该迭代器所隶属的各种类型中，最强化的那个”。例如，<code>int*</code> 既是 <code>RandomAccessIterator</code> ，又是 <code>BidirectionalIterator</code>，同时也是 <code>Forward Iterator</code> 和 <code>Input Iterator</code>那么它的类型就应该归为：<code>RandomAccessIterator</code></p><h3 id="总结">3. 总结</h3><p>设计适当的相应型别是迭代器的责任。设计适当的迭代器，则视容器的责任。唯容器本身，才知道该设计出怎样的迭代器来遍历自己，并执行迭代器该有的各种行为（前进、后退、取值、取用成员...）。至于算法，完全可以独立于容器和迭代器之外自行发展，只要设计时以迭代器为对外接口就行。</p><p><strong>traits</strong> 编程技法大量运用于 STL 实现品中，它利用 “内嵌类别” 的编程技巧与编译器的 template 参数推导功能，增强 C++ 未能提供的关于型别认证方面的能力，弥补 C++ 不为强型别语言的遗憾。</p>]]></content>
      
      
      <categories>
          
          <category> STL源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码解析 </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL源码解析之空间配置器allocator</title>
      <link href="/posts/1556292897/"/>
      <url>/posts/1556292897/</url>
      
        <content type="html"><![CDATA[<blockquote><p>空间配置器（allocator）总是隐藏在一切容器的背后，默默工作，默默付出。整个STL的操作对象都存放在容器之内，所以时时刻刻都要与 allocator 打交道。那么为什么不叫内存适配器呢？因为空间不一定是内存，我们也可以对磁盘或者其他辅助存储介质进行操作。</p></blockquote><span id="more"></span><h3 id="allocator作用">1. allocator作用</h3><p>我们在编写程序的时候，经常会用到 vector、map、set... 等容器，我们定义的时候只需要把类型指定就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们学习 C++ 的时候都知道 vector 容器的空间是动态分配的，那么系统是如何为它分配空间的呢？其实当我们定义一个 vector 变量的时候，一直都有一个隐形的参数 allocator，让我们看一下 vector 的部分源码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Allocator</span> =</span> allocator&lt;T&gt; &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，一个完整的 vector 定义应该是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>, std::allocator&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br></pre></td></tr></table></figure><p>其中模板参数 <code>class T</code> 被替换成了 <code>int</code> ，第二个模板参数默认为 <code>std::allocator&lt;int&gt;</code>。</p><p>为什么 allocator 也需要接收这个模板参数 T 呢？</p><p>因为这个隐含的参数 allocator 不仅帮助我们完成<font color='red'><strong>内存的分配和释放</strong></font>，也帮助我们完成<strong><font color='red'>对象的构造和析构</font></strong>。知道类型才能调用对象的构造和析构函数。而且，对于分配内存，allocator 接口设计中有类似于”为n个T类型的对象分配内存”这种批量操作，这就需要知道类型才能算出对象需要的空间了。</p><p>既然 allocator 是一个参数，自然我们可以传入一个自定义的 allocator 类。根据STL的规范，以下是 allocator 的必要接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下各种 type 的涉及原由，后续阐述</span></span><br><span class="line">allocator::value_type</span><br><span class="line">allocator::pointer</span><br><span class="line">allocator::const_pointer</span><br><span class="line">allocator::reference</span><br><span class="line">allocator::const_reference</span><br><span class="line">allocator::size_type</span><br><span class="line">allocator::difference</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个嵌套的(nested)class template，class rebind&lt;U&gt;拥有唯一成员other，那是一个typedef，代表allocator&lt;U&gt;</span></span><br><span class="line"><span class="function">allocator::rebind</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">allocator::allocator</span><span class="params">()</span> <span class="comment">// 默认构造函数</span></span></span><br><span class="line"><span class="function"><span class="title">allocator::allocator</span><span class="params">(<span class="keyword">const</span> allocator&amp;)</span> <span class="comment">// 拷贝构造函数</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span> &lt;class U&gt;<span class="title">allocator::allocator</span><span class="params">(<span class="keyword">const</span> allocator&lt;U&gt;&amp;)</span> <span class="comment">// 泛化的拷贝构造函数</span></span></span><br><span class="line"><span class="function">allocator::~<span class="title">allocator</span><span class="params">()</span> <span class="comment">// 析构函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回某个对象的地址，a.address(x)等同于&amp;x</span></span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::address</span><span class="params">(reference x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回某个const对象的地址，a.address(x)等同于&amp;x</span></span></span><br><span class="line"><span class="function">const_pointer <span class="title">allocator::address</span><span class="params">(const_reference x)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 配置空间，足以存储n个T对象。第二个参数是个提示。实现上可能会利用它来增进区域性(locality)，或完全忽略之</span></span></span><br><span class="line"><span class="function">pointer <span class="title">allocator::allocate</span><span class="params">(size_type n, <span class="keyword">const</span> <span class="keyword">void</span>* = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 释放先前配置的空间</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocator::deallocate</span><span class="params">(pointer p, size_type n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回可成功配置的最大量</span></span></span><br><span class="line"><span class="function">size_type allocator:maxsize() const</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 调用对象的构造函数，等同于 new((void*)p) T(x)</span></span><br><span class="line"><span class="function">void allocator::construct(pointer p, const T&amp; x)</span></span><br><span class="line"><span class="function">// 调用对象的析构函数，等同于 p-&gt;~T()</span></span><br><span class="line"><span class="function">void allocator::destroy(pointer p)</span></span><br></pre></td></tr></table></figure><p><strong>然而，这样并不能通过编译（如果你使用的是GCC编译器），因为SGI STL的allocator并不完全符合STL规范，我们编写的符合规范的自然不能搭配使用，</strong>SGI STL版本的allocator具体实现在下文阐述。</p><h3 id="sgi-stl-的空间配置器">2. SGI STL 的空间配置器</h3><p>SGI STL 的配置器与众不同，也与标准规范不同，其名称是 alloc 而非 allocator，而且<strong>不接受任何参数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>, std::allocator&lt;<span class="keyword">int</span>&gt; &gt; v;    <span class="comment">// in VC or CB</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>, std::alloc&gt; v;              <span class="comment">// in GCC, SGI STL</span></span><br></pre></td></tr></table></figure><p>虽然 SGI 也定义有一个符合部分标准、名为 allocator 的配置器，在文件 defalloc.h 中实现。但 SGI 自己从未使用过它，也不建议我们使用。主要原因是效率不佳，它存在的意义仅在于为用户提供一个兼容老代码的折衷方法，其实现仅仅是对 new 和 delete 的简单包装。</p><p>一般而言，我们所习惯的 C++ 内存配置操作和释放操作是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span>...&#125;</span><br><span class="line">Foo* pf = <span class="keyword">new</span> <span class="built_in">Foo</span>();    <span class="comment">// 配置内存，构造对象</span></span><br><span class="line"><span class="keyword">delete</span> pf;              <span class="comment">// 析构对象，释放内存</span></span><br></pre></td></tr></table></figure><p>可以看到，new 和 delete 都包含两阶段的操作。为了精密分工， STL allocator 拥有四个操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alloc::<span class="built_in">allocate</span>()    <span class="comment">// 配置内存</span></span><br><span class="line">alloc::<span class="built_in">deallocate</span>()  <span class="comment">// 释放内存</span></span><br><span class="line">alloc::<span class="built_in">construct</span>()   <span class="comment">// 构造对象</span></span><br><span class="line">allo::<span class="built_in">destroy</span>()     <span class="comment">// 析构对象</span></span><br></pre></td></tr></table></figure><h4 id="构造和析构基本工具">2.1. 构造和析构基本工具</h4><p>STL 标准告诉我们，配置器定义于 <code>&lt;memory&gt;</code> 中，而在 <code>&lt;memory&gt;</code> 中包含两个头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_alloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stl_construct.h&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="image-20191109161802839.png" alt="image-20191109161802839" style="zoom: 50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Construct 接受一个指针p 和一个初值 value</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">T1</span>, <span class="keyword">class</span> _<span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Construct(_T1* __p, <span class="keyword">const</span> _T2&amp; __value) &#123;</span><br><span class="line">  <span class="keyword">new</span> ((<span class="keyword">void</span>*) __p) _T1(__value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// destroy 有两个版本</span></span><br><span class="line"><span class="comment">// 1. 接受一个指针，准备将该指针所指之物析构掉</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Destroy(_Tp* __pointer) &#123;</span><br><span class="line">  __pointer-&gt;~_Tp();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 接受 first 和 last 两个迭代器，将[first, last)范围内所有对象析构掉</span></span><br><span class="line"><span class="comment">// 首先利用 value_type() 获得迭代器所指对象的类别，再利用__type_traits&lt;T&gt;</span></span><br><span class="line"><span class="comment">// 判断该类型的析构函数是否无关痛痒。若是，则什么都不做；否则，循环释放</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">    <span class="built_in">destroy</span>(&amp;*__first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空间的配置与释放">2.2. 空间的配置与释放</h4><p>对象构造前的空间配置和对象析构后的空间释放，由 <code>&lt;stl_alloc.h&gt;</code> 负责，SGI 对此的设计哲学如下：</p><ul><li>向 System heap 申请空间</li><li>考虑多线程状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多“小型区块”可能造成的内存碎片问题</li></ul><p>以下的所有讨论都先不讨论多线程的状态。</p><p>为了解决内存碎片的问题，SGI 设计了双层级配置器</p><ul><li>第一级配置器直接使用 malloc() 和 free()；</li><li>第二级配置器则视情况采用不同的策略；</li><li>当配置区块超过 128 bytes 时，视之为<strong>过大</strong>，调用第一级配置器</li><li>当配置区块小于 128 bytes 时，视之为<strong>过小</strong>，调用第二级配置器（内存池）</li></ul><p>无论 alloc 被定义为第一级或第二级配置器，SGI 还为它再包装一个接口如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == __n ? <span class="number">0</span> : (_Tp*) _Alloc::<span class="built_in">allocate</span>(__n * <span class="built_in"><span class="keyword">sizeof</span></span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">return</span> (_Tp*) _Alloc::<span class="built_in">allocate</span>(<span class="built_in"><span class="keyword">sizeof</span></span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p, <span class="keyword">size_t</span> __n)</span></span></span><br><span class="line"><span class="function">      </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != __n) _Alloc::<span class="built_in">deallocate</span>(__p, __n * <span class="built_in"><span class="keyword">sizeof</span></span> (_Tp)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(_Tp* __p)</span></span></span><br><span class="line"><span class="function">      </span>&#123; _Alloc::<span class="built_in">deallocate</span>(__p, <span class="built_in"><span class="keyword">sizeof</span></span> (_Tp)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内部的四个成员函数其实都是单纯的转调用，调用传递给配置器的成员函数。</p><p>我们再来看 vector 的部分源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="keyword">class</span> _<span class="title">Alloc</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Vector_base</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;_Tp, _Alloc&gt; _M_data_allocator;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 vector 中是定义了一个 simple_alloc 的对象来进行相关的操作的。</p><h3 id="第一级配置器">3. 第一级配置器</h3><p>__malloc_alloc_template 是基于 malloc 实现的配置器，一般而言是线程安全的，并且对于空间的运用比较高效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 一下函数用来处理内存不足的情况，oom = out of memory</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_malloc(<span class="keyword">size_t</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_oom_realloc(<span class="keyword">void</span>*, <span class="keyword">size_t</span>);</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">malloc</span>(__n);   <span class="comment">// 直接使用 malloc</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_malloc(__n);   <span class="comment">// 无法满足要求，内存不足</span></span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* __n */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(__p);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> __new_sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* __result = <span class="built_in">realloc</span>(__p, __new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == __result) __result = _S_oom_realloc(__p, __new_sz);</span><br><span class="line">    <span class="keyword">return</span> __result;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __set_malloc_handler(<span class="keyword">void</span> (*__f)()))</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = __f;</span><br><span class="line">    <span class="keyword">return</span>(__old);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ------------------------------------- */</span></span><br><span class="line"><span class="comment">// malloc_alloc out-of-memory handling</span></span><br><span class="line"><span class="comment">// __malloc_alloc_oom_handler 初始值为0，有待客端设定</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (* __malloc_alloc_template&lt;__inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _S_oom_malloc 的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_malloc(<span class="keyword">size_t</span> __n) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 不断尝试释放、配置、再释放、再配置...</span></span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;  <span class="comment">// 抛出异常</span></span><br><span class="line">        (*__my_malloc_handler)();  <span class="comment">// 调用处理例程，企图释放内存</span></span><br><span class="line">        __result = <span class="built_in">malloc</span>(__n);    <span class="comment">// 尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _S_oom_realloc 的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __malloc_alloc_template&lt;__inst&gt;::_S_oom_realloc(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (* __my_malloc_handler)();</span><br><span class="line">    <span class="keyword">void</span>* __result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 不断尝试释放、配置、再释放、再配置...</span></span><br><span class="line">        __my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == __my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;   <span class="comment">// 抛出异常</span></span><br><span class="line">        (*__my_malloc_handler)();      <span class="comment">// 调用处理例程，企图释放内存</span></span><br><span class="line">        __result = <span class="built_in">realloc</span>(__p, __n);  <span class="comment">// 尝试配置内存</span></span><br><span class="line">        <span class="keyword">if</span> (__result) <span class="keyword">return</span>(__result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的源码可以看出，SGI 第一级配置器的 <code>allocate()</code> 和 <code>reallocate()</code> 都是在调用 <code>malloc()</code> 和 <code>realloc()</code> 不成功后，改调用 <code>_S_oom_malloc()</code> 和 <code>_S_oom_realloc()</code>。后两者都有内循环，不断调用 <strong>内存不足处理例程</strong>，期望在某次调用之后，获得足够的内存而圆满完成任务。</p><p>但是，如果<strong>内存不足处理例程</strong> <code>__malloc_alloc_oom_handler</code> 没有被客端设定，则会调用 <code>__THROW_BAD_ALLOC</code> 抛出 bad_alloc 异常或者 exit(1) 终止程序。</p><p><font color='red'>！！！设计内存不足处理例程是客端的责任</font></p><h3 id="第二级配置器">4. 第二级配置器</h3><p>__default_alloc_template 第二级配置器多了一些机制，避免太多小额区块造成内存的碎片。小额区块带来的其实不仅是内存碎片，配置时的额外负担（overhead）也是一个大问题。</p><p>SGI 第二级配置器的做法是，如果区块够大，超过 128 bytes 时，就移交第一级配置器处理。当区块小于 128 bytes 时，则以内存池管理。维护 16 个 free-lists，各自管理大小分别为8，16，24，32，... ，120，128 bytes的小额区块，SGI 第二级配置器会将任何小额区块的内存需求量上调至 8 的倍数。</p><p>free-list 的结点结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line"><span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了维护链表，每个节点需要额外的指针，这不又造成了另一种额外负担吗？</p><p>事实上，并没有额外的存储消耗，因为这不是一个 struct 而是一个 union ，union 中的变量存在<strong>同一个地址开始的内存单元</strong>中，当区块被分配给客端使用后，则不存在 free list 的指针指向它了。</p><p><img src="image-20191109213342958.png" alt="image-20191109213342958" style="zoom:50%;" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">default_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span>_ALIGN = <span class="number">8</span>&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span>_MAX_BYTES = <span class="number">128</span>&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span>_NFREELISTS = <span class="number">16</span>&#125;;  <span class="comment">// _MAX_BYTES/_ALIGN</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 将 bytes 上调至8的倍数</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_round_up(<span class="keyword">size_t</span> __bytes) &#123; </span><br><span class="line">    <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>) _ALIGN<span class="number">-1</span>) &amp; ~((<span class="keyword">size_t</span>) _ALIGN - <span class="number">1</span>)); </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">Obj</span>* _<span class="title">M_free_list_link</span>;</span></span><br><span class="line">    <span class="keyword">char</span> _M_client_data[<span class="number">1</span>];    <span class="comment">/* The client sees this.        */</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS];   <span class="comment">// 16 个free list</span></span><br><span class="line">  <span class="comment">// 根据区块大小，决定使用哪个free list</span></span><br><span class="line">  <span class="keyword">static</span>  <span class="keyword">size_t</span> _S_freelist_index(<span class="keyword">size_t</span> __bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> (((__bytes) + (<span class="keyword">size_t</span>)_ALIGN<span class="number">-1</span>)/(<span class="keyword">size_t</span>)_ALIGN - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个大小为n的对象，并可能假如大小为n的其它区块到free list</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span>* _S_refill(<span class="keyword">size_t</span> __n);</span><br><span class="line">  <span class="comment">// 配置一大块空间，可容纳nobjs个大小为size的区块</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size, <span class="keyword">int</span>&amp; __nobjs);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Chunk allocation state.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_start_free;  <span class="comment">// 内存池起始位置</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span>* _S_end_free;    <span class="comment">// 内存池结束位置</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> _S_heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __old_sz, <span class="keyword">size_t</span> __new_sz)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初值设定</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">size_t</span> __default_alloc_template&lt;__threads, __inst&gt;::_S_heap_size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="空间配置函数-allocate">4.1. 空间配置函数 allocate</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* __ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;  <span class="comment">// 大于128bytes就调用第一级配置器</span></span><br><span class="line">    __ret = malloc_alloc::<span class="built_in">allocate</span>(__n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找16个free lists中适当的一个</span></span><br><span class="line">    _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">    _Obj* __RESTRICT __result = *__my_free_list;</span><br><span class="line">    <span class="keyword">if</span> (__result == <span class="number">0</span>) &#123;  <span class="comment">// 如果没找到可用的free list，准备重新填充free list</span></span><br><span class="line">      __ret = _S_refill(_S_round_up(__n));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *__my_free_list = __result -&gt; _M_free_list_link;</span><br><span class="line">      __ret = __result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20191109215258948.png" alt="image-20191109215258948" style="zoom:50%;" /></p><h4 id="空间释放函数-deallocate">4.2. 空间释放函数 deallocate</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* __p, <span class="keyword">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__n &gt; (<span class="keyword">size_t</span>) _MAX_BYTES) &#123;  <span class="comment">// 如果大于128bytes，就调用第一级配置器</span></span><br><span class="line">    malloc_alloc::<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 寻找16个free lists中适当的一个</span></span><br><span class="line">    _Obj* __STL_VOLATILE*  __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">    _Obj* __q = (_Obj*)__p;</span><br><span class="line">    <span class="comment">// 调整free list，回收区块</span></span><br><span class="line">    __q -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">    *__my_free_list = __q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20191109215721342.png" alt="image-20191109215721342" style="zoom:50%;" /></p><h4 id="重新填充-refill">4.3. 重新填充 refill</h4><p>当 <code>allocate()</code> 过程中，发现 free list 中没有可用区块了时，就调用 <code>refill()</code>，准备为 free list 重新填充空间。新的空间取自内存池（经由 <code>chunk_alloc()</code> 完成）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> threads, <span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="keyword">void</span>* __default_alloc_template&lt;__threads, __inst&gt;::_S_refill(<span class="keyword">size_t</span> __n) &#123;</span><br><span class="line">  <span class="keyword">int</span> __nobjs = <span class="number">20</span>;  <span class="comment">// 计划取得20个新的节点</span></span><br><span class="line">  <span class="keyword">char</span>* __chunk = _S_chunk_alloc(__n, __nobjs);  <span class="comment">// nobjs传入的是引用</span></span><br><span class="line">  _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">  _Obj* __result;</span><br><span class="line">  _Obj* __current_obj;</span><br><span class="line">  _Obj* __next_obj;</span><br><span class="line">  <span class="keyword">int</span> __i;</span><br><span class="line">  <span class="comment">// 如果只取得一个区块，这个区块就分配给调用者使用，free list无新节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> == __nobjs) <span class="keyword">return</span>(__chunk);</span><br><span class="line">  <span class="comment">// 否则，准备调整free list，纳入新节点</span></span><br><span class="line">  __my_free_list = _S_free_list + _S_freelist_index(__n);</span><br><span class="line">  <span class="comment">/* Build free list in chunk */</span></span><br><span class="line">  __result = (_Obj*)__chunk;  <span class="comment">// 准备返回客端</span></span><br><span class="line">  *__my_free_list = __next_obj = (_Obj*)(__chunk + __n);</span><br><span class="line">  <span class="keyword">for</span> (__i = <span class="number">1</span>; ; __i++) &#123;  <span class="comment">// 从1开始，因为0返回给客端</span></span><br><span class="line">  __current_obj = __next_obj;</span><br><span class="line">    __next_obj = (_Obj*)((<span class="keyword">char</span>*)__next_obj + __n);</span><br><span class="line">    <span class="keyword">if</span> (__nobjs - <span class="number">1</span> == __i) &#123;</span><br><span class="line">      __current_obj -&gt; _M_free_list_link = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      __current_obj -&gt; _M_free_list_link = __next_obj;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(__result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存池">4.4. 内存池</h4><p>从内存池中取空间给 free list 使用，是 <code>chunk_alloc()</code> 的工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We allocate memory in large chunks in order to avoid fragmenting     */</span></span><br><span class="line"><span class="comment">/* the malloc heap too much.                                            */</span></span><br><span class="line"><span class="comment">/* We assume that size is properly aligned.                             */</span></span><br><span class="line"><span class="comment">/* We hold the allocation lock.                                         */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> __threads, <span class="keyword">int</span> __inst&gt;</span><br><span class="line"><span class="keyword">char</span>* _S_chunk_alloc(<span class="keyword">size_t</span> __size,  <span class="keyword">int</span>&amp; __nobjs) &#123;</span><br><span class="line">  <span class="keyword">char</span>* __result;</span><br><span class="line">  <span class="keyword">size_t</span> __total_bytes = __size * __nobjs;    <span class="comment">// eg. 32 * 20</span></span><br><span class="line">  <span class="keyword">size_t</span> __bytes_left = _S_end_free - _S_start_free;    <span class="comment">// 内存池剩余空间</span></span><br><span class="line">  <span class="keyword">if</span> (__bytes_left &gt;= __total_bytes) &#123;</span><br><span class="line">  <span class="comment">// 内存池剩余空间完全满足需求量</span></span><br><span class="line">    __result = _S_start_free;</span><br><span class="line">    _S_start_free += __total_bytes;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__bytes_left &gt;= __size) &#123;</span><br><span class="line">    <span class="comment">// 内存池剩余空间不能完全满足需求量，但足够提供1个以上的区块</span></span><br><span class="line">    __nobjs = (<span class="keyword">int</span>)(__bytes_left/__size);</span><br><span class="line">    __total_bytes = __size * __nobjs;</span><br><span class="line">    __result = _S_start_free;</span><br><span class="line">    _S_start_free += __total_bytes;</span><br><span class="line">    <span class="keyword">return</span>(__result);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 内存剩余空间连一个区块的大小都无法提供</span></span><br><span class="line">    <span class="comment">// 新申请空间的大小为：需求量的2倍 + 随着配置次数增加而愈来愈大的附加量</span></span><br><span class="line">    <span class="keyword">size_t</span> __bytes_to_get = <span class="number">2</span> * __total_bytes + _S_round_up(_S_heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 利用内存池的零头</span></span><br><span class="line">    <span class="keyword">if</span> (__bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 分配给适当的free list</span></span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left);</span><br><span class="line">      ((_Obj*)_S_start_free) -&gt; _M_free_list_link = *__my_free_list;</span><br><span class="line">      *__my_free_list = (_Obj*)_S_start_free;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向 heap 申请空间</span></span><br><span class="line">    _S_start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(__bytes_to_get);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == _S_start_free) &#123;</span><br><span class="line">      <span class="comment">// heap空间不足，申请失败</span></span><br><span class="line">      <span class="keyword">size_t</span> __i;</span><br><span class="line">      _Obj* __STL_VOLATILE* __my_free_list;</span><br><span class="line">      _Obj* __p;</span><br><span class="line">      <span class="comment">// 1. 试着对我们拥有的内存做一些事情，这不会造成伤害</span></span><br><span class="line">      <span class="comment">// 我们不打算尝试分配较小的区块，因为这在多进程机器上容易导致灾难</span></span><br><span class="line">      <span class="comment">// 尝试搜索适当的free list（尚有未使用的区块，且区块足够大）</span></span><br><span class="line">      <span class="keyword">for</span> (__i = __size; __i &lt;= _MAX_BYTES; __i += _ALIGN) &#123;</span><br><span class="line">        __my_free_list = _S_free_list + _S_freelist_index(__i);</span><br><span class="line">        __p = *__my_free_list;</span><br><span class="line">        <span class="comment">// free list 还有未使用的区块</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != __p) &#123;</span><br><span class="line">          <span class="comment">// 调整free list释放出未使用的区块</span></span><br><span class="line">          *__my_free_list = __p -&gt; _M_free_list_link;</span><br><span class="line">          _S_start_free = (<span class="keyword">char</span>*)__p;</span><br><span class="line">          _S_end_free = _S_start_free + __i;</span><br><span class="line">          <span class="comment">// 递归调用自己，修正__nobjs</span></span><br><span class="line">          <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2. 山穷水尽，到处都没有可用的内存了</span></span><br><span class="line">      _S_end_free = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 调用第一级配置器，虽然第一级配置器也使用 malloc 机制， 但是它拥有 out-of-memory 处理机制</span></span><br><span class="line">      <span class="comment">// 或许有机会释放其它的内存，否则就抛出异常</span></span><br><span class="line">      _S_start_free = (<span class="keyword">char</span>*)malloc_alloc::<span class="built_in">allocate</span>(__bytes_to_get);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用从heap申请到的空间</span></span><br><span class="line">    _S_heap_size += __bytes_to_get;</span><br><span class="line">    _S_end_free = _S_start_free + __bytes_to_get;</span><br><span class="line">    <span class="keyword">return</span>(_S_chunk_alloc(__size, __nobjs));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看一个例子：</p><p>程序一开始，客端调用 <code>chunk_alloc(32, 20)</code> ，于是 <code>malloc()</code> 配置 40 个 32 bytes 区块，其中第 1 个交出，另外 19 个交给 <code>free_list[3]</code> 维护，<strong>剩下 20 个留给内存池</strong>。</p><p>接下来，客端调用 <code>chunk_alloc(64, 20)</code> ，此时 <code>free_list[7]</code> 空空如也，必须向内存池要求支持。此时的内存池只够供应 (32 * 20) / 64 = 10 个 64 bytes 区块，就把这 10 个区块返回，第 1 个交给客端，余 9 个由 <code>free_list[7]</code> 维护。<strong>此时内存池为空。</strong></p><p>接下来，客端调用 <code>chink_alloc(96, 20)</code>，此时 <code>free_list[11]</code> 空空如也，必须向内存池要求支持。此时的内存池也是空的，于是调用 <code>malloc()</code> 配置 40 + n（附加量）个 96 bytes区块，其中第 1 个交出，另 19 个交给 <code>free_list[11]</code> 维护，<strong>剩下 20 + n 个区块留给内存池</strong>。</p><p><img src="image-20191110143315504.png" alt="image-20191110143315504" style="zoom:50%;" /></p>]]></content>
      
      
      <categories>
          
          <category> STL源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL源码解析 </tag>
            
            <tag> 空间配置器 </tag>
            
            <tag> allocator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析select、poll、epoll</title>
      <link href="/posts/1856378058/"/>
      <url>/posts/1856378058/</url>
      
        <content type="html"><![CDATA[<blockquote><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但 select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p></blockquote><span id="more"></span><h3 id="select">1. select</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。</p><p>调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时函数返回。</p><p>select的一个<strong>缺点</strong>在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><p>fd_set是一个int型数组，大小为32，每一位都能与一打开的文件句柄建立联系，所以 32 * 32 = 1024</p><blockquote><p>select使用位域的方式来传递关心的文件描述符，位域就有最大长度，在Unix下是256，在Linux下是1024，好像可以调大，但是不方便</p></blockquote><h4 id="select优点">1.1. select优点</h4><ul><li>select() 可移植性更好，在某些Unix系统上不支持 poll() 。</li><li>select() 对于超时值提供了更好的精度：微秒，而 poll() 是毫秒。</li></ul><h4 id="select缺点">1.2. select缺点</h4><ul><li>单个进程可监视的fd数量被限制。</li><li>每次都需要重新将监控集合拷贝到内核（select会修改集合）。如果以万计的句柄会导致每次都要 copy 几十几百 KB 的内存到内核态，非常低效。</li><li>用户需要遍历描述符是否在集合中来判断哪个描述符就绪，这个判断是一个遍历的过程，性能随着描述符增多而下降，并且复杂度更高。</li><li>select每次返回都会修改监控集合，因此每次都需要用户重新向集合中添加所有描述符。</li></ul><h3 id="poll">2. poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>与select不同的是，poll不需要使用3个 <code>fd_set</code> ，poll使用一个 pollfd 的指针实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> fd;        <span class="comment">/* file descriptor */</span></span><br><span class="line">  <span class="keyword">short</span> events;  <span class="comment">/* requested events to watch */</span></span><br><span class="line">  <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每一个 pollfd 结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示 poll() 监视多个文件描述符。 每个结构体的 events 域是监视该文件描述符的事件掩码，由用户来设置这个域。 revents 域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域。 events 域中请求的任何事件都可能在 revents 域中返回。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POLLIN            有数据可读。</span><br><span class="line">POLLRDNORM        有普通数据可读。</span><br><span class="line">POLLRDBAND        有优先数据可读。</span><br><span class="line">POLLPRI           有紧迫数据可读。</span><br><span class="line">POLLOUT           写数据不会导致阻塞。</span><br><span class="line">POLLWRNORM        写普通数据不会导致阻塞。</span><br><span class="line">POLLWRBAND        写优先数据不会导致阻塞。</span><br><span class="line">POLLMSGSIGPOLL    消息可用</span><br><span class="line">---------------------------------------</span><br><span class="line">POLLER            指定的文件描述符发生错误。</span><br><span class="line">POLLHUP           指定的文件描述符挂起事件。</span><br><span class="line">POLLNVAL          指定的文件描述符非法。</span><br></pre></td></tr></table></figure><h4 id="poll优点">2.1. poll优点</h4><ul><li>poll 采用事件结构形式对描述符关心的事件进行监控，简化了 select 三种集合操作的流程。</li><li>poll 没有描述符上限的设置。</li></ul><h4 id="poll缺点">2.2. poll缺点</h4><ul><li>同样每次都需要将监控集合拷贝到内核。</li><li>在内核中进行轮询遍历判断就绪，性能随着描述符事件增多而下降。</li><li>也不会告诉用户具体哪一个描述符就绪，需要用户轮询遍历判断事件中的 revents。</li></ul><h3 id="epoll">3. epoll</h3><h4 id="epoll_create">3.1. epoll_create</h4><p>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span>；</span></span><br></pre></td></tr></table></figure><p>创建一个epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 select() 中的第一个参数，给出最大监听的 fd+1 的值，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p><p>当创建好 epoll 句柄后，它就会占用一个 fd 值。所以在使用完 epoll 后，必须调用 close() 关闭，否则可能导致 fd 被耗尽。</p><p><img src="1_k-PycQSwivn-jIoEhXsvxg.png" alt="1_k-PycQSwivn-jIoEhXsvxg" /></p><p>Linux 中每一个进程都有一个文件描述符的表，保存当前进程关联的文件描述符。这个表存在用户空间的。 Linux 系统空间中保存一张 “已打开的文件表”，里面保存着当前系统所有已经打开的文件。 文件系统中，每一个文件都是一个 iNode。</p><p><img src="1_zwsANOj2UkICip9FhDzl_Q.png" alt="1_zwsANOj2UkICip9FhDzl_Q" /></p><p>如上图所示，进程文件表中每一个 fd 关联到了 kernel 中阿的一个已经打开的文件（可能有多个 fd 指向同一个已经打开的文件）。同样的，kernel 中的已打开文件表指向了文件系统中的 iNode。</p><h4 id="epoll_ctl">3.2. epoll_ctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span>；</span></span><br></pre></td></tr></table></figure><p>该函数用来对指定的 socket 添加/删除/修改 需要监听的 event。</p><ul><li>epfd：是epoll_create()的返回值。</li><li>op：表示 op 操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD</li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中events表示感兴趣的事件和被触发的事件，可能的取值为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EPOLLIN： 表示对应的文件描述符可以读；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数可读；</span><br><span class="line">--------------------------------------</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 设置epoll工作模式为边缘触发；</span><br></pre></td></tr></table></figure><p><img src="1_Abjr5spvjK56w1p7PszWVw.jpeg" alt="1_Abjr5spvjK56w1p7PszWVw" /></p><h4 id="epoll_wait">3.3. epoll_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>等待 epfd上 的 io 事件，最多返回 maxevents 个事件。当监控的 fd 准备好了之后就会加入到 Ready List 中去。</p><p><img src="1_24HukCwzdkH0Vb8n-RHlFw.jpeg" alt="1_24HukCwzdkH0Vb8n-RHlFw" /></p><h4 id="水平触发lt">3.4. 水平触发（LT）</h4><p>缺省的工作方式，并且同时支持 block 和 non-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。</p><h4 id="边沿触发et">3.5. 边沿触发（ET）</h4><p>高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，等到下次有新的数据进来的时候才会再次出发就绪事件。</p><p>采用LT模式下， 如果accept调用有返回就可以马上建立当前这个连接了，再epoll_wait等待下次通知，和select一样。</p><p>但是对于ET而言，如果accpet调用有返回，除了建立当前这个连接外，不能马上就epoll_wait还需要继续循环accpet，直到返回-1，且errno==EAGAIN。</p><p><strong>为什么边沿触发要配合非阻塞IO</strong></p><p>因为如果是边缘触发的情况下，需要一次性把数据读完，就会调用while(read())这样的操作，在最后一次read的时候一定会被阻塞。因为阻塞式IO会在读完之后一直阻塞下去，非阻塞IO则会返回&lt;0，并让errno返回EAGAIN。</p><p><a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a></p><p><a href="http://www.gonglin91.com/linux-epoll-epoll的原理；struct-epoll_event-为什么要这样设计/">linux epoll epoll的原理；struct epoll_event 为什么要这样设计</a></p><p><a href="https://medium.com/@copyconstruct/the-method-to-epolls-madness-d9d2d6378642">The method to epoll’s madness</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析Linux的IO模型</title>
      <link href="/posts/4213317268/"/>
      <url>/posts/4213317268/</url>
      
        <content type="html"><![CDATA[<blockquote><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p></blockquote><span id="more"></span><h3 id="前言">1. 前言</h3><h4 id="用户空间和内核空间">1.1. 用户空间和内核空间</h4><p>程序是一系列代码段，数据段的集合，而程序要运行必须是加载到内存里的，但是物理内存就那么大，如何能保证很多个程序都装载进去呢？这里就引进了虚拟内存的概念，虚拟内存基本思想就是，给每个程序都分配一个4G的虚拟的内存（32位机器），但这部分内存占用的不是物理内存，而是磁盘空间。</p><p>在这4G的虚拟内存空间中，又分为了内核空间和用户空间，操作系统运行在内核空间，用户程序运行在用户空间。</p><p><img src="11.jpg" alt="11" /></p><h4 id="进程切换">1.2. 进程切换</h4><p>从一个进程切换到另一个进程会经历如下的变化：</p><ul><li>保存当前进程的上下文信息</li><li>更新当前PCB信息，并把PCB移入阻塞或就绪队列</li><li>选择另一个进程执行，并更新它的PCB信息</li><li>载入进程的上下文信息</li></ul><p><strong>什么是上下文信息？</strong></p><p>CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境。</p><p><strong>什么是PCB？</strong></p><p>进程控制块（process control block）存放进程的管理和控制信息的数据结构称为进程控制块，是进程存在的唯一标志、是进程管理和控制的最重要的数据结构</p><p><strong>进程上下文切换跟系统调用又有什么区别呢？</strong></p><p>进程是由内核来管理和调度的，进程的切换只能发生在内核态。 在linux中系统调用是用户空间访问内核的唯一手段</p><h4 id="进程阻塞">1.3. 进程阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程(获得CPU)，才可能将其转为阻塞状态。</p><h3 id="io模式">2. IO模式</h3><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p><p>所以说，当一个read操作发生时，它会经历两个阶段：</p><ol type="1"><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ol><p><strong>缓存 I/O 的缺点：</strong>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h4 id="阻塞-ioblocking-io">2.1. 阻塞 I/O（blocking IO）</h4><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p><p><img src="1593755892-55c466c2b5fc5_articlex.png" alt="1593755892-55c466c2b5fc5_articlex" /></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><blockquote><p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p></blockquote><h4 id="非阻塞-iononblocking-io">2.2. 非阻塞 I/O（nonblocking IO）</h4><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p><p><img src="1505222224-55c466dda9803_articlex.png" alt="1505222224-55c466dda9803_articlex" /></p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><blockquote><p>所以，nonblocking IO的特点是用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p></blockquote><h4 id="io-多路复用-io-multiplexing">2.3. I/O 多路复用（ IO multiplexing）</h4><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p><p><img src="1903235121-55c466eb17665_articlex.png" alt="1903235121-55c466eb17665_articlex" /></p><p><code>当用户进程调用了select，那么整个进程会被block</code>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><blockquote><p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p></blockquote><p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p><p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h4 id="异步-ioasynchronous-io">2.4. 异步 I/O（asynchronous IO）</h4><p><img src="1311869885-55c466fac00ba_articlex.png" alt="1311869885-55c466fac00ba_articlex" /></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性之智能指针</title>
      <link href="/posts/2599753973/"/>
      <url>/posts/2599753973/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为什么C++中的原生指针那么的不讨人喜欢呢？</p><ul><li><p>从它的声明你看不出他指向的是单一的对象还是一个数组</p></li><li><p>使用完了指针，你不知道要使用delete还是析构函数</p></li><li><p>当你知道了要用delete的时候，又不知道应该是delete还是delete[]</p></li><li><p>最后，你终于确定指针指向的内容了。但是你又不知道，前面有没有销毁。因为销毁代码只能执行一次。</p></li><li><p>目前，没有方法来确定指针是否是悬挂指针 (即一个指针不再拥有指向的内容，也就是说内容被销毁啦)</p><p>原生指针虽然是一个强大的工具，但是稍有不慎，这个工具就会反噬你！</p></li></ul></blockquote><span id="more"></span><h3 id="什么是智能指针">1. 什么是智能指针</h3><p>终于，智能指针出现了，智能指针表现起来很像原生指针，它相当于是原生指针的一层再包装，但是规避了许多使用原生指针带来的问题。</p><p>智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p><p>所以，我们应该尽量使用智能指针，它几乎做到了原生指针能做到的所有功能，却很少给你犯错的机会。</p><p>c++11标准中规定了3个智能指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr</span><br><span class="line">std::shared_ptr</span><br><span class="line">std::weak_ptr</span><br></pre></td></tr></table></figure><p>它们都可以用来辅助管理动态分配对象的生命周期，即确保这些对象在正确的时间以及发生异常时，用正确的方式被回收，确保不会产生内存泄漏。</p><h3 id="stdunique_ptr">2. std::unique_ptr</h3><p>当你要使用一个指针的时候，首先应该想到的就是 <code>std::unique_ptr</code> ，因为它和原生指针无论是大小还是速度上都相同。</p><p><code>std::unique_ptr</code> 实现了独占的思想，一个非空的 <code>std::unique_ptr</code> 永远拥有它指向的对象，并且无法被拷贝。因为，如果允许拷贝，那么就有两个 <code>std::unique_ptr</code> 指向相同的地方，每个指针都认为自己拥有销毁该对象的权利。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> ptr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">// ...执行一个会抛出异常的操作</span></span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码由于操作发生了异常，导致最后的delete并没有被执行。在C++98中，我们会使用非常笨重的try-catch来解决，但是使用智能指针就可以避免这样的问题。因为对象退出作用域的时候，智能指针将自动调用析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">  <span class="comment">// ...执行一个会抛出异常的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，释放资源由delete来完成，也可以指定自定义的析构函数来替代。但是会增大开销。</p><p>因为 <code>std::unique_ptr</code> 不可被复制，但是C++11中提供了移动语义 (move操作)，可以转移对象的所有权！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p));    <span class="comment">// 使用移动语义</span></span><br></pre></td></tr></table></figure><h3 id="stdshared_ptr">3. std::shared_ptr</h3><p>当我们要让几个指针共同占有一个对象的时候， <code>std::unique_ptr</code> 就无法满足我们的需求了，这个时候另一个智能指针 <code>std::shared_ptr</code> 就应运而生啦，一个通过 <code>std::shared_ptr</code> 访问的对象被指向它的指针共享所有权。</p><p>每个 <code>std::shared_ptr</code> 关联一个计数器，它记录着有多少个 <code>std::shared_ptr</code> 指向了该资源。如果这个计数器变为了0，就证明没有指针指向它了，所以需要释放掉。</p><p>由于引用计数的存在，对性能会产生一定的影响：</p><ul><li><code>std::shared_ptr</code> 的大小是原生指针的两倍，因为它们内部需要包含一个引用计数</li><li>引用计数的内存是动态分配的</li><li>引用计数的增加和减少操作都必须是原子的（线程安全的），因为可能工作在多线程环境下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p2 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>); <span class="comment">// wrong, no implicit constructor</span></span><br></pre></td></tr></table></figure><p>不能将一个new表达式返回的指针赋值给shared_ptr。</p><p>最稳妥的方式，就是使用 <code>make_shared</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1 = make_shared&lt;string&gt;(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="stdweak_ptr">4. std::weak_ptr</h3><p><code>std::weak_ptr</code> 是为了配合 <code>std::shared_ptr</code> 而引入的一种智能指针，将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>shared_ptr</code>的引用计数。不论是否有<code>weak_ptr</code>指向，一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放。从这个角度看，<code>weak_ptr</code>更像是<code>shared_ptr</code>的一个助手而不是智能指针。</p><p>当我们创建一个<code>weak_ptr</code>时，需要用一个<code>shared_ptr</code>实例来初始化<code>weak_ptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br></pre></td></tr></table></figure><p>你可能有这样的疑问，如果<code>shared_ptr</code>指向的东西被释放掉了，那<code>weak_ptr</code>怎么办呢？</p><p>C++中为<code>weak_ptr</code>设计了一个lock函数，如果<code>weak_ptr</code>是悬挂的状态 (即shared_ptr被释放掉了) ，lock会返回null值，否则返回它所绑定的<code>shared_ptr</code>。</p><p><strong>weak_ptr到底有啥用？</strong></p><ul><li><p>完成一个带缓存的工厂函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">const</span> Widget&gt; <span class="title">fastLoadWidget</span><span class="params">(WidgetId id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> std::unordered_map&lt;WidgetID, std::weak_ptr&lt;<span class="keyword">const</span> Widget&gt;&gt; cache;</span><br><span class="line"><span class="keyword">auto</span> objPtr = cache[id].<span class="built_in">lock</span>();    <span class="comment">//objPtr是std::shared_ptr类型</span></span><br><span class="line">                                   <span class="comment">//指向了被缓存的对象(如果对象不在缓存中则是null)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!objPtr)&#123;</span><br><span class="line">objPtr = <span class="built_in">loadWidget</span>(id);</span><br><span class="line">cache[id] = objPtr;</span><br><span class="line">&#125; <span class="comment">//如果不在缓存中，载入并且缓存它</span></span><br><span class="line"><span class="keyword">return</span> objPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要这么写这个函数呢？假如fastLoadWidget这个函数每调用一次，都要进行一次磁盘的IO操作。为了提高效率，我们要使用一个cache来记录最近被使用过的widget。自然你会想到使用Hash表，但是如果Hash的对象自然不能是<code>shared_ptr</code>，因为它被拷贝之后，在cache中永远不会被销毁。</p><p>这个时候，<code>weak_ptr</code>就派上用场了，因为它关联的<code>shared_ptr</code>如果被销毁了，它自然就被悬挂了。</p></li><li><p>解决环型问题</p></li></ul><p><img src="image-20190512223733512.png" alt="image-20190512223733512" /></p><p><img src="image-20190512225743894.png" alt="image-20190512225743894" /></p><p>有这样一个数据结构，包含A，B和C。A和C共享B的所有权，它们各自包含了一个<code>std::shared_ptr</code>指向B。</p><p>这个时候，如果要让B拥有反向指针指向A，那么指针应该是什么类型？</p><ol type="a"><li><p>一个原生指针：如果A被析构了，但是C会继续指向B，B指向A的指针就处于悬挂状态了。但是B对此毫不知情，假如B继续使用这个悬挂指针，就会引发异常。</p></li><li><p>一个<strong>std::shared_ptr</strong>：这样A和B会形成环，A和B中shared_ptr的计数都是1，永远无法被回收。</p></li><li><p>一个<strong>std::weak_ptr</strong>：最优解，如果A被回收，B指向A的指针会被悬挂，B也有能力检测到这一状态。</p></li></ol><h3 id="stdauto_ptr">5. std::auto_ptr</h3><ul><li>auto_ptr不能共享所有权，即不要让两个auto_ptr指向同一个对象。</li><li>auto_ptr不能指向数组，因为auto_ptr在析构的时候只是调用delete,而数组应该要调用delete[]。</li><li>auto_ptr只是一种简单的智能指针，如有特殊需求，需要使用其他智能指针，比如share_ptr。</li><li>auto_ptr不能作为容器对象，STL容器中的元素经常要支持拷贝，赋值等操作，在这过程中auto_ptr会传递所有权。</li></ul><p>尽量避免使用<code>std::auto_ptr</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性之右值引用</title>
      <link href="/posts/881195839/"/>
      <url>/posts/881195839/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C++中所有的值都必然属于左值、右值二者之一。简单讲，如果能对表达式进行取地址操作，那么它就是一个左值，否则就是一个右值。</p><p>左值：可以出现在等号的左边或右边 右值：只能出现在等号的右边，因为声明结束后就会被销毁。</p></blockquote><span id="more"></span><h3 id="右值引用">1. 右值引用</h3><p>右值引用如何表示呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;    <span class="comment">// 这里i是一个左值，0是一个右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;j = i;   <span class="comment">// 一个左值引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;k = <span class="number">0</span>;  <span class="comment">// 一个右值引用</span></span><br></pre></td></tr></table></figure><p>我们学习引用的时候，知道 j 其实就是 i 的一个别名，同理 k 也是 0 的一个别名！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">readFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; retv;</span><br><span class="line">  … <span class="comment">// fill retv</span></span><br><span class="line">  <span class="keyword">return</span> retv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = <span class="built_in">readFile</span>();</span><br></pre></td></tr></table></figure><p>我们再来看一下上面的代码，首先v是一个左值，readFile()会产生一个没有名字的临时变量temp (右值)。上面的代码的流程为：</p><blockquote><p>构造retv <span class="math inline">\(\to\)</span> 传递给临时变量temp <span class="math inline">\(\to\)</span> 传递给变量v</p></blockquote><p>retv传递给temp后，就烟消云散了；temp传递给v之后就烟消云散了；一次拷贝的开销是很大的，然而上面的代码存在了两次毫无意义的拷贝。所以，你能想象早期的C++程序员忍受了多么大的痛苦么。</p><p>好在，后来各家的编译器都对上面的过程进行了优化。但是治标不治本，最后还要靠C++11的右值和移动语义。</p><h3 id="移动语义">2. 移动语义</h3><p>简单来说解决的是各种情形下<strong>对象的资源所有权转移</strong>的问题。</p><p>C++通过拷贝构造函数和拷贝赋值操作符为类设计了<strong>拷贝/复制</strong>的概念，但为了实现对资源的<strong>移动</strong>操作，调用者必须使用先复制、再析构的方式。</p><p>我们为什么不能直接<strong>移动</strong>资源呢？首先，我们要规定什么样的资源可以被移动。</p><p><strong>右值中的数据可以被安全移走</strong>这一特性使得右值被用来表达移动语义。</p><p>那么，如何区分拷贝和移动呢？</p><p>C++对每个类增加两个函数：移动构造函数和移动赋值构造函数。编译器根据参数的不同选择不同的构造函数。</p><ul><li>拷贝构造函数的参数为：左值引用 <code>const T&amp; str</code></li><li>移动构造函数的参数为：右值引用 <code>T&amp;&amp; str</code></li></ul><p>移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是"偷"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为<code>nullptr</code>，这一步很重要，如果不将别人的指针修改为空，那么临时对象析构的时候就会释放掉这个资源，"偷"也白偷了。</p><p>对于一个左值，肯定是调用拷贝构造函数了，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？C++11为了解决这个问题，提供了<code>std::move()</code>方法来将左值转换为右值。</p><p>最初的例子的完美解决方案：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">readFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; retv;</span><br><span class="line">  … <span class="comment">// fill retv</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(retv); <span class="comment">// move retv out</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = <span class="built_in">readFile</span>();</span><br></pre></td></tr></table></figure><h3 id="通用引用">3. 通用引用</h3><p>当右值引用和模板结合的时候，就复杂了。<code>T&amp;&amp;</code>并不一定表示右值引用，它可能是个左值引用又可能是个右值引用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( T&amp;&amp; param)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);  <span class="comment">//10是右值</span></span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">//x是左值</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：只有当<strong>发生自动类型推断</strong>时（如函数模板的类型自动推导，或auto关键字），<code>&amp;&amp;</code>才是一个<code>universal references</code>。</p><h3 id="完美转发">4. 完美转发</h3><p>所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;左值：&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;右值：&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myforward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123; <span class="built_in">process</span>(i); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">process</span>(a);        <span class="comment">// 左值：0</span></span><br><span class="line"><span class="built_in">process</span>(<span class="number">1</span>);        <span class="comment">// 右值：1</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">move</span>(a));  <span class="comment">// 右值：0</span></span><br><span class="line"><span class="comment">// 转发</span></span><br><span class="line"><span class="built_in">myforward</span>(<span class="number">1</span>);        <span class="comment">// 左值：0</span></span><br><span class="line"><span class="built_in">myforward</span>(<span class="built_in">move</span>(a));  <span class="comment">// 左值：1</span></span><br></pre></td></tr></table></figure><p>我们可以看到，转发都失败了。这是因为他们传递到了myforward中之后，变成了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; i = <span class="built_in">move</span>(a);</span><br></pre></td></tr></table></figure><p>虽然 1 和 move(a) 都是右值，但是 i 是一个右值的引用，i 本身的数据类型是一个左值，因为我们可以对 i 取地址，但是不能对 1 取地址。</p><p>所以，完美的转发应该是使用<code>通用引用</code>和<code>std::forward</code>合作实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里利用了universal references，如果写T&amp;,就不支持传入右值，而写T&amp;&amp;，既能支持左值，又能支持右值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perfectForward</span><span class="params">(T &amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RunCode</span>(forward&lt;T&gt; (t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以最终还是要看<code>T</code>被推导成什么类型，如果<code>T</code>被推导成了<code>string</code>，那么<code>T&amp;&amp;</code>就是<code>string&amp;&amp;</code>，是个右值引用，如果<code>T</code>被推导为<code>string&amp;</code>，就会发生类似<code>string&amp; &amp;&amp;</code>的情况，对于这种情况，<code>c++11</code>增加了引用折叠的规则，总结如下：</p><ol type="1"><li>所有的右值引用叠加到右值引用上仍然使一个右值引用。</li><li>所有的其他引用类型之间的叠加都将变成左值引用。</li></ol><p>如上面的<code>T&amp; &amp;&amp;</code>其实就被折叠成了个<code>string &amp;</code>，是一个左值引用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11新特性之类型推导</title>
      <link href="/posts/3478694804/"/>
      <url>/posts/3478694804/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C++11在类型推导方面新增加了两个规则：auto和decltype，可以使我们的开发更流畅，不用耗费精力去想变量的类型和它的拼写。也使得我们日后修改变量的类型变得高效。</p></blockquote><span id="more"></span><h3 id="理解模板类型推导">1. 理解模板类型推导</h3><p>C++的模板对于类型推导来说，在通常情况推导出的类型和我们期望的是一致的，然而事情并不是总是这样如此美妙。例如下面这个例子:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(ParamType param)</span></span>;</span><br></pre></td></tr></table></figure><p>调用上面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(expr);                    <span class="comment">// call f with some expression</span></span><br></pre></td></tr></table></figure><p>在编译的时候，编译器对 <code>expr</code> 需要推导出两个类型：一个是 <code>T</code> ，另一个是 <code>ParamType</code>。因为<code>ParamType</code> 通过包裹一些类型的修饰，比如下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;     <span class="comment">// ParamType is const T&amp;</span></span><br></pre></td></tr></table></figure><p>我们有如下的调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">f</span>(x);                       <span class="comment">// call f with an int</span></span><br></pre></td></tr></table></figure><p><code>T</code> 被推导成为<code>int</code>，<code>ParamType</code>被推导成为<code>const int&amp;</code>。</p><p>我们都很希望<code>T</code>的类型和传递进来的参数，也就是<code>expr</code>的类型是一致的，在上面的例子中<code>x</code>是一个<code>int</code>，<code>T</code>也被推导成<code>int</code>，<font color="red">但是并不是所有的情况都是这样的</font>。不仅仅是<code>expr</code>的类型影响<code>T</code>，<code>ParamType</code>也对<code>T</code>的类型推导有影响。比如，下面的三种情况：</p><h4 id="paramtype是一个引用或一个指针">1.1. ParamType是一个引用或一个指针</h4><p>最简单的情况是当<code>ParamType</code>是一个引用类型或者一个指针，在这种情况下，类型推导按照如下规则：</p><ol type="1"><li>如果传入的类型，即<code>expr</code>的类型是引用或指针，忽略引用或指针</li><li>然后对比<code>expr</code>和<code>ParamType</code>的类型去判断<code>T</code>的类型</li></ol><p>如果我们的模板是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;       <span class="comment">// param is a reference</span></span><br></pre></td></tr></table></figure><p>变量声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;             <span class="comment">// x is an int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;       <span class="comment">// cx is a const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;      <span class="comment">// rx is a reference to x as a const int</span></span><br></pre></td></tr></table></figure><p>类型推导的结果为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(x);                   <span class="comment">// T is int, param&#x27;s type is int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                  <span class="comment">// T is const int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                  <span class="comment">// T is const int, param&#x27;s type is const int&amp;</span></span><br></pre></td></tr></table></figure><p>注意第三个例子中，尽管<code>rx</code>的类型是<code>const int&amp;</code>，但是<code>T</code>仍然被推导成了<code>const int</code>，因为规则1。</p><p>如果我们把<code>f</code>的参数类型(ParamType)从<code>T&amp;</code>改为<code>const T&amp;</code>，会发生一点微小的改变，但并没有什么特别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;  <span class="comment">// param is now a ref-to-const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;              <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;        <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;       <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                    <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                   <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                   <span class="comment">// T is int, param&#x27;s type is const int&amp;</span></span><br></pre></td></tr></table></figure><p>注意到，由于<code>ParamType</code>的类型是const的，那么在<code>T</code>的类型推导过程中，就没有必要保留const属性了。</p><p>指针的情况也是如此：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T* param)</span></span>;        <span class="comment">// param is now a pointer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;              <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *px = &amp;x;      <span class="comment">// px is a ptr to x as a const int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(&amp;x);                   <span class="comment">// T is int, param&#x27;s type is int*</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(px);                   <span class="comment">// T is const int, param&#x27;s type is const int*</span></span><br></pre></td></tr></table></figure><h4 id="paramtype是通用的引用">1.2. ParamType是通用的引用</h4><p>通用的引用就是指：右值引用（<code>T&amp;&amp;</code>），当我们传入一个左值参数进去的时候，情况会有些不同：</p><ol type="1"><li>如果<code>expr</code>是一个左值，<code>T</code>和<code>ParamType</code>都会被推导成左值引用。这是在模板类型推导中<code>T</code>被推导成为引用的唯一情况，另外，尽管<code>ParamType</code>利用右值引用的语法来进行推导，但是最终结果是左值引用。</li><li>如果<code>expr</code>是一个右值，那么久执行1.1中的法则。</li></ol><p>下面来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;       <span class="comment">// param is now a universal reference</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;              <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;        <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;       <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                    <span class="comment">// x is lvalue, so T is int&amp;,</span></span><br><span class="line">                         <span class="comment">// param&#x27;s type is also int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);                   <span class="comment">// cx is lvalue, so T is const int&amp;,</span></span><br><span class="line">                         <span class="comment">// param&#x27;s type is also const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);                   <span class="comment">// rx is lvalue, so T is const int&amp;,</span></span><br><span class="line">                         <span class="comment">// param&#x27;s type is also const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">27</span>);                   <span class="comment">// 27 is rvalue, so T is int,</span></span><br><span class="line">                         <span class="comment">// param&#x27;s type is therefore int&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>Todo：具体的解释，之后补充</p><h4 id="paramtype既不是引用也不是指针">1.3. ParamType既不是引用也不是指针</h4><p>这种情况是按值传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;         <span class="comment">// param is now passed by value</span></span><br></pre></td></tr></table></figure><p>这就意味着，<code>param</code>是传进来的参数的一份拷贝，一个全新的对象。所以按照如下法则进行类型推导：</p><ol type="1"><li>和之前一样，如果<code>expr</code>的类型是一个引用，将会忽略引用。</li><li>如果<code>expr</code>是一个<code>const</code>的，也会忽略<code>const</code>。如果是<code>volatile</code>，同样忽略。</li></ol><p>下面来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">27</span>;          <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;    <span class="comment">// as before</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;   <span class="comment">// as before</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(x);                <span class="comment">// T&#x27;s and param&#x27;s types are both int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(cx);               <span class="comment">// T&#x27;s and param&#x27;s types are again both int</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(rx);               <span class="comment">// T&#x27;s and param&#x27;s types are still both int</span></span><br></pre></td></tr></table></figure><p>为什么const会被忽略呢？因为param是一个新的对象，一份对cx或rx的拷贝。换句话说，我们对param的修改和cx和rx一点关系都没有，随意就可以对const说再见了。</p><p>下面再来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;         <span class="comment">// param is still passed by value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> ptr =  <span class="string">&quot;Fun with pointers&quot;</span>;  <span class="comment">// ptr is const pointer to const object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(ptr);                  <span class="comment">// pass arg of type const char * const</span></span><br></pre></td></tr></table></figure><p><code>const char* const ptr</code>表示的含义是一个不可被修改的指针（右面的<code>const</code>），指向了一个不可被修改的字符串(左面的<code>const</code>)。在传递的过程中，<code>ptr</code>的内存被拷贝给了<code>param</code>，ptr指向的字符串的<code>const</code>特性被保留，但是<code>ptr</code>自己本身的<code>const</code>特性被忽略。，这样<code>T</code>推导出来的类型就是<code>const char*</code>。</p><h4 id="数组参数">1.4. 数组参数</h4><p>我们都知道数组等于指向第一个元素的指针，代码常常如此：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[] = <span class="string">&quot;J. P. Briggs&quot;</span>;  <span class="comment">// name&#x27;s type is const char[13]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ptrToName = name;       <span class="comment">// array decays to pointer</span></span><br></pre></td></tr></table></figure><p>但是，如果把一个数组按值传递到一个模板中会发生什么呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;      <span class="comment">// template with by-value parameter</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name);              <span class="comment">// what types are deduced for T and param?</span></span><br></pre></td></tr></table></figure><p>因为数组参数声明会被当成指针参数，<code>T</code>被推导成为<code>const char*</code>。</p><p>但是来看一个特例，尽管函数的参数不能定义真正数组（就是<code>char name[13]</code>不能作为参数！），但是我们可以使用数组的引用来作为参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp; param)</span></span>;      <span class="comment">// template with by-reference parameter</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(name);               <span class="comment">// pass array to f</span></span><br></pre></td></tr></table></figure><p>这样，<code>T</code>被推导为<code>const char[13]</code>， <code>ParamType</code>推导为<code>const char(&amp;) [13]</code>。</p><h4 id="函数参数">1.5. 函数参数</h4><p>数组并不是C++中唯一可以退化成指针的东西，函数同样会被退化成指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;   <span class="comment">// someFunc is a function;</span></span><br><span class="line">                              <span class="comment">// type is void(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T param)</span></span>;             <span class="comment">// in f1, param passed by value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span></span>;            <span class="comment">// in f2, param passed by ref</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>(someFunc);                 <span class="comment">// param deduced as ptr-to-func;</span></span><br><span class="line">                              <span class="comment">// type is void (*)(int, double)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f2</span>(someFunc);                 <span class="comment">// param deduced as ref-to-func;</span></span><br><span class="line">                              <span class="comment">// type is void (&amp;)(int, double)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++运行时类型信息</title>
      <link href="/posts/3887007265/"/>
      <url>/posts/3887007265/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Runtime Type Information：运行时类型信息，指的是在程序运行时保存其对象的类型信息的行为。在C++中主要体现在dynamic_cast 和 typeid 中。</p><p>C++语言提供了dynamic_cast 和 typeid两种运算符，typeid用于在运行时识别类型信息，dynamic_cast具有运行时类型识别和类型转换匹配2个功能。</p><p>在类的虚表的前面存放RTTI数据块的指针。因此，类必须有虚函数，才会有RTTI。</p></blockquote><span id="more"></span><h3 id="typeid函数">1. Typeid函数</h3><p>返回指针和引用所指的实际类型；</p><p>我们来看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base:: I am a person.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived:: I am a teacher.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *p = <span class="keyword">new</span> <span class="built_in">Person</span>();</span><br><span class="line">Person he;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(p).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">// class Person*</span></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(he).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// class Person</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *pt = <span class="keyword">new</span> <span class="built_in">Teacher</span>();  <span class="comment">// 向上转型(upcast)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(pt).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">// class Person*</span></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(*pt).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// class Person</span></span><br></pre></td></tr></table></figure><p>我们可以看到按照定义：pt是一个Person类型的指针，指向的是一个Teacher对象。为什么两个输出的都是Person呢？这是因为，在C++中如果不存在虚函数，那么类型的确定是在编译期间的。也就是静态类型。</p><p>下面，我们使用虚函数，再来看一看结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virSay</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base(virtual):: I am a person.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derived(virtual):: I am a teacher.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person *pt = <span class="keyword">new</span> <span class="built_in">Teacher</span>();  <span class="comment">// 向上转型(upcast)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(pt).<span class="built_in">name</span>() &lt;&lt; endl;   <span class="comment">// class Person*</span></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(*pt).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">// class Teacher</span></span><br></pre></td></tr></table></figure><p>显然，结果就变成了我们所期望的结果。</p><h3 id="dynamic_cast">2. dynamic_cast</h3><p>将<font color='red'>基类类型的指针或引用</font>安全地转换为其<font color='red'>派生类类型的指针或引用</font>。</p><p>我们知道C++的多态性（运行时）是由虚函数实现的，对于多态性的对象，无法在程序编译阶段确定对象的类型。当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就有可能不知道基类指针到底指向的是哪个对象的情况，类型的确定要在运行时利用运行时类型标识做出。为了获得一个对象的类型可以使用typeid函数，该函数反回一个对type_info类对象的引用，要使用typeid必须使用头文件<typeinfo>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> &#123;</span>  <span class="comment">// parent class</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Fruit</span>() &#123;</span><br><span class="line">  &#125;  <span class="comment">// must be polymorphic to use runtime-checked dynamic-cast</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> :</span> <span class="keyword">public</span> Fruit &#123;&#125;;  <span class="comment">// child class</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The following is an implicit upcast:</span></span><br><span class="line">  Fruit* parent = <span class="keyword">new</span> <span class="built_in">Apple</span>();</span><br><span class="line">  <span class="comment">// The following is a downcast. Here, it works since the variable `parent` is</span></span><br><span class="line">  <span class="comment">// holding an instance of Apple:</span></span><br><span class="line">  Apple* child = <span class="keyword">dynamic_cast</span>&lt;Apple*&gt;(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们做向上转型 (upcast) 的时候，即将派生类的对象转换成基类，一定是安全的。</p><p>但是如果做向下转型 (downcast) 的时候，即将一个基类对象转换成派生类对象，不一定是安全的。</p><p>比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruit* parent = <span class="keyword">new</span> <span class="built_in">Apple</span>();</span><br><span class="line">Apple *child = <span class="keyword">dynamic_cast</span>&lt;Apple *&gt;(parent);</span><br></pre></td></tr></table></figure><p>这样做，是没有问题的，因为 parent 本身就指向了一个 Apple 对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fruit* parent = <span class="keyword">new</span> <span class="built_in">Banana</span>();</span><br><span class="line">Apple *child = <span class="keyword">dynamic_cast</span>&lt;Apple *&gt;(parent);</span><br></pre></td></tr></table></figure><p>但是，parent 可以指向任意的派生类，如果 parent 指向的是一个 Banana 对象，这时候就出现问题了呀，现实生活中，我们可以让香蕉变成苹果吗？</p><p>那么，dynamic_cast 是如何避免这种现象的呢？这就需要用到<strong>RTTI机制</strong>了，上面我们讲到了typeid可以在运行的时候返回相应具体的对象。</p><p>所以，只要保证 <code>typeid(*parent).name() == typeid(*child).name()</code> 就可以啦~</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++三大特性之多态</title>
      <link href="/posts/1851632770/"/>
      <url>/posts/1851632770/</url>
      
        <content type="html"><![CDATA[<blockquote><p>多态性可以简单的概括为 "一个接口，多种方法"，它是面向对象编程语言的核心。</p></blockquote><span id="more"></span><h3 id="什么是多态">1. 什么是多态</h3><p>在编程语言中，多态就意味着某些代码、操作或对象在不同的上下文中有不一样的作用。C++分为两种类型的多态</p><ul><li>编译时多态性 (静态多态)：通过重载函数实现</li><li>运行时多态性 (动态多态)：通过<font color='Magenta'>虚函数</font>实现</li></ul><p>我们定义如下几个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base:: I am a person.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virSay</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base(virtual):: I am a person.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived:: I am a student.&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">virSay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Derived(virtual):: I am a student.&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们执行如下命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student *s = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">  Person *p = s;</span><br><span class="line"></span><br><span class="line">  s-&gt;<span class="built_in">say</span>();</span><br><span class="line">  s-&gt;<span class="built_in">virSay</span>();</span><br><span class="line"></span><br><span class="line">  p-&gt;<span class="built_in">say</span>();</span><br><span class="line">  p-&gt;<span class="built_in">virSay</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到如下输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived:: I am a student.</span><br><span class="line"><span class="built_in">Derived</span>(<span class="keyword">virtual</span>):: I am a student.</span><br><span class="line"></span><br><span class="line">Base:: I am a person.</span><br><span class="line"><span class="built_in">Derived</span>(<span class="keyword">virtual</span>):: I am a student.</span><br></pre></td></tr></table></figure><p>我们可以看到Student对象的输出是正常的，但是我们将Student对象向上转换为Person的时候，它的非虚函数调用的是父类的函数。</p><blockquote><p>这里，有一个概念就是<font color='Magenta'>类的成员函数存储</font>的问题，设想一下每个类都包括数据和函数两个部分，如果同一个类定义了10个对象，那么我们就要为10个对象分配内存</p></blockquote><p><img src="image-20190511225136606.png" alt="image-20190511225136606" /></p><p>但是，每个对象的函数都是相同的，所以我们可不可以让这10个对象公用一份函数呢？答案当然是可以的，c++中将函数单独存储出去，当我们调用相应的函数的时候，一定是通过一个对象实例去调用的，每个对象实例都有一个this指针，所以不同的对象实例调用的时候，传入的是不同的this指针，this指针起到访问数据的作用。</p><p>所以，上面的代码 <code>p-&gt;say()</code> 之所以会输出：<code>Base:: I am a person.</code> 就是因为它的内存结果如下所示：</p><p><img src="image-20190511230102342.png" alt="image-20190511230102342" /></p><p>除了虚函数,决定调用哪一个函数的过程在编译期就已经完成了。每一个成员函数的第一个参数都应为this,这是编译器生成的。所有类成员函数和非成员函数代码存放在代码区。</p><p>静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区的，因而可以说它们都是属于类的，但是类为什么只能直接调用静态类成员函数，而非静态类成员函数(即使函数没有参数)只有类对象才能调用呢？</p><p>原因是类的非静态类成员函数其实都内含了一个指向类对象的指针型参数(即this指针)，因而只有类对象才能调用(此时this指针有实值)。</p><h3 id="虚函数">2. 虚函数</h3><p>虚函数的地址被存储一张叫做虚表的东西里，虚函数表的地址总是存在于对象实例中最前面的位置，其后依次是对象实例的成员。</p><p><img src="image-20190511230923674.png" alt="image-20190511230923674" /></p><p>虚函数的存储原理与成员函数是一致的，如果你对函数进行了重写，那么就会指向重写的函数地址，否则所有的对象共用相同的地址。</p><p>另外我们在使用虚函数的时候要注意：</p><ul><li><strong>静态函数不可以声明为虚函数 ：</strong>静态函数不属于任一实例，因此将其声明为虚函数也没有意义 。</li><li><strong>构造函数不可以声明为虚函数 ：</strong>除了 inline 之外，构造函数不允许使用其它任何关键字。构造函数是用来创建实例的，被创建的实例必须有明确的类型，因此构造函数不能是虚函数 。</li><li><strong>析构函数可以声明为虚函数：</strong>事实上，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数，因为我们可能也需要动态确定被销毁对象的实际类型 。</li></ul><h4 id="单继承只有一个父类">2.1. 单继承（只有一个父类）</h4><p>类的继承关系为：class Derived : public Base</p><p><img src="20150522023659996.png" alt="20150522023659996" /></p><p>若子类并无overwrite父类虚函数，而是声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后。</p><p>若子类overwrite父类虚函数，同样地将覆盖父类子物体中的虚函数表对应位置，而若子类声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针vptr，这与一般继承不同,在后面再讨论。</p><h4 id="多重继承多个父类">2.2. 多重继承（多个父类）</h4><p>类的继承关系如下：class Derived : public Base1, public Base2</p><p>在多继承中，子类含有多个父类的子对象，该往哪个父类的虚函数表扩展呢？</p><ul><li>子类的虚函数被放在声明的第一个基类的虚函数表中。</li><li>overwrite时，所有基类的print()函数都被子类的print()函数覆盖。</li><li>内存布局中，父类按照其声明顺序排列。</li></ul><p><img src="20150522023810465.png" alt="20150522023810465" /></p><h4 id="重复继承继承的多个父类中其父类有相同的超类">2.3. 重复继承（继承的多个父类中其父类有相同的超类）</h4><p>类的继承关系如下：</p><p>class Base1 : public Base</p><p>class Base2: public Base</p><p>class Derived : public Base1, public Base2</p><p><img src="610439-20151025200532099-858573066.png" alt="610439-20151025200532099-858573066" /></p><p>这就是菱形继承，派生类对象中拥有多份基类实例。</p><p><img src="20150522023800275.png" alt="20150522023800275" /></p><p>一个属于来源B1类，一个来源B2类。这样不仅增大了空间，更重要的是引起了程序歧义。</p><h4 id="虚继承">2.4. 虚继承</h4><p>虚继承解决了菱形继承中最派生类拥有多个间接父类实例的情况。虚继承的派生类的内存布局与普通继承很多不同，主要体现在：</p><p>虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个虚函数指针（vptr）以及一张虚函数表。该vptr位于对象内存最前面。</p><h3 id="纯虚函数">3. 纯虚函数</h3><p>在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但<strong>动物本身生成对象明显不合常理</strong>。而针对每种动物的方法又有所不同，此时需要使用多态特性，也就需要在基类中定义虚函数。</p><p>纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习训练方法对比</title>
      <link href="/posts/835479121/"/>
      <url>/posts/835479121/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们了解的反向传播算法之后，那么每一次的梯度更新就尤为重要，常见梯度下降方法有SGD、BGD。以及针对梯度下降的各种优化算法Momentum、Adam，RMSProp等。</p></blockquote><span id="more"></span><p>先来了解下Loss function和Cost Function的区别</p><ul><li><p>Loss function <span class="math display">\[L(\hat{y}, y) = -[y\ log\hat{y} + (1-y)\ log(1 - \hat{y})]\]</span> 衡量了<strong>单个训练样本</strong>上的表现</p></li><li><p>Cost function <span class="math display">\[J(W, b) = \frac{1}{m} \sum_{i=1}^{m} L(\hat{y}^{(i)}, y^{(i)})\]</span> 衡量的是在<strong>全体训练样本</strong>上的表现</p></li></ul><h3 id="批量梯度下降bgd">1. 批量梯度下降(BGD)</h3><p><strong>参数更新时间</strong>：输入完全部数据</p><p>每次输入X中的一列数据r，计算出Loss：<span class="math inline">\(J_r(W, b)\)</span></p><p>输入完全部 <span class="math inline">\(m\)</span> 列数据之后，计算整个批次的权重<strong>更新量</strong> <span class="math display">\[\begin{aligned}\Delta W^{(l)} &amp;= \frac{1}{m} \sum_{r=1}^{m} \frac{\partial J_r(W, b)}{\partial W^{(l)}} \\\Delta b^{(l)} &amp;= \frac{1}{m} \sum_{r=1}^{m} \frac{\partial J_r(W, b)}{\partial b^{(l)}}\end{aligned}\]</span> 然后进行参数更新： <span class="math display">\[\begin{aligned}\Delta W^{(l)} &amp;= W^{(l)} - \alpha \Delta W^{(l)}\\\Delta b^{(l)} &amp;= b^{(l)} - \alpha \Delta b^{(l)}\end{aligned}\]</span> 上面的式子是针对第 <span class="math inline">\(l\)</span> 层的参数更新，其它层同理。</p><blockquote><p>由于我们每进行一次参数更新需要计算整体训练数据的梯度，批量梯度下降会变得很慢并且一遇到内存吃不下数据就挂。</p></blockquote><h3 id="随机梯度下降sgd">2. 随机梯度下降(SGD)</h3><p><strong>参数更新时间</strong>：输入一个数据</p><p>每次随机选择X中的一列数据r，计算出Loss：<span class="math inline">\(J_r(W, b)\)</span></p><p>计算该列数据的权重更新： <span class="math display">\[\begin{aligned}\Delta W^{(l)} &amp;= \frac{\partial J_r(W, b)}{\partial W^{(l)}} \\\Delta b^{(l)} &amp;= \frac{\partial J_r(W, b)}{\partial b^{(l)}}\end{aligned}\]</span> 进行参数更新： <span class="math display">\[\begin{aligned}\Delta W^{(l)} &amp;= W^{(l)} - \alpha \Delta W^{(l)}\\\Delta b^{(l)} &amp;= b^{(l)} - \alpha \Delta b^{(l)}\end{aligned}\]</span></p><blockquote><p>随机梯度下降是通过每个样本来迭代更新一次，如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</p></blockquote><p><img src="20160324223105074.png" alt="20160324223105074" /></p><h3 id="小批量梯度下降mini-batch-gd">3. 小批量梯度下降(Mini-Batch GD)</h3><p><strong>参数更新时间</strong>：输入完一个Mini-Batch</p><p>将样本集 <span class="math inline">\(X\)</span> 划分为多个包含<code>batch_size</code>个数据的集合，设其中一个集合是 <span class="math inline">\(X_b\)</span></p><p>每次输入 <span class="math inline">\(X_b\)</span> 中的一列数据 <span class="math inline">\(r\)</span> 并计算Loss：<span class="math inline">\(J_r(W, b)\)</span></p><p>输入完一个Mini-Batch后，计算权重更新量： <span class="math display">\[\begin{aligned}\Delta W^{(l)} &amp;= \frac{1}{m_b} \sum_{r=1}^{m_b} \frac{\partial J_r(W, b)}{\partial W^{(l)}} \\\Delta b^{(l)} &amp;= \frac{1}{m_b} \sum_{r=1}^{m_b} \frac{\partial J_r(W, b)}{\partial b^{(l)}}\end{aligned}\]</span> 进行参数更新： <span class="math display">\[\begin{aligned}\Delta W^{(l)} &amp;= W^{(l)} - \alpha \Delta W^{(l)}\\\Delta b^{(l)} &amp;= b^{(l)} - \alpha \Delta b^{(l)}\end{aligned}\]</span></p><blockquote><p>集成了上述两种方法的优点：算法的训练过程比较快，而且也要保证最终参数训练的准确率。</p></blockquote><h3 id="小批量随机梯度下降mini-batch-sgd">4. 小批量随机梯度下降(Mini-Batch SGD)</h3><p><strong>参数更新时间</strong>：输入完一个Mini-Batch</p><p>每次随机选择 <span class="math inline">\(X\)</span> 中的一个数据 <span class="math inline">\(r\)</span> 并计算Loss：<span class="math inline">\(J_r(W, b)\)</span></p><p>循环 <span class="math inline">\(m_b\)</span> 次，即<code>batch_size</code>次后，计算权重更新量： <span class="math display">\[\begin{aligned}\Delta W^{(l)} &amp;= \frac{1}{m_b} \sum_{r=1}^{m_b} \frac{\partial J_r(W, b)}{\partial W^{(l)}} \\\Delta b^{(l)} &amp;= \frac{1}{m_b} \sum_{r=1}^{m_b} \frac{\partial J_r(W, b)}{\partial b^{(l)}}\end{aligned}\]</span> 进行参数更新： <span class="math display">\[\begin{aligned}\Delta W^{(l)} &amp;= W^{(l)} - \alpha \Delta W^{(l)}\\\Delta b^{(l)} &amp;= b^{(l)} - \alpha \Delta b^{(l)}\end{aligned}\]</span></p><blockquote><p>该方法与3不同的地方在于，<strong>不需要划分Mini-Batch</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习反向传播算法</title>
      <link href="/posts/4005678680/"/>
      <url>/posts/4005678680/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我们使用前馈神经网络接受输入 <span class="math inline">\(x\)</span> 并产生输出 <span class="math inline">\(\hat{y}\)</span> 时，信息通过网络向前流动。每一层网络都需要一个参数矩阵参数矩阵 <span class="math inline">\(W^{(l)}\)</span> 和偏置 <span class="math inline">\(b^{(l)}\)</span> 来计算出本层的真正输入 $ z^{(l)} $，然后经过激活函数得到 <span class="math inline">\(a^{(l)}\)</span>(相当于之前的 <span class="math inline">\(x\)</span> )作为下一层的输入。那么当信息在网络中流动了一遍之后，我们该如何修改每一层的参数 <span class="math inline">\(W^{(l)}\)</span> 和 <span class="math inline">\(b^{(l)}\)</span> 呢？ 此时<strong>反向传播算法</strong>就应运而生了。</p></blockquote><span id="more"></span><h3 id="前向传播">1. 前向传播</h3><p>在进行正式的介绍时，我们先来对神经网络中的每个字母所代表的含义，进行一下梳理，只有明白了每个参数所代表的含义，才能更好的去理解算法本身。</p><p><img src="神经网络图.png" alt="神经网络图" /></p><blockquote><p><span class="math inline">\(X = [x_1, x_2, x_3]^T\)</span>，首先<span class="math inline">\(X\)</span>是一个列向量，每个元素对应图中的一个小圆点。<span class="math inline">\(X\)</span>是整个网络的输入！</p><p>$W^{(1)} <span class="math inline">\(,\)</span>W<sup>{(2)}<span class="math inline">\(,\)</span>W</sup>{(3)}$ 代表的是 <span class="math inline">\(l_1\)</span>, <span class="math inline">\(l_2\)</span>, <span class="math inline">\(l_3\)</span> 层的矩阵参数；<span class="math inline">\(b^{(1)}\)</span>, <span class="math inline">\(b^{(2)}\)</span>, <span class="math inline">\(b^{(3)}\)</span>代表的是偏置。</p><p><span class="math inline">\(W_{21}^{(1)}\)</span> 的上角标(1)表示第一层，下角标21表示的是第2个神经元对应 <span class="math inline">\(x_1\)</span> 的的参数。</p><p><span class="math inline">\(W_{12}^{(2)}\)</span> 表示的是第2层网络的第1个神经元的第2个输入。</p><p><span class="math inline">\(z_2^{(1)}\)</span> 表示第1层网络的第2个神经元的输入</p><p><span class="math inline">\(a_2^{(1)}\)</span> 表示第1层网络的第2个神经元经过激活函数的输出</p></blockquote><p>当我们知道了上面符号的含义之后，我们就会发现关键点是如何计算 <span class="math inline">\(Z\)</span> 的值 <span class="math display">\[\begin{aligned}z_1^{(1)} &amp;= w_{11}^{(1)}x_1 + w_{12}^{(1)}x_1 + w_{13}^{(1)}x_3 + b_1^{(1)} \qquad \qquada_1^{(1)} = f(z_1^{(1)}) \\z_2^{(1)} &amp;= w_{21}^{(1)}x_1 + w_{22}^{(1)}x_1 + w_{23}^{(1)}x_3 + b_2^{(1)} \qquad \qquada_2^{(1)} = f(z_2^{(1)}) \\z_3^{(1)} &amp;= w_{31}^{(1)}x_1 + w_{32}^{(1)}x_1 + w_{33}^{(1)}x_3 + b_3^{(1)} \qquad \qquada_3^{(1)} = f(z_3^{(1)}) \\\end{aligned}\]</span> 这么整齐的式子，简直就是为了矩阵而生的！ <span class="math display">\[\begin{aligned}z^{(1)} = \begin{bmatrix}   z_1^{(1)} \\   z_2^{(1)} \\   z_3^{(1)}\end{bmatrix} = \begin{bmatrix}   w_{11}^{(1)} &amp; w_{12}^{(1)} &amp; w_{13}^{(1)} \\   w_{21}^{(1)} &amp; w_{22}^{(1)} &amp; w_{23}^{(1)} \\   w_{31}^{(1)} &amp; w_{32}^{(1)} &amp; w_{33}^{(1)}\end{bmatrix}\begin{bmatrix}   x_1 \\   x_2 \\   x_3\end{bmatrix} +\begin{bmatrix}   b_1^{(1)} \\   b_2^{(1)} \\   b_3^{(1)}\end{bmatrix} = W^{(1)}X + b^{(1)}\end{aligned}\]</span> 然后，就有了 <span class="math display">\[\begin{aligned}z^{(2)} = \begin{bmatrix}   z_1^{(2)} \\   z_2^{(2)} \\\end{bmatrix} = \begin{bmatrix}   w_{11}^{(2)} &amp; w_{12}^{(2)} &amp; w_{13}^{(2)} \\   w_{21}^{(2)} &amp; w_{22}^{(2)} &amp; w_{23}^{(2)} \\\end{bmatrix}\begin{bmatrix}   a_1^{(1)} \\   a_2^{(1)} \\   a_3^{(1)}\end{bmatrix} +\begin{bmatrix}   b_1^{(2)} \\   b_2^{(2)} \\   b_3^{(2)}\end{bmatrix} = W^{(2)}a^{(1)} + b^{(2)}\end{aligned}\]</span> 即： <span class="math display">\[\begin{aligned}a^{(1)} &amp;= f(z^{(1)}) = f(W^{(1)}X + b^{(1)}) \\a^{(2)} &amp;= f(z^{(2)}) = f(W^{(2)}a^{(1)} + b^{(2)}) \\\end{aligned}\]</span> 总之， <span class="math display">\[z^{(l)} = W^{(l)}a^{(l-1)} + b^{(l)} \qquad \qquad \qquad a^{(l)} = f(z^{(l)})\]</span> 上面的公式总结为：输入的 <span class="math inline">\(x\)</span> 提供一个初始的向量，经过第 <span class="math inline">\(l\)</span> 层的参数矩阵 <span class="math inline">\(W^{(l)}\)</span> 和偏置 <span class="math inline">\(b^{(l)}\)</span> 计算得到了第 <span class="math inline">\(l\)</span> 层的输入 $Z^{(l)} $，然后 <span class="math inline">\(Z^{(l)}\)</span> 中的每个值都要经过激活函数 <span class="math inline">\(f(·)\)</span> 产生第 <span class="math inline">\(l\)</span> 层的输出，最后把输出与 <span class="math inline">\(W^{(l+1)}\)</span> 和 <span class="math inline">\(b^{(l+1)}\)</span> 计算得到第 <span class="math inline">\(l+1\)</span> 层的输入 <span class="math inline">\(Z^{(l+1)}\)</span>，然后再一次的经过激活函数 <span class="math inline">\(f(·)\)</span> 产生第 <span class="math inline">\(l+1\)</span>层的输出，如此循环往复的过程称作前向传播。</p><h3 id="反向传播">2. 反向传播</h3><p>每一轮需要更新的参数是 <span class="math inline">\(W^{(l)}\)</span> 和 <span class="math inline">\(b^{(l)}\)</span>，从数学的角度上面来说就是使用梯度下降法来求解。最暴力的解法就是针对每一个 <span class="math inline">\(w_{ji}^{(l)}\)</span> 求它的偏导，但是这种暴力的算法存在大量的重复计算过程，所以反向传播算法就应运而生。我们把上面那幅图中的标红的线路拿出来，单独的去看它。</p><p><img src="image-20190304205128762.png" alt="image-20190304205128762" /></p><p>注意：一定要理解这条线和上面图中的红线的对应关系</p><p>假如，我们要求 <span class="math inline">\(J(W, b)\)</span> 关于 <span class="math inline">\(w_{ji}^{(l)}\)</span> 的偏导，仔细观察上图<strong>蓝色部分</strong></p><blockquote><p><span class="math inline">\(w_{ji}^{(l)}\)</span> 首先变成了 <span class="math inline">\(z_j^{(l)}\)</span>，然后向后传播到 <span class="math inline">\(J(W, b)\)</span></p></blockquote><p>我们先不管它怎么传播过去的，针对 <span class="math inline">\(w_{ji}^{(l)}\)</span> 、 <span class="math inline">\(z_j^{(l)}\)</span> 和 <span class="math inline">\(J(W, b)\)</span> 它们三个的关系，我们来应用<strong>链式法则</strong>。</p><p>由前向传播过程可知：$ z_{j}^{(l)} = <em>{i = 1}<sup>{n_{l-1}}w_{ji}</sup>{(l)} a</em>{i}^{(l-1)} + b_{j}^{(l)} $ <span class="math display">\[\begin{aligned}\frac{\partial J(W,b)}{\partial w_{ji}^{(l)}} &amp;= \frac{\partial J(W,b)}{\partial z_j^{(l)}}\frac{\partial z_j^{(l)}}{\partial w_{ji}^{(l)}} = \frac{\partial J(W,b)}{\partial z_j^{(l)}} a_i^{(l-1)} \\\frac{\partial J(W,b)}{\partial b_{j}^{(l)}} &amp;= \frac{\partial J(W,b)}{\partial z_j^{(l)}}\frac{\partial z_j^{(l)}}{\partial b_{j}^{(l)}} = \frac{\partial J(W,b)}{\partial z_j^{(l)}}\end{aligned}\]</span> 所以，我们的任务变成了：如何求 <span class="math inline">\(\frac{\partial J(W,b)}{\partial z_j^{(l)}}\)</span> ，我们设 <span class="math display">\[\delta_j^{(l)} = \frac{\partial J(W,b)}{\partial z_j^{(l)}}\]</span> <img src="image-20190304215022966.png" alt="image-20190304215022966" /></p><p>继续观察上面的图，可以发现：<span class="math inline">\(z_j^{(l)} \to a_j^{(l)} \to z_k^{(l+1)}\)</span></p><p>又因为：$ z_k^{(l+1)} = _{j = 1}<sup>{n_{l}}w_{kj}</sup>{(l+1)} a_j^{(l)} + b_k^{(l+1)} $ ，另外我们需要注意 <span class="math inline">\(a_j^{(l)}\)</span> 与 <span class="math inline">\(l+1\)</span> 层的所有 <span class="math inline">\(z\)</span> 都有关系，所以 <span class="math display">\[\begin{aligned}\delta_j^{(l)} = \frac{\partial J(W,b)}{\partial z_j^{(l)}}&amp;= \sum_{k=1}^{n_{l+1}}\frac{\partial J(W,b)}{\partial z_k^{(l+1)}}\frac{\partial z_k^{(l+1)}}{\partial a_j^{(l)}}\frac{\partial a_j^{(l)}}{\partial z_j^{(l)}} \\&amp;= \sum_{k=1}^{n_{l+1}}\frac{\partial J(W,b)}{\partial z_k^{(l+1)}}w_{kj}^{(l+1)} f&#39;(z_j^{(l)}) \\&amp;= \sum_{k=1}^{n_{l+1}} \delta_k^{(l+1)} w_{kj}^{(l+1)} f&#39;(z_j^{(l)})\end{aligned}\]</span></p><p>对于最后一层</p><p><img src="image-20190304214833095.png" alt="image-20190304214833095" /> <span class="math display">\[\delta_p^{(L)} = \frac{\partial J(W,b)}{\partial z_p^{(L)}}= \frac{\partial J(W,b)}{\partial a_p^{(L)}} \frac{\partial a_p^{(L)}}{\partial z_p^{(L)}}= \frac{\partial J(W,b)}{\partial a_p^{(L)}} f&#39;(z_p^{(L)})\]</span></p><h3 id="总结">3. 总结</h3><p>有了上面的推导，反向传播算法的计算流程如下：</p><p><img src="image-20190304205128762.png" alt="image-20190304205128762" /></p><p>Step-1：依据前向传播算法求解每一层的激活值 <span class="math display">\[z^{(l)} = W^{(l)}a^{(l-1)} + b^{(l)} \qquad \qquad a^{(l)} = f(z^{(l)})\]</span> Step-2：计算出最后一层 (L 层) 的<strong>每个</strong>神经元的 <span class="math inline">\(\delta_p^{(L)}\)</span> <span class="math display">\[\delta_p^{(L)} = \frac{\partial J(W,b)}{\partial z_p^{(L)}}= \frac{\partial J(W,b)}{\partial a_p^{(L)}} f&#39;(z_p^{(L)})\]</span> Step-3：由后向前，依次计算出各 <span class="math inline">\(l\)</span> 层的各个神经元的 <span class="math inline">\(\delta_j^{(l)}\)</span> <span class="math display">\[\delta_j^{(l)} = \sum_{k=1}^{n_{l+1}} \delta_k^{(l+1)} w_{kj}^{(l+1)} f&#39;(z_j^{(l)})\]</span> Step-4：计算出各 <span class="math inline">\(l\)</span> 层的各个权重 $w_{ji}^{(l)} $ 的梯度及各个偏置 <span class="math inline">\(b_i^{(l)}\)</span> 的梯度 <span class="math display">\[\begin{aligned}\frac{\partial J(W,b)}{\partial w_{ji}^{(l)}} &amp;= \delta_j^{(l)}a_i^{(l-1)} \\\frac{\partial J(W,b)}{\partial b_{j}^{(l)}} &amp;= \delta_j^{(l)}\end{aligned}\]</span> Step-5：对各 <span class="math inline">\(l\)</span> 层的各个权重 $w_{ji}^{(l)} $ 的梯度及各个偏置 <span class="math inline">\(b_i^{(l)}\)</span> 的梯度进行更新，直到代价函数 <span class="math inline">\(J(W,b)\)</span> 足够小 <span class="math display">\[\begin{aligned}w_{ji}^{(l)} &amp;= w_{ji}^{(l)} - \alpha \frac{\partial J(W,b)}{\partial w_{ji}^{(l)}} \\b_j^{(l)} &amp;= b_j^{(l)} - \alpha \frac{\partial J(W,b)}{\partial b_j^{(l)}}\end{aligned}\]</span> 反向传播的最核心算式： <span class="math display">\[\begin{aligned}w_{ji}^{(l)} &amp;= w_{ji}^{(l)} - \alpha \frac{\partial J(W,b)}{\partial w_{ji}^{(l)}} \\&amp;= w_{ji}^{(l)} - \alpha \frac{\partial J(W,b)}{\partial z_j^{(l)}}\frac{\partial z_j^{(l)}}{\partial w_{ji}^{(l)}} \\&amp;= w_{ji}^{(l)} - \alpha \frac{\partial J(W,b)}{\partial z_j^{(l)}} a_i^{(l-1)} \\&amp;= w_{ji}^{(l)} - \alpha \bigg( \sum_{k=1}^{n_{l+1}} \delta_k^{(l+1)} w_{kj}^{(l+1)} f&#39;(z_j^{(l)}) \bigg) a_i^{(l-1)}\end{aligned}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BP算法 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习笔记</title>
      <link href="/posts/2837359218/"/>
      <url>/posts/2837359218/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是自己在学习git中的一些命令的笔记，以及基本的一个开发流程。因为当你不经常使用一个东西的时候，就会忘记那些命令怎么去用，所以我将其记录下来。 本文内容，学习自廖雪峰老师的网站：https://www.liaoxuefeng.com</p></blockquote><span id="more"></span><h3 id="git简介">1. Git简介</h3><p><strong>集中式版本控制系统：</strong>版本库是集中存放在中央服务器的，干活的时候，要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p><img src="0.jpg" alt="0" /></p><p>缺点：因为网速的限制，每次存取的耗时可能较长，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，在现在这个时代里，你能忍受么？</p><p><strong>分布式版本控制系统：</strong>没有”中央服务器”，每个人的电脑上都是一个完整的版本库。所以工作的时候就不需要联网了，那如何多个人合作呢？我们只需要把各自的修改推送就可以了。和集中式版本控制系统相比较，分布式版本控制系统更安全，因为每个人都有完整的库，不用害怕服务器崩掉。</p><p><img src="1.jpg" alt="1" /></p><h4 id="创建版本库">1.1. 创建版本库</h4><p>首先，我们需要新建一个文件夹，把这个文件夹当做我们的仓库(<strong>repository</strong>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir repository</span><br><span class="line">cd repository</span><br></pre></td></tr></table></figure><p>然后，使用 <code>git init</code> 来进行初始化设置，会生成一个 <code>.git</code> 的文件夹，里面存放的都是git仓库的管理信息。</p><p>再把文件添加到版本库，注意：千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可。</p><p>最后，我们使用命令来将我们改变的文件添加到Git仓库中去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add readme.txt</span><br><span class="line">git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure><h3 id="版本管理">2. 版本管理</h3><h4 id="版本回退">2.1. 版本回退</h4><p>当我们不断的进行add和commit操作之后，一旦我们发现某一天我们进行了一个错误的操作，需要我们回退到之前的版本：<code>git log</code> 命令显示从最近到最远的提交日志。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：<code>git log --pretty=oneline</code>。</p><p>我们看到了一大串数字开头，表示的是版本号，和SVN使用递增数字不一样，git使用的是一个SHA1计算出来的非常大的十六进制数字。</p><p><img src="image-20190313112907296.png" alt="image-20190313112907296" /></p><p>在git中，<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>这里需要注意下reset命令的参数有三个：</p><ul><li>hard：改变HEAD，索引和工作目录中的内容都恢复到指定版本。相当于我们做的一切修改都被删除了</li><li>soft：改变HEAD，索引和工作目录中的内容<strong>不变</strong>，相当于回到了没有commit的状态</li><li>mixed：改变HEAD，索引内容改变，工作目录中的内容<strong>不变</strong>，相当于回到了没有add的状态</li></ul><p>在Git中只要知道了每一次操作的版本号就可以reset，那么如何从旧版本恢复到新版本呢？Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令。</p><h4 id="工作区和暂存区">2.2 工作区和暂存区</h4><p>工作区就是我们在电脑中的目录</p><p>工作区有一个隐藏目录.git，这个就是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。 <img src="2.jpg" alt="2" /></p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><h4 id="撤销修改">2.3. 撤销修改</h4><h5 id="丢弃工作区的修改">2.3.1. 丢弃工作区的修改</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区（未执行<code>git add</code>），现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改（执行过<code>git add</code>），现在，撤销修改就回到添加到暂存区后的状态。</p><h5 id="丢弃暂存区的修改">2.3.2. 丢弃暂存区的修改</h5><p>如果我们执行了<code>git add</code>后，发现了文件的错误，这个时候该如何撤销呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><p>使用这个命令可以把暂存区的修改撤销掉（unstage），重新放回工作区。 还记得如何丢弃工作区的修改吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure><h5 id="丢弃版本库的修改">2.3.3. 丢弃版本库的修改</h5><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。</p><h4 id="删除文件">2.4 删除文件</h4><p>当我们从工作区中删除一个文件的时候，我们有两个选择</p><h5 id="从版本库中删除该文件">2.4.1. 从版本库中删除该文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm test.txt</span><br><span class="line">git commit -m &quot;remove test.txt&quot;</span><br></pre></td></tr></table></figure><h5 id="删错了文件">2.4.2. 删错了文件</h5><p>因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- test.txt</span><br></pre></td></tr></table></figure><h3 id="远程仓库">3. 远程仓库</h3><h4 id="添加远程库">3.1. 添加远程库</h4><p>使用Github来作为Git的远程仓库</p><p>那么如何把本地仓库与远程仓库关联呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:liysss/Self-NN.git</span><br></pre></td></tr></table></figure><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure><h4 id="从远程库克隆">3.2. 从远程库克隆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:liysss/Self-NN.git</span><br></pre></td></tr></table></figure><h3 id="分支管理">4. 分支管理</h3><h4 id="创建分支">4.1 创建分支</h4><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点，每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p><p><img src="3.png" alt="3" /></p><p>当我们创建新的分支，比如dev的时候，Git新建了一个指针叫dev，指向master相同的提交，再把head指向dev，就表示当前分支在dev上。 <img src="4.png" alt="4" /></p><p>Git新建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化。不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。 <img src="5.png" alt="5" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><p>现在，我们在dev分支上面的工作完成了，我们就可以切换回master分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure><p>然后，把dev分支上的工作成果合并到master分支上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure><p>合并完成后，就可以放心地删除dev分支了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure><h4 id="解决冲突">4.2. 解决冲突</h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><h4 id="分支管理-1">4.3. 分支管理</h4><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h4 id="bug分支">4.4. Bug分支</h4><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交。</p><p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &#x27;issue-101&#x27;</span><br></pre></td></tr></table></figure><p>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br></pre></td></tr></table></figure><p>然后切回dev分支干活吧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h4 id="feature分支">4.5. Feature分支</h4><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch &#x27;feature-vulcan&#x27;</span><br></pre></td></tr></table></figure><p>切回dev，准备合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h4 id="多人协作">4.6. 多人协作</h4><p>要查看远程库的信息，用<code>git remote</code>，或者，用<code>git remote -v</code>显示更详细的信息。</p><h5 id="推送分支">4.6.1 推送分支</h5><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h5 id="抓取分支">4.6.2 抓取分支</h5><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><ul><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p></li></ul><h4 id="rebase">4.7. Rebase</h4><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p><p>每次合并再push后，分支变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin/master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#x27;dev&#x27;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin/dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |/  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|/ /  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |/  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找区间问题</title>
      <link href="/posts/377396194/"/>
      <url>/posts/377396194/</url>
      
        <content type="html"><![CDATA[<blockquote><p>二分查找可以用 $O(logn) $ 的时间复杂度来完成查找，是经常使用的查找算法，也是面试中经常出现的题目，二分问题最重要的两个点就是：1）二分的区间；2）判断的条件。</p></blockquote><span id="more"></span><p>通过查阅资料以及自己的刷题经验，我通常使用左闭右开 <code>[left, right)</code> 这样的方式，因为这种方法可以做到足够的简洁，以及它是 STL 标准库中的写法，下面来详细的介绍如何使用。</p><h3 id="lower_bound">1. lower_bound</h3><p><code>lower_bound</code> 是STL标准库中的函数，这个函数的目的是在区间 <code>[left, right)</code> 内求出第一个不小于 <code>target</code> 的位置，目标是为了求一个<strong>下界</strong>，如果不存在，就返回 <code>right</code>。</p><p>这里要记住的就是，如果 <code>target</code> 不存在，那么返回的是第一个<font color='red'>大于</font> <code>target</code> 的数。</p><p>因为该函数，返回的是 <code>[left, right)</code> 内满足 <code>x &gt;= target</code> 的<font color='red'>最小值</font>的位置，所以叫做 <code>lower_bound</code>。</p><h3 id="upper_bound">2. upper_bound</h3><p><code>upper_bound</code> 同样是STL标准库的函数，它个目的是为了在区间 <code>[left, right)</code> 内求出第一个大于 <code>target</code> 的值，细心的你可能会发现，这个函数要找的是 <code>x &gt; target</code> 的<font color='red'>最小值</font>的位置，这不也找的是一个下界么？为什么它叫 <code>upper_bound</code> 呢？</p><p>别急，我们先想一想 <code>upper_bound</code> 和 <code>lower_bound</code> 的作用，换句话说，它们的服务对象是不是都是 <code>target</code>。这个 <code>target</code> 在数组里就像一个老大，我们要找到它的所有值，比如说有这样一个数组：<code>[2, 2, 2, 2, 3]</code> 现在 <code>target = 2</code>，所以 <code>target</code> 的区间显然是 <code>[0, 3]</code>，如果把这个区间变成左闭右开，即：<code>[0, 4)</code></p><p>这不就是 <code>[ lower_bound(target), upper_bound(target) )</code> 嘛</p><p>第一个大于 <code>target</code> 的值，放到上面这个区间内，不就是一个上界值嘛。所以这个 <code>upper_bound</code> 的名字也因此而得来。</p><p>不过，显然这个函数更常用的还是寻找一个下界值，即：第一个 <code>x &gt; target</code> 。</p><h3 id="应用">3. 应用</h3><p><strong>求下界</strong></p><ul><li>第一个 <code>x &gt;= target</code> ：lower_bound</li><li>第一个 <code>x &gt; target</code> ：upper_bound</li></ul><p><strong>求上界</strong></p><ul><li><code>x &lt; target</code> 的最大值：lower_bound - 1</li><li><code>x &lt;= target</code> 的最大值：upper_bound - 1</li></ul><h4 id="二分写法">4. 二分写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">  <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    right = mid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode树专题</title>
      <link href="/posts/554588017/"/>
      <url>/posts/554588017/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文对所有关于树的算法题做一个概括</p></blockquote><span id="more"></span><h3 id="二叉树遍历">1. 二叉树遍历</h3><h4 id="递归写法">1.1. 递归写法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">  res.<span class="built_in">push_back</span>(root-&gt;val);       <span class="comment">// only need to change there.</span></span><br><span class="line">  <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归写法">1.2. 非递归写法</h4><p>使用栈和一个辅助节点 <code>p = root</code>，<code>while</code> 的循环条件改为栈不为空或者辅助结点p不为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p) &#123;</span><br><span class="line">    s.<span class="built_in">push</span>(p);</span><br><span class="line">    p = p-&gt;left;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p = s.<span class="built_in">top</span>();</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    res.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">    p = p-&gt;right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历的非递归写法特殊，有两种做法，一种是在先序遍历的基础上做修改</p><p>因为先序遍历是：根 <span class="math inline">\(\to\)</span> 左 <span class="math inline">\(\to\)</span> 右；后序遍历是：左 <span class="math inline">\(\to\)</span> 右 <span class="math inline">\(\to\)</span> 根</p><p>所以我们可以把先序遍历改为：根 <span class="math inline">\(\to\)</span> 右 <span class="math inline">\(\to\)</span> 左，然后做一个翻转。</p><p>另外一个方法就是使用一个辅助节点 p 来表示上一个节点，来判断当前节点是否为根</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  TreeNode* t = s.<span class="built_in">top</span>();</span><br><span class="line">  <span class="keyword">if</span> ((!t-&gt;left &amp;&amp; !t-&gt;right) || t-&gt;left == pre || t-&gt;right == pre) &#123;</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">    res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">    pre = t;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;right) s.<span class="built_in">push</span>(t-&gt;right); <span class="comment">// first right</span></span><br><span class="line">    <span class="keyword">if</span> (t-&gt;left) s.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历">1.3. 层序遍历</h4><p>使用队列来表示每一层，关键点在于 for 循环的条件：<code>for (int i = q.size() ; i &gt; 0; i--)</code></p><h3 id="bst">2. BST</h3><h4 id="bst的数目">2.1. BST的数目</h4><p>我们假设 <span class="math inline">\(G(n)\)</span> 表示1... n 所能组成的BST的个数，<span class="math inline">\(F(j, n)\)</span> 表示以 <span class="math inline">\(j\)</span> 为根形成BST的数目 <span class="math display">\[\begin{align}F(j, n) &amp;= G(j-1)*G(n-j) \\G(n) &amp;= \sum_{j=1}^{n}F(j, n)\end{align}\]</span></p><h4 id="具体的bst">2.2. 具体的BST</h4><p>上面我们求了不同BST的数目，那如果是求具体的BST呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = beg; i &lt;= end; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : <span class="built_in">helper</span>(beg, i<span class="number">-1</span>, dp)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; b : <span class="built_in">helper</span>(i+<span class="number">1</span>, end, dp)) &#123;</span><br><span class="line">      TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(i);</span><br><span class="line">      root-&gt;left = a;</span><br><span class="line">      root-&gt;right = b;</span><br><span class="line">      res.<span class="built_in">push_back</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[beg][end] = res;</span><br></pre></td></tr></table></figure><h4 id="验证一个bst">2.4. 验证一个BST</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;val &gt;= maxVal || root-&gt;val &lt;= minVal) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> helper(root-&gt;left, root-&gt;val, minVal) &amp;&amp; helper(root-&gt;right, maxVal, root-&gt;val);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>975. Odd Even Jump 奇偶跳</title>
      <link href="/posts/2496146020/"/>
      <url>/posts/2496146020/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个整数数组A，从一个起始index，你可以做一系列的跳跃，第1，3，5…次为奇数跳 (第2，4，6…次为偶数跳)</p><p>从位置 i 开始，奇数跳只能跳到之后的最小值；偶数跳只能跳到之后的最大值。进行一次次跳跃之后如果可以到达最后一个位置，就是一次合法的跳跃。求合法跳跃的总数。</p></blockquote><span id="more"></span><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,13,12,14,15]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">From starting index i = 0, we can jump to i = 2 (since A[2] is the smallest among A[1], A[2], A[3], A[4] that is greater or equal to A[0]), then we can&#x27;t jump any more.</span><br><span class="line">From starting index i = 1 and i = 2, we can jump to i = 3, then we can&#x27;t jump any more.</span><br><span class="line">From starting index i = 3, we can jump to i = 4, so we&#x27;ve reached the end.</span><br><span class="line">From starting index i = 4, we&#x27;ve reached the end already.</span><br><span class="line">In total, there are 2 different starting indexes (i = 3, i = 4) where we can reach the end with some number of jumps.</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>我们每次的跳跃由两个因素决定：1）当前index；2）第几次跳跃</p><p>对于每一个位置 i 我们可以用 <code>odd[i]</code> 来表示本次为奇数跳跃是否能够到达最后一个元素；<code>even[i]</code> 来表示本次为偶数跳跃能否到达最后一个元素。</p><p>因为从一个位置开始第一次跳跃一定是奇数的，所以<code>res</code>的结果就是<code>odd</code>中1的个数。</p><p>关键点就转变为求出下一次跳跃的位置：</p><ul><li>oddNext：<code>A[i] &lt;= A[j]</code>，位置 i 之后的不小于 A[i] 的<strong>最小值</strong></li><li>evenNext：<code>A[i] &gt;= A[j]</code>，位置 i 之后的不大于 A[i] 的<strong>最大值</strong></li></ul><p>只要求出 oddNext 和 evenNext 这两个数组，本题就得以解决了。</p><h3 id="单调栈">2. 单调栈</h3><p>想要更好的了解单调栈，我们先来看一个经典的例子：</p><blockquote><p>给一个数组，返回每个位置之后第一个比自己大的下标，不存在比自己大的数，返回-1 输入：[5, 3, 1, 2, 4] 输出：[-1, 4, 3, 4, -1]</p></blockquote><p>暴力解法显然是 <span class="math inline">\(O(n^2)\)</span> 的</p><p>我们维护一个单调递减的栈，如果要进栈的数比栈顶元素大，我们弹出栈内所有对应数比这个数小的元素。并更新它们在返回数组中对应位置的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;  <span class="comment">// 压入每个元素的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; input[s.<span class="built_in">top</span>()] &lt; input[i]) &#123;</span><br><span class="line">    res[s.<span class="built_in">top</span>()] = i;</span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  s.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看我们这道题，如何求位置 i 之后的不小于 A[i] 的<strong>最小值</strong>呢？ 位置 i 之后的元素是无序的，如果我们想求它的最大值，暴力解法就是遍历 i 之后的每一个元素得到最大值。这样的时间复杂度是 <span class="math inline">\(O(n^2)\)</span> 的。如果我们把原数组按照升序排列，那么结果就是排序之后 i 的下一个元素，这样的时间复杂度是 <span class="math inline">\(O(n·logn)\)</span> 的。</p><p>但是，因为我们想知道的是下标，所以还需要用 <code>vector&lt;pair&lt;int, int&gt;&gt; index</code> 将每个元素和它的下标对应起来。</p><h4 id="代码">2.1. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">oddEvenJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; index;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">oddNext</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">evenNext</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">odd</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">even</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) index.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(A[i], i));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大排列</span></span><br><span class="line">    <span class="built_in">sort</span>(index.<span class="built_in">begin</span>(), index.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">helper</span>(index, oddNext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从大到小排列</span></span><br><span class="line">    <span class="built_in">sort</span>(index.<span class="built_in">begin</span>(), index.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">helper</span>(index, evenNext);</span><br><span class="line"></span><br><span class="line">    odd[n - <span class="number">1</span>] = even[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oddNext[i] != <span class="number">-1</span>) odd[i] = even[oddNext[i]];</span><br><span class="line">      <span class="keyword">if</span> (evenNext[i] != <span class="number">-1</span>) even[i] = odd[evenNext[i]];</span><br><span class="line">      res += odd[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.first == b.first) <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;index, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> j : index) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; j.second &gt; s.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        res[s.<span class="built_in">top</span>()] = j.second;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      s.<span class="built_in">push</span>(j.second);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">2.2. 结果</h4><p>Runtime: 68 ms, faster than 99.50% of C++ online submissions for Odd Even Jump. Memory Usage: 15.4 MB, less than 94.55% of C++ online submissions for Odd Even Jump.</p><h3 id="map">3. Map</h3><p>STL中的Map是基于红黑树实现的，提供了两个函数：</p><ul><li>lower_bound(key)：返回map中第一个大于或等于key的迭代器指针</li><li>upper_bound(key)：返回map中第一个大于key的迭代器指针</li></ul><h4 id="代码-1">3.1. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">oddEvenJumps</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>, n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">odd</span><span class="params">(n, <span class="number">0</span>)</span>, <span class="title">even</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;  <span class="comment">// key -&gt; index</span></span><br><span class="line">    m[A[n - <span class="number">1</span>]] = n - <span class="number">1</span>;</span><br><span class="line">    even[n - <span class="number">1</span>] = odd[n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="comment">// 此时m中的元素都是i之后的元素</span></span><br><span class="line">      <span class="keyword">auto</span> it = m.<span class="built_in">lower_bound</span>(A[i]);  <span class="comment">// 第一个大于等于A[i]</span></span><br><span class="line">      <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) odd[i] = even[it-&gt;second];</span><br><span class="line"></span><br><span class="line">      it = m.<span class="built_in">upper_bound</span>(A[i]);  <span class="comment">// 第一个大于A[i], --it就是第一个小于等于A[i]</span></span><br><span class="line">      <span class="keyword">if</span> (it != m.<span class="built_in">begin</span>()) even[i] = odd[(--it)-&gt;second];</span><br><span class="line"></span><br><span class="line">      m[A[i]] = i;</span><br><span class="line">      res += odd[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">3.2. 结果</h4><p>Runtime: 92 ms, faster than 92.01% of C++ online submissions for Odd Even Jump. Memory Usage: 19.2 MB, less than 48.99% of C++ online submissions for Odd Even Jump.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>973. K Closest Points to Origin 距原点最近的K个点</title>
      <link href="/posts/425578935/"/>
      <url>/posts/425578935/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个点集合，找到距离原点最近的K个点</p></blockquote><span id="more"></span><h3 id="思路">1. 思路</h3><p>只需要把把点按照距离排序，然后选取前K个元素就可以了。可以使用快排中的partition函数操作来找到mid = K的值，然后返回前K个就可以了(注：前K个不需要有顺序)</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = points.<span class="built_in">size</span>() - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      mid = <span class="built_in">partition</span>(points, left, right);</span><br><span class="line">      <span class="keyword">if</span> (mid == K - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; K - <span class="number">1</span>)</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(points.<span class="built_in">begin</span>(), points.<span class="built_in">begin</span>() + K);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 加减乘除的做法，一定能缩减就缩减，最开始我使用的是dis函数算单点的距离，多出了100ms</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; p1, vector&lt;<span class="keyword">int</span>&gt;&amp; p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] - p2[<span class="number">0</span>] * p2[<span class="number">0</span>] - p2[<span class="number">1</span>] * p2[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; temp = points[left];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">compare</span>(points[right], temp) &gt;= <span class="number">0</span>) right--;</span><br><span class="line">      points[left] = points[right];</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">compare</span>(points[left], temp) &lt;= <span class="number">0</span>) left++;</span><br><span class="line">      points[right] = points[left];</span><br><span class="line">    &#125;</span><br><span class="line">    points[left] = temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 220 ms, faster than 96.07% of C++ online submissions for K Closest Points to Origin. Memory Usage: 36.6 MB, less than 99.33% of C++ online submissions for K Closest Points to Origin.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> quick select </tag>
            
            <tag> top-k </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>929. Unique Email Addresses 不同的Email地址</title>
      <link href="/posts/1301789903/"/>
      <url>/posts/1301789903/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每一个email地址都包含两部分：用户名@域名。除了小写字母外，还包含<code>'.'</code>和 <code>'+'</code>两个符号 如果在用户名部分使用<code>'.'</code>会被忽略，例如：<code>"alice.z@leetcode.com"</code>和<code>"alicez@leetcode.com"</code>相等 如果在用户名部分使用<code>'+'</code>之后的字母会被忽略，例如：<code>"m.y+name@email.com"</code>和<code>"my@email.com"</code>相等 域名部分，上述符号都不起作用。给定一组email，返回不同email的数量</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>这道题，很简单，没有什么复杂的逻辑，首先要定位@的位置，然后在前半部分寻找<code>'.'</code>和 <code>'+'</code>两个符号做处理，然后统计处理后的email中的不同值。</p><p>这里，我会用到几个C++11的新特性，所以记录一下。</p><h4 id="unordered_set和unordered_map">1.1. unordered_set和unordered_map</h4><p>C++ 11中出现了两种新的关联容器：unordered_set和unordered_map，其内部实现与set和map不同。原来的set和map的内部实现是使用的<strong>红黑树</strong>，红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <span class="math inline">\(O(logN)\)</span>。而unordered_set和unordered_map的内部实现是<strong>哈希表</strong>，哈希表的特点就是查找效率高，时间复杂度为常数级别 <span class="math inline">\(O(1)\)</span>。</p><p>因为这道题每个值要求是唯一的，所以我们可以使用<strong>unordered_set</strong>来存储。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(vector&lt;string&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;string&gt; unique;</span><br><span class="line">    <span class="keyword">for</span> (string email : emails) &#123;</span><br><span class="line">      string res;</span><br><span class="line">      <span class="keyword">bool</span> domain = <span class="literal">false</span>, add = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">char</span> c : email) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">          domain = <span class="literal">true</span>;</span><br><span class="line">          add = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> &amp;&amp; !domain) &#123;</span><br><span class="line">          add = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((c == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !domain) || add) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += c;</span><br><span class="line">      &#125;</span><br><span class="line">      unique.<span class="built_in">insert</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unique.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 36 ms, faster than 88.56% of C++ online submissions for Unique Email Addresses. Memory Usage: 14.2 MB, less than 57.89% of C++ online submissions for Unique Email Addresses.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>924. Minimize Malware Spread 最小感染结点</title>
      <link href="/posts/2972120990/"/>
      <url>/posts/2972120990/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有一个无向图，图中有些结点被感染了，感染会通过图的边传播。现在可以移除一个初始被感染的结点，问移除哪一个结点可以使最终被感染的总结点数最小？如果有多个结点，输出编号最小的一个。</p></blockquote><span id="more"></span><h3 id="思路">1. 思路</h3><p>刚开始读这个题的时候，并不是哼明白题的意思，看了眼评论区，有大佬给出了图示，瞬间就明白了题意。</p><p><img src="image_1539490077.png" alt="image_1539490077" /></p><p>上面的图中3个黄色的点被感染了，题目要求移除一个结点，使被感染的总结点数最小，这里要注意的是并不是真的移除，仅仅只是让结点变成正常的结点，之后它还有可能被感染。下面我们来看3种情况：</p><ul><li>处理结点1：因为结点3的存在，结点0，1，4，6最终还是会被感染</li><li>处理结点3：与结点1同理</li><li>处理结点5：因为没有其它感染源，所以最后2，5，7三个结点不会被感染。</li></ul><p>通过上面的分析，这道题考察的是<strong>连通分量</strong>，找出图中的所有连通分量，如果该联通分量只存在一个感染源，那么就可以通过改变这个结点使整个连通分量幸免。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> u, <span class="keyword">int</span>&amp; c, <span class="keyword">int</span>&amp; inc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.<span class="built_in">size</span>(); v++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (graph[u][v] &amp;&amp; !vis[v]) &#123;</span><br><span class="line">        vis[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (injected.<span class="built_in">find</span>(v) != injected.<span class="built_in">end</span>()) inc += <span class="number">1</span>;</span><br><span class="line">        c += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(graph, v, c, inc);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initial.<span class="built_in">size</span>(); i++) injected.<span class="built_in">insert</span>(initial[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); i++) vis.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(initial.<span class="built_in">begin</span>(), initial.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> res = initial[<span class="number">0</span>], MAX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initial.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">1</span>;    <span class="comment">// 连通分量中的结点总数</span></span><br><span class="line">      <span class="keyword">int</span> inCount = <span class="number">1</span>;  <span class="comment">// 连通分量重被感染的结点数</span></span><br><span class="line">      <span class="keyword">int</span> u = initial[i];</span><br><span class="line">      <span class="keyword">if</span> (!vis[u]) &#123;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(graph, u, count, inCount);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (inCount == <span class="number">1</span> &amp;&amp; count - <span class="number">1</span> &gt; MAX) &#123;</span><br><span class="line">        MAX = count - <span class="number">1</span>;</span><br><span class="line">        res = u;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="keyword">bool</span>&gt; vis;</span><br><span class="line">  unordered_set&lt;<span class="keyword">int</span>&gt; injected;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 180 ms, faster than 57.16% of C++ online submissions for Minimize Malware Spread. Memory Usage: 28 MB, less than 67.44% of C++ online submissions for Minimize Malware Spread.</p><h3 id="并查集">4. 并查集</h3><h4 id="解析">4.1. 解析</h4><p>首先利用并查集把graph中各个节点进行分组，同一个组的元素只要有一个被infected，那么其他的都会被infected，接下来遍历initial中的元素，如果initial中的元素有两个或者两个以上属于同一个组的话，那么从initial中去除这几个元素中的任何一个都无法减少infected nodes的数量。所以题目就演变成了从initial中找出和其他元素均不属于同一个组，并且这个元素的所属的组包含最多的元素。</p><h4 id="代码-1">4.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> MAX = <span class="number">-1</span>, res = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(initial.<span class="built_in">begin</span>(), initial.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[i][j]) <span class="built_in">unionfather</span>(i, j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u : initial) &#123;</span><br><span class="line">      <span class="keyword">int</span> fu = <span class="built_in">findfather</span>(u);</span><br><span class="line">      <span class="comment">// 如果injected中不存在fu，可能是潜在答案</span></span><br><span class="line">      <span class="keyword">if</span> (injected.<span class="built_in">find</span>(u) == injected.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        injected.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(u, count[fu]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        injected[u] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : injected) &#123;</span><br><span class="line">      <span class="keyword">if</span> (it.second &gt; MAX) &#123;</span><br><span class="line">        MAX = it.second;</span><br><span class="line">        res = it.first;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; father;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; count;  <span class="comment">// 树包含的结点</span></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; injected;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findfather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != father[x]) <span class="keyword">return</span> father[x] = <span class="built_in">findfather</span>(father[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unionfather</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = <span class="built_in">findfather</span>(a);</span><br><span class="line">    <span class="keyword">int</span> fb = <span class="built_in">findfather</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">      father[fa] = fb;</span><br><span class="line">      count[b] += count[a];  <span class="comment">// 结点数增加</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    father.<span class="built_in">resize</span>(n);</span><br><span class="line">    count.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      father[i] = i;</span><br><span class="line">      count[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">4.3. 结果</h4><p>Runtime: 176 ms, faster than 77.19% of C++ online submissions for Minimize Malware Spread. Memory Usage: 27.7 MB, less than 97.67% of C++ online submissions for Minimize Malware Spread.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> DFS </tag>
            
            <tag> Union Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>904. Fruit Into Baskets 水果装入果篮</title>
      <link href="/posts/3103430288/"/>
      <url>/posts/3103430288/</url>
      
        <content type="html"><![CDATA[<blockquote><p>假设你有两个果篮，现在要去书上摘果子，tree[i]对应的数值表示的是水果的类型，每个果篮只能装一种水果（即只能选择两种水果），当我们选定一颗果树的时候，只能往右走。</p></blockquote><span id="more"></span><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We can collect [1,2,1,1,2].</span><br><span class="line">If we started at the first tree or the eighth tree, we would only collect 4 fruits.</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>我的第一想法是像之前的<strong>最长无重复子串</strong>这道题一样，维护一个窗口，因为我们只能采摘两个水果，所以在这个窗口中只能存在两种类型，当向右遍历出现新类型的时候，我们需要把窗口的左边界，移动到第一种水果的最后一个位置</p><p>注意：采用的窗口是左开右闭的 (a, b]<br />所以<code>start</code>、<code>type[0].second</code>、<code>type[1].second</code>初始值为-1</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">    pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; type[<span class="number">2</span>];</span><br><span class="line">    type[<span class="number">0</span>].second = type[<span class="number">1</span>].second = <span class="number">-1</span>;  <span class="comment">// 初始化边界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tree[i] != type[<span class="number">0</span>].first &amp;&amp; tree[i] != type[<span class="number">1</span>].first) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type[<span class="number">0</span>].second &lt;= type[<span class="number">1</span>].second) &#123;</span><br><span class="line">          start = type[<span class="number">0</span>].second;</span><br><span class="line">          type[<span class="number">0</span>] = &#123;tree[i], i&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          start = type[<span class="number">1</span>].second;</span><br><span class="line">          type[<span class="number">1</span>] = &#123;tree[i], i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree[i] == type[<span class="number">0</span>].first)</span><br><span class="line">        type[<span class="number">0</span>].second = i;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (tree[i] == type[<span class="number">1</span>].first)</span><br><span class="line">        type[<span class="number">1</span>].second = i;</span><br><span class="line">      maxLen = <span class="built_in">max</span>(maxLen, i - start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 132 ms, faster than 72.94% of C++ online submissions for Fruit Into Baskets. Memory Usage: 15.2 MB, less than 95.98% of C++ online submissions for Fruit Into Baskets.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>560. Subarray Sum Equals K 子数组和为K</title>
      <link href="/posts/1301811862/"/>
      <url>/posts/1301811862/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个数组和一个整数k，求和为k的连续子数组的个数</p></blockquote><span id="more"></span><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><h3 id="暴力解法">1. 暴力解法</h3><h4 id="思路">1.1. 思路</h4><p>暴力解法使用两个for循环来求解，第一个for循环表示起始位置，第二个for循环从i开始做累加。</p><h4 id="代码">1.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line">        <span class="keyword">if</span> (sum == k) res++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">1.3. 结果</h4><p>Runtime: 472 ms, faster than 26.85% of C++ online submissions for Subarray Sum Equals K. Memory Usage: 9.8 MB, less than 100.00% of C++ online submissions for Subarray Sum Equals K.</p><h3 id="使用hashmap">2. 使用HashMap</h3><h4 id="思路-1">2.1. 思路</h4><p>还有一种思路是用一个 <code>sums[i]</code> 来记录从 [0, i] 的和，那么从 [a, b] 的累加和就等于 <code>sums[b] - sums[a]</code></p><p>但是，如果我们常规来做的话，还是需要两个for循环，因为我们需要从当前位置 i 向前遍历每一个j 去求 <code>sums[i] - sums[j]</code> 。所以，这个时候就需要用到HashMap来记录下之前的 <code>sums</code>，有因为 <code>sums[i] - sum[j] = k</code> ，即 <code>sums[j] = sums[i] - k</code> ，所以只要 <code>HashMap[sums[i] - k]</code> 存在，那么 <code>res</code> 就需要加一。</p><h4 id="代码-1">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      sum += nums[i];</span><br><span class="line">      <span class="keyword">int</span> j = sum - k;</span><br><span class="line">      <span class="keyword">if</span> (m.<span class="built_in">find</span>(j) != m.<span class="built_in">end</span>()) res += m[j];</span><br><span class="line">      m[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">2.3. 结果</h4><p>Runtime: 32 ms, faster than 99.29% of C++ online submissions for Subarray Sum Equals K. Memory Usage: 14.1 MB, less than 76.56% of C++ online submissions for Subarray Sum Equals K.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>547. Friend Circles 朋友圈</title>
      <link href="/posts/1791764637/"/>
      <url>/posts/1791764637/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果 A 和 B 是好友，B 和 C 是好友，那么即使 A 和 C 就是好友，我们用一个 N*N 的矩阵来描述 N 个人之间的朋友关系，M[i][j] = 1就表示 i 和 j 是好朋友，求 N 个人中有几个朋友圈</p></blockquote><span id="more"></span><h3 id="dfs-解法">1. DFS 解法</h3><h4 id="分析">1.1. 分析</h4><p>假如 M[i] [j] 为 1，那么我们就可以顺着 j 向下 DFS 找到该圈子内的所有人，i <span class="math inline">\(\to\)</span> <span class="math inline">\(j_1\)</span> <span class="math inline">\(... \to j_n\)</span></p><p>对于某个人，遍历其好友，然后再遍历其好友的好友，那么我们就能把属于同一个朋友圈的人都遍历一遍，我们同时标记出已经遍历过的人，然后累积朋友圈的个数。</p><h4 id="代码">1.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    M[i][j] = M[j][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; M.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (M[j][k]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(M, j, k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (M[i][i]) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="built_in">dfs</span>(M, i, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">1.3. 结果</h4><p>Runtime: 24 ms, faster than 45.27% of C++ online submissions for Friend Circles. Memory Usage: 11.1 MB, less than 36.36% of C++ online submissions for Friend Circles.</p><h3 id="并查集">2. 并查集</h3><h4 id="思路">2.1. 思路</h4><p>这是一道典型的并查集题目，N 个人一开始属于 N 个结点，如果 A 和 B 是朋友，那么就将 B 和 A 合并在一起，然后如果 B 和 C 是朋友关系，由于 A 和 B 已经在同一颗树上了，那么将 C 也加入这颗树就可以了。最后我们统计有几棵树，就是几个朋友圈。</p><p>这里有一个小 trick，我们可以初始化 <code>ans = N</code> 如果有结点合并，那么就让 <code>ans--</code></p><h4 id="代码-1">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; father, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (father[k] != k) <span class="keyword">return</span> father[k] = <span class="built_in">findFather</span>(father, father[k]);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">father</span><span class="params">(M.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> ans = M.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.<span class="built_in">size</span>(); i++) father[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; M.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (M[i][j]) &#123;</span><br><span class="line">          <span class="keyword">int</span> f1 = <span class="built_in">findFather</span>(father, i);</span><br><span class="line">          <span class="keyword">int</span> f2 = <span class="built_in">findFather</span>(father, j);</span><br><span class="line">          <span class="keyword">if</span> (f1 != f2) &#123;</span><br><span class="line">            ans--;</span><br><span class="line">            father[f2] = f1;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">2.3. 结果</h4><p>Runtime: 16 ms, faster than 97.08% of C++ online submissions for Friend Circles. Memory Usage: 10.8 MB, less than 100.00% of C++ online submissions for Friend Circles.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>460. LFU Cache 最近最少未使用</title>
      <link href="/posts/4094197651/"/>
      <url>/posts/4094197651/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计并实现一个<a href="https://en.wikipedia.org/wiki/Least_frequently_used">Least Frequently Used (LFU)</a> 的数据结构，支持<code>get</code> and <code>put</code>两种方法。 <code>get(key)</code> - 获得cache中key值的value，如果不存在返回-1，key保证正数 <code>put(key, value)</code> - 将cache中key值对应的数设置为value，如果不存在key则插入(key, value)这个数据 要求：时间复杂度为 <span class="math inline">\(O(1)\)</span></p></blockquote><span id="more"></span><h3 id="解析">1. 解析</h3><p>LRU是从时间角度出发</p><p>LFU是从数量角度出发</p><p>因为涉及到了次数的问题，所以我们设计的哈希表既要包含value，也要包含freq，即 <code>(key, (value, freq))</code></p><ul><li><code>unoreder_map&lt;int, pair&lt;int, int&gt;&gt; cache_</code></li></ul><p>如果出现超出容量的情况，我们需要快速的找到频率最小的那个元素，所以我们还要对 freq 建立哈希表。又因为具有相同频率的 key 会被哈希到同一个位置，所以需要 <code>(freq, list&lt;key&gt;)</code></p><ul><li><code>unordered_map&lt;int, list&lt;int&gt;&gt; freq_</code></li></ul><p>因为出现了list，回顾LRU中我们为了精准的定位到 list 中的元素，又需要建立 <code>(key, itetator)</code> 的哈希</p><ul><li><code>unordered_map&lt;int, list&lt;int&gt;::itetator&gt; pos_</code></li></ul><p><strong>use(key) 操作</strong></p><p>首先，判断 key是否存在于 cache 中</p><ul><li>如果存在，那么将它从 freq_ 的 list 中移除，并且记录它的 freq 的值</li><li>如果不存在，那么就要判断容量的大小</li></ul><p>然后，更新 <code>cache_, freq_, pos_</code> 三个哈希表的值</p><p>最后，更新 minfreq_ 的值</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">capacity_</span>(capacity), <span class="built_in">minfreq_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache_.<span class="built_in">find</span>(key) == cache_.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">use</span>(key);</span><br><span class="line">    <span class="keyword">return</span> cache_[key].first;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity_ &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">use</span>(key);</span><br><span class="line">    cache_[key].first = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos_.<span class="built_in">find</span>(key) != pos_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      freq = cache_[key].second;</span><br><span class="line">      freq_[freq].<span class="built_in">erase</span>(pos_[key]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache_.<span class="built_in">size</span>() &gt;= capacity_) &#123;</span><br><span class="line">      <span class="keyword">int</span> old = freq_[minfreq_].<span class="built_in">back</span>();</span><br><span class="line">      freq_[minfreq_].<span class="built_in">pop_back</span>();</span><br><span class="line">      cache_.<span class="built_in">erase</span>(old);</span><br><span class="line">      pos_.<span class="built_in">erase</span>(old);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freq++;</span><br><span class="line">    cache_[key].second = freq;</span><br><span class="line">    freq_[freq].<span class="built_in">push_front</span>(key);</span><br><span class="line">    pos_[key] = freq_[freq].<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freq_[minfreq_].<span class="built_in">size</span>() == <span class="number">0</span>) minfreq_++;</span><br><span class="line">    <span class="keyword">if</span> (freq == <span class="number">1</span>) minfreq_ = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> capacity_;</span><br><span class="line">  <span class="keyword">int</span> minfreq_;</span><br><span class="line">  unordered_map&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cache_;     <span class="comment">// (key, (value, freq));</span></span><br><span class="line">  unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;&gt; freq_;           <span class="comment">// (freq, list)</span></span><br><span class="line">  unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;::iterator&gt; pos_;  <span class="comment">// (key, pos)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 128 ms, faster than 56.74% of C++ online submissions for LFU Cache. Memory Usage: 40.9 MB, less than 61.76% of C++ online submissions for LFU Cache.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>336. Palindrome Pairs 回文对</title>
      <link href="/posts/4206173663/"/>
      <url>/posts/4206173663/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给你一些不同的words，选出所有能构成回文对的组合。即 word[i] + word[j] 构成回文。</p></blockquote><span id="more"></span><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]</span><br><span class="line">Output: [[0,1],[1,0],[3,2],[2,4]] </span><br><span class="line">Explanation: The palindromes are [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>这道题，如果我们直接用暴力的方法，遍历所有words的组合，验证组合后的字符串是否为回文。时间复杂度为 <span class="math inline">\(O(n^2 * k)\)</span>。这样的时间复杂度显然不是我们能接受的。所以，我们要想办法优化。如果我们想判断一个字符串是否为回文，有一个简便的方法就是判断 <code>hash[反转word]</code> 是否存在。但是，这样我们只能找到 <code>["abcd","dcba"]</code> 。我们还需要解决 <code>["lls", "s"]</code> 这种情况。</p><ul><li><p>初始化 dict[反转word] = 自己的下标，这样 <code>word[i] = "abcd"</code> ，就有 <code>dict["dcba"] = i</code> ；如果不存在 <code>"dcba"</code> ，那么 <code>dict[word[i]]</code> 就不存在。这样，我们就可以快速判断回文。</p></li><li><p>我们把一个word，拆分为 <code>left | right</code></p></li><li><p>对于一个候选词<strong>candidate</strong>，有两种情况 <strong>left</strong> | right | <strong>candidate</strong> 和 <strong>candidate</strong> | left | <strong>right</strong></p></li><li><p>所以，如果right本身是一个回文，<code>dict[left]</code> 存在，那么 candidate 存在，我们就得到一个解。</p></li></ul><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">palindromePairs</span>(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; dict;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      string key = words[i];</span><br><span class="line">      <span class="built_in">reverse</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">      dict[key] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; words[i].<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">        string left = words[i].<span class="built_in">substr</span>(<span class="number">0</span>, k);</span><br><span class="line">        string right = words[i].<span class="built_in">substr</span>(k, words[i].<span class="built_in">size</span>() - k);</span><br><span class="line">        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(left) != dict.<span class="built_in">end</span>() &amp;&amp; dict[left] != i &amp;&amp; <span class="built_in">check</span>(right))</span><br><span class="line">          res.<span class="built_in">push_back</span>(&#123;i, dict[left]&#125;);</span><br><span class="line">        <span class="keyword">if</span> (dict.<span class="built_in">find</span>(right) != dict.<span class="built_in">end</span>() &amp;&amp; dict[right] != i &amp;&amp; <span class="built_in">check</span>(left))</span><br><span class="line">          res.<span class="built_in">push_back</span>(&#123;dict[right], i&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面的for循环漏掉一种情况 left = self， right = &quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (dict.<span class="built_in">find</span>(<span class="string">&quot;&quot;</span>) != dict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (words[i] != <span class="string">&quot;&quot;</span> &amp;&amp; <span class="built_in">check</span>(words[i])) res.<span class="built_in">push_back</span>(&#123;dict[<span class="string">&quot;&quot;</span>], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = str.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str[i++] != str[j--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 264 ms, faster than 55.35% of C++ online submissions for Palindrome Pairs. Memory Usage: 48.7 MB, less than 58.32% of C++ online submissions for Palindrome Pairs.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> String </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322. Coin Change 硬币找零</title>
      <link href="/posts/298521502/"/>
      <url>/posts/298521502/</url>
      
        <content type="html"><![CDATA[<blockquote><p>假设你有充足的不同面值的硬币，现在有人给了你一张面值为amount的纸币，你的任务是用你的硬币来给这张纸币做兑换。要求使用最少数量的硬币，如果无法找零则返回-1</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [1, 2, 5], amount = 11</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><h3 id="暴力解法dfs">1. 暴力解法DFS</h3><p>假如你有 n 个硬币的话，那么每一个节点你就有n种状态 <code>dfs(vector&lt;int&gt;&amp; coins, int amount, int count)</code>，递归的边界就是 <code>amount == 0</code>，解就是 <code>count</code></p><p>虽然可以得到正确的结果，但是显然时间复杂度太高了，存在大量的重复运算。如果，你经常做题的话，就会发现对于求最少/最多的DFS问题的时候，多半都要使用记忆搜索。</p><h3 id="记忆化搜索">2. 记忆化搜索</h3><h4 id="思路">2.1. 思路</h4><p>上面的DFS是从状态的角度去考虑的。</p><p>记忆搜索其实是DP的一个演化，与上面的DFS不同的地方在于，需要DFS返回一个int的结果，所以DFS的含义就是当前amount最小的结果。</p><p><img src="322_coin_change_tree.png" alt="322_coin_change_tree" /></p><p>从这个图，我们可以看到存在大量的重复运算，所以记忆化搜索就是利用了这一点，使用一个dp数组来存储已经算出来的结果。</p><h4 id="代码">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(coins.<span class="built_in">begin</span>(), coins.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(coins, amount, dp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dp[amount] != INT_MAX) <span class="keyword">return</span> dp[amount];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = <span class="built_in">dfs</span>(coins, amount - coins[i], dp);</span><br><span class="line">      <span class="keyword">if</span> (temp &gt;= <span class="number">0</span>) dp[amount] = <span class="built_in">min</span>(dp[amount], temp + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[amount] = (dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount]);</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">2.3. 结果</h4><p>Runtime: 76 ms, faster than 24.78% of C++ online submissions for Coin Change. Memory Usage: 12.5 MB, less than 90.31% of C++ online submissions for Coin Change.</p><h3 id="自底向上的dp">3. 自底向上的DP</h3><h4 id="思路-1">3.1. 思路</h4><p>上面的记忆化搜索的过程，可以看成是自顶向下的的递归方式，例如我们要求F(6) <span class="math inline">\(\to\)</span> F(3) <span class="math inline">\(\to\)</span> F(0)</p><p>那么，我们换一个思路来看，可不可以自底向上呢？我按照F(0) <span class="math inline">\(\to\)</span> F(1) <span class="math inline">\(\to\)</span> … <span class="math inline">\(\to\)</span> F(6)的顺序去求，最后只需要返回F(6) 就可以了啊。</p><p>DP方程式什么呢？如下所示： <span class="math display">\[\begin{aligned}F(3) &amp;= min \{F(3 - c_1), F(3 - c_2), F(3 - c_1)\} + 1 \\&amp; = min \{F(2), F(1), F(0) \} + 1 \\&amp; = min \{1, 1, 0 \} + 1 \\&amp; = 1\end{aligned}\]</span></p><h4 id="代码-1">3.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c : coins) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i - c &gt;= <span class="number">0</span> &amp;&amp; dp[i - c] != <span class="number">-1</span>)</span><br><span class="line">          dp[i] = (dp[i] &gt; <span class="number">0</span> ? <span class="built_in">min</span>(dp[i], dp[i - c] + <span class="number">1</span>) : dp[i - c] + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>超级简洁，强烈推荐！！！</p><h4 id="结果-1">3.3. 结果</h4><p>Runtime: 52 ms, faster than 70.95% of C++ online submissions for Coin Change. Memory Usage: 12.4 MB, less than 90.31% of C++ online submissions for Coin Change.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> Memory DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>301. Remove Invalid Parentheses 移除非法括号</title>
      <link href="/posts/3265272059/"/>
      <url>/posts/3265272059/</url>
      
        <content type="html"><![CDATA[<blockquote><p>删除最小数目的括号，来保证最后是合法的字符串，原字符串中可能存在字母</p></blockquote><span id="more"></span><h3 id="暴力解">1. 暴力解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()())()&quot;</span><br><span class="line">Output: [&quot;()()()&quot;, &quot;(())()&quot;]</span><br></pre></td></tr></table></figure><h4 id="思路">1.1. 思路</h4><p>有两种结果，对于括号我们可以选择删除或者不删除。可以用DFS</p><h4 id="代码">1.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(s, s.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;string&gt; result;</span><br><span class="line">  unordered_map&lt;string, <span class="keyword">int</span>&gt; visited;</span><br><span class="line">  <span class="keyword">int</span> maxlen = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (count == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(string s, <span class="keyword">int</span> curlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curlen &lt; maxlen) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(s)) &#123;</span><br><span class="line">      <span class="comment">// 如果当前长度大于最大长度，那么之前的答案都无效</span></span><br><span class="line">      <span class="keyword">if</span> (curlen &gt; maxlen) result.<span class="built_in">clear</span>();</span><br><span class="line">      result.<span class="built_in">push_back</span>(s);</span><br><span class="line">      maxlen = s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] != <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i] != <span class="string">&#x27;)&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// 删除当前节点</span></span><br><span class="line">      string temp = s.<span class="built_in">substr</span>(<span class="number">0</span>, i) + s.<span class="built_in">substr</span>(i + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (visited.<span class="built_in">find</span>(temp) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        visited.<span class="built_in">insert</span>(pair&lt;string, <span class="keyword">int</span>&gt;(temp, <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">solve</span>(temp, curlen - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">1.3. 结果</h4><p>Runtime: 148 ms, faster than 18.26% of C++ online submissions for Remove Invalid Parentheses. Memory Usage: 26.8 MB, less than 22.59% of C++ online submissions for Remove Invalid Parentheses.</p><p>显然这个解法的时间复杂度是 <span class="math inline">\(O(2^n)\)</span> ，所以我们要优化！！！</p><h3 id="优化dfs">2. 优化DFS</h3><h4 id="思路-1">2.1. 思路</h4><p>上面的解法，存在大量重复的运算，因为对于每个符号都要去计算删除/不删除它的结果，显然有的case只需要删除左括号，有的case只需要删除右括号。所以我们来优化一下。</p><p>首先，遍历字符串求得需要删除的左括号数量和右括号数量。</p><h4 id="代码-1">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">removeInvalidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left_removed = <span class="number">0</span>, right_removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) left_removed++;</span><br><span class="line">      <span class="keyword">if</span> (ch == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left_removed &gt; <span class="number">0</span>)</span><br><span class="line">          left_removed--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          right_removed++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(s, <span class="number">0</span>, left_removed, right_removed, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> vector&lt;string&gt;(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  unordered_set&lt;string&gt; result;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(string s, <span class="keyword">int</span> index, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pair, string temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> &amp;&amp; pair == <span class="number">0</span>) result.<span class="built_in">insert</span>(temp);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s[index] != <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[index] != <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">      <span class="built_in">solve</span>(s, index + <span class="number">1</span>, left, right, pair, temp + s[index]);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[index] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) <span class="built_in">solve</span>(s, index + <span class="number">1</span>, left - <span class="number">1</span>, right, pair, temp);</span><br><span class="line">        <span class="built_in">solve</span>(s, index + <span class="number">1</span>, left, right, pair + <span class="number">1</span>, temp + s[index]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (s[index] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) <span class="built_in">solve</span>(s, index + <span class="number">1</span>, left, right - <span class="number">1</span>, pair, temp);</span><br><span class="line">        <span class="keyword">if</span> (pair &gt; <span class="number">0</span>)</span><br><span class="line">          <span class="built_in">solve</span>(s, index + <span class="number">1</span>, left, right, pair - <span class="number">1</span>, temp + s[index]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">2.3. 结果</h4><p>Runtime: 64 ms, faster than 47.11% of C++ online submissions for Remove Invalid Parentheses. Memory Usage: 47.5 MB, less than 12.91% of C++ online submissions for Remove Invalid Parentheses.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>297. Serialize and Deserialize Binary Tree 二叉树的序列化</title>
      <link href="/posts/3296169899/"/>
      <url>/posts/3296169899/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实现一个二叉树的序列化和反序列化</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">You may serialize the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">as &quot;[1,2,3,null,null,4,5]&quot;</span><br></pre></td></tr></table></figure><h3 id="递归解法">1. 递归解法</h3><p>将一个二叉树序列化，其实就是遍历，可以用先序遍历的递归解法来得到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot; &quot;</span> + <span class="built_in">serialize</span>(root-&gt;left) + <span class="string">&quot; &quot;</span> +</span><br><span class="line">         <span class="built_in">serialize</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化，比较麻烦，因为涉及到把字符串转为数字。一开始，我是对字符串进行处理，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Mydeserialize</span><span class="params">(string&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() &gt; <span class="number">1</span>) data = data.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 找出数字</span></span><br><span class="line">    <span class="keyword">int</span> pos = data.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>);  <span class="comment">// 这里使用的是逗号分隔，上面的序列化是&#x27; &#x27;分隔</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="built_in">stoi</span>(data.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">    data = data.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    root-&gt;left = <span class="built_in">Mydeserialize</span>(data);</span><br><span class="line">    root-&gt;right = <span class="built_in">Mydeserialize</span>(data);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，最麻烦的的部分就是转数字的操作。由于原题目给的参数是string，我们要对字符串进行改变，所以就只好写一个Mydeserialize，参数为引用。</p><p>在转数字的时候，存在大量的substr操作，浪费很多时间。看了讨论区中的高票答案，使用了字符串流操作。由于string是遇到空格结束输入，所以可以利用这一点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">Mydeserialize</span><span class="params">(istringstream &amp;in)</span> </span>&#123;</span><br><span class="line">  string val;</span><br><span class="line">  in &gt;&gt; val;  <span class="comment">// 流操作，遇到&#x27; &#x27;停止</span></span><br><span class="line">  <span class="keyword">if</span> (val == <span class="string">&quot;#&quot;</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(val));</span><br><span class="line">  root-&gt;left = <span class="built_in">Mydeserialize</span>(in);</span><br><span class="line">  root-&gt;right = <span class="built_in">Mydeserialize</span>(in);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比使用字符串流操作，节省了大量的时间。</p><h3 id="非递归解法">2. 非递归解法</h3><p>非递归的解法，就要使用队列来做层次遍历了，序列化如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">  string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  queue&lt;TreeNode*&gt; q;</span><br><span class="line">  q.<span class="built_in">push</span>(root);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>)</span><br><span class="line">      result += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      result += <span class="built_in">to_string</span>(temp-&gt;val);</span><br><span class="line">      q.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">      q.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!q.<span class="built_in">empty</span>()) result += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，反序列化的时候，对数字的判断就很关键。我是先把所有的结点放入<code>vector&lt;TreeNode*&gt; tree;</code> 然后按照层次遍历的规则，去把各个节点之间的关系找到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">int</span> begin = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">  vector&lt;TreeNode*&gt; tree;</span><br><span class="line">  <span class="comment">// 将结点放入vector中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data[i] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">      tree.<span class="built_in">push_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">      begin = i + <span class="number">2</span>;  <span class="comment">// #号后面的逗号也跳过</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到数字</span></span><br><span class="line">    <span class="keyword">if</span> (data[i] == <span class="string">&#x27;,&#x27;</span> &amp;&amp; i &gt; begin) &#123;</span><br><span class="line">      val = <span class="built_in">stoi</span>(data.<span class="built_in">substr</span>(begin, i - begin));</span><br><span class="line">      tree.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(val));</span><br><span class="line">      begin = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  queue&lt;TreeNode*&gt; q;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(tree[k++]);</span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    TreeNode* temp = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">    temp-&gt;left = tree[k];</span><br><span class="line">    temp-&gt;right = tree[k + <span class="number">1</span>];</span><br><span class="line">    q.<span class="built_in">push</span>(tree[k++]);</span><br><span class="line">    q.<span class="built_in">push</span>(tree[k++]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>295. Find Median from Data Stream 找出数据流的中位数</title>
      <link href="/posts/3262262637/"/>
      <url>/posts/3262262637/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计一个寻找中位数的数据结构，初始为空，支持以下两个操作：</p><ul><li>增加一个元素，要求在log(n)时间内完成</li><li>返回当前元素集合的中位数，要求在常数时间内完成</li></ul></blockquote><span id="more"></span><h3 id="思路">1. 思路</h3><p>这道题我稍微改了下，LeetCode上面并没有要求时间复杂度，其实如果它加了时间复杂度的要求反而更容易让人联想到用优先队列来做。</p><p>我们可以通过设置一个最大堆，一个最小堆来实现上面的要求。最大堆来存储前半部分的数，最小堆用来存储后半部分的数，所以中位数就可以通过访问堆顶元素来获得。需要注意的是，<strong>最大堆的size始终保持&gt;=最小堆的size</strong>，如果最大堆和最小堆都可以比对方多一个元素，这就可能导致最大堆有0个元素，最小堆有一个元素。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">  <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; num &gt; minHeap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = minHeap.<span class="built_in">top</span>();</span><br><span class="line">        minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        maxHeap.<span class="built_in">push</span>(temp);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num &gt;= maxHeap.<span class="built_in">top</span>())</span><br><span class="line">        minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = maxHeap.<span class="built_in">top</span>();</span><br><span class="line">        maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">        maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        minHeap.<span class="built_in">push</span>(temp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1.0</span> * (maxHeap.<span class="built_in">top</span>() + minHeap.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> maxHeap.<span class="built_in">top</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;</span><br><span class="line">  priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 164 ms, faster than 94.62% of C++ online submissions for Find Median from Data Stream. Memory Usage: 42.5 MB, less than 86.63% of C++ online submissions for Find Median from Data Stream.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> Priority Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>289. Game of Life 生命游戏</title>
      <link href="/posts/4133133870/"/>
      <url>/posts/4133133870/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F">康威生命游戏</a>，使用一个m*n的数组来表示细胞，每个细胞有2种状态：1表示活细胞，0表示死细胞。下一个周期细胞的状态遵循如下规则：</p><ul><li>如果活细胞周围八个位置的活细胞数少于两个，则该活细胞死亡</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该活细胞仍然存活</li><li>如果活细胞周围八个位置有超过三个活细胞，则该活细胞死亡</li><li>如果死细胞周围正好有三个活细胞，则该死细胞复活</li></ul><p>要求：使用 O(1) 的空间复杂度，求出细胞更新后的状态</p></blockquote><span id="more"></span><h3 id="思路">1. 思路</h3><p>这道题的解法不难，关键在于O(1)的空间复杂度问题。我们 可以使用状态机来解。我定义的在状态机为：</p><ul><li>-1：活细胞变成死细胞</li><li>2：死细胞变成活细胞</li></ul><p>这样在遍历一个细胞的8个邻位置的时候，就可以判断 <code>abs(board[newX][newY]) == 1</code>。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) <span class="built_in">change</span>(board, i, j, m, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="number">-1</span>)</span><br><span class="line">          board[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="number">2</span>)</span><br><span class="line">          board[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> step[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                      &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,  &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,   &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,  &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> liveNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> newX = x + step[i][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> newY = y + step[i][<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n &amp;&amp;</span><br><span class="line">          <span class="built_in">abs</span>(board[newX][newY]) == <span class="number">1</span>)</span><br><span class="line">        liveNum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (board[x][y] == <span class="number">0</span> &amp;&amp; liveNum == <span class="number">3</span>) board[x][y] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (board[x][y] == <span class="number">1</span> &amp;&amp; (liveNum &lt; <span class="number">2</span> || liveNum &gt; <span class="number">3</span>)) board[x][y] = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Game of Life. Memory Usage: 8.7 MB, less than 95.57% of C++ online submissions for Game of Life.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>273. Integer to English Words 整数转英文</title>
      <link href="/posts/2011209242/"/>
      <url>/posts/2011209242/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个非负的整数，返回它的英文表达</p></blockquote><span id="more"></span><h3 id="思路">1. 思路</h3><p>这个题，不是很难，重点是要明白美国人的计数方式，他们数字每3个一组，然后就是单位晋级(千，百万，亿) 所以，我们可以使用一个字符串num2str来保存结果，从后向前遍历字符串，每3个一组。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;Zero&quot;</span>;</span><br><span class="line">    vector&lt;string&gt; oneToNineteen&#123;<span class="string">&quot;One&quot;</span>,       <span class="string">&quot;Two&quot;</span>,      <span class="string">&quot;Three&quot;</span>,   <span class="string">&quot;Four&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;Five&quot;</span>,      <span class="string">&quot;Six&quot;</span>,      <span class="string">&quot;Seven&quot;</span>,   <span class="string">&quot;Eight&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;Nine&quot;</span>,      <span class="string">&quot;Ten&quot;</span>,      <span class="string">&quot;Eleven&quot;</span>,  <span class="string">&quot;Twelve&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;Thirteen&quot;</span>,  <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>,</span><br><span class="line">                                 <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; twenty2Ninty&#123;<span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>,  <span class="string">&quot;Forty&quot;</span>,  <span class="string">&quot;Fifty&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;Sixty&quot;</span>,  <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; big&#123;<span class="string">&quot;Thousand&quot;</span>, <span class="string">&quot;Million&quot;</span>, <span class="string">&quot;Billion&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    string num2str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; num != <span class="number">0</span>; i += <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> one = num % <span class="number">10</span>;</span><br><span class="line">      num /= <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> ten = num % <span class="number">10</span>;</span><br><span class="line">      num /= <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> hundred = num % <span class="number">10</span>;</span><br><span class="line">      num /= <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span> ((one || ten || hundred) &amp;&amp; i / <span class="number">3</span> &gt; <span class="number">0</span>)</span><br><span class="line">        num2str = big[i / <span class="number">3</span> - <span class="number">1</span>] + <span class="string">&quot; &quot;</span> + num2str;</span><br><span class="line">      <span class="keyword">if</span> (ten != <span class="number">1</span> &amp;&amp; one &gt; <span class="number">0</span>) num2str = oneToNineteen[one - <span class="number">1</span>] + <span class="string">&quot; &quot;</span> + num2str;</span><br><span class="line">      <span class="keyword">if</span> (ten == <span class="number">1</span>) num2str = oneToNineteen[one + <span class="number">9</span>] + <span class="string">&quot; &quot;</span> + num2str;</span><br><span class="line">      <span class="keyword">if</span> (ten &gt;= <span class="number">2</span>) num2str = twenty2Ninty[ten - <span class="number">2</span>] + <span class="string">&quot; &quot;</span> + num2str;</span><br><span class="line">      <span class="keyword">if</span> (hundred &gt;= <span class="number">1</span>)</span><br><span class="line">        num2str = oneToNineteen[hundred - <span class="number">1</span>] + <span class="string">&quot; &quot;</span> + <span class="string">&quot;Hundred&quot;</span> + <span class="string">&quot; &quot;</span> + num2str;</span><br><span class="line">    &#125;</span><br><span class="line">    num2str[num2str.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> num2str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 8 ms, faster than 76.69% of C++ online submissions for Integer to English Words. Memory Usage: 9.4 MB, less than 63.64% of C++ online submissions for Integer to English Words.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>269. Alien Dictionary 外星字典</title>
      <link href="/posts/996259444/"/>
      <url>/posts/996259444/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有一种外星文字，但是并不知道字母之间的顺序。现在存在一组没有空字符串的有序的单词，我们要寻找出字母之间的顺序。如果不存在一个有效的顺序，返回一个空字符串。</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;wrt&quot;,</span><br><span class="line">  &quot;wrf&quot;,</span><br><span class="line">  &quot;er&quot;,</span><br><span class="line">  &quot;ett&quot;,</span><br><span class="line">  &quot;rftt&quot;</span><br><span class="line">]</span><br><span class="line">Output: &quot;wertf&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  &quot;z&quot;,</span><br><span class="line">  &quot;x&quot;,</span><br><span class="line">  &quot;z&quot;</span><br><span class="line">] </span><br><span class="line"></span><br><span class="line">Output: &quot;&quot; </span><br><span class="line"></span><br><span class="line">Explanation: The order is invalid, so return &quot;&quot;.</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>首先要明白题意，怎么去确定字母之间的顺序。在Example 1中 <code>wrt</code> 排在了 <code>wrf</code> 前面，由于 <code>wr</code> 相同，所以就代表了 t 要在 f 的前面。<font color="red">这里要注意一个超级大坑：我们只能知道 t 排在 f 的前面， w 和 r 的顺序千万不能想当然。</font>简单说，就是只能纵向比，不能横向比。</p><p>这么解释完了，自然就会想到拓扑排序。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">alienOrder</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, unordered_set&lt;<span class="keyword">char</span>&gt;&gt; graph;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; inDegree;  <span class="comment">// 入度</span></span><br><span class="line">    string ans;</span><br><span class="line">    queue&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step1. 初始入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        inDegree[words[i][j]] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step2. 建图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      string cur = words[i];</span><br><span class="line">      string next = words[i + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">int</span> len = <span class="built_in">min</span>(cur.<span class="built_in">size</span>(), next.<span class="built_in">size</span>());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur[j] != next[j]) &#123;</span><br><span class="line">          <span class="keyword">char</span> s = cur[j], v = next[j];</span><br><span class="line">          <span class="keyword">if</span> (graph[s].<span class="built_in">find</span>(v) == graph[s].<span class="built_in">end</span>()) &#123;</span><br><span class="line">            graph[s].<span class="built_in">insert</span>(v);</span><br><span class="line">            inDegree[v]++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step3. 拓扑排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : inDegree) &#123;</span><br><span class="line">      <span class="keyword">if</span> (it.second == <span class="number">0</span>) q.<span class="built_in">push</span>(it.first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">char</span> temp = q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      ans += temp;</span><br><span class="line">      <span class="keyword">if</span> (graph[temp].<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[temp]) &#123;</span><br><span class="line">          inDegree[v]--;</span><br><span class="line">          <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans.<span class="built_in">size</span>() == inDegree.<span class="built_in">size</span>() ? ans : <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 8 ms, faster than 85.04% of C++ online submissions for Alien Dictionary. Memory Usage: 9.5 MB, less than 45.94% of C++ online submissions for Alien Dictionary.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> Graph </tag>
            
            <tag> Topological sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>253. Meeting Rooms II 会议室II</title>
      <link href="/posts/2243778836/"/>
      <url>/posts/2243778836/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一些会议的起始时间和结束时间 <code>[[s1,e1],[s2,e2],...]</code> (si &lt; ei)，找出所需要的最少的会议室数目</p></blockquote><span id="more"></span><h3 id="优先队列">1. 优先队列</h3><h4 id="思路">1.1. 思路</h4><p>我们遍历各个会议时间，需不需要开一个新的会议时间，取决于最早结束的会议的时间是否小于当前会议的开始时间。所以，问题的关键就变成了如何记录：<strong>最早结束的会议的时间</strong>。</p><p>每次要找当前对早的时间，时间复杂度尽可能的低。咦，最小堆呀！<font color="red"> 获得最小的元素是O(1)的时间复杂度</font>。使用最小堆来记录会议的最早结束时间，如果Si小于堆顶元素，那么会议 i 就需要一个新的会议室(只需要把ei入堆)，最后堆的size就是会议室的数目。</p><h4 id="代码">1.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; rooms;</span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">         [](Interval a, Interval b) &#123; <span class="keyword">return</span> a.start &lt; b.start; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (Interval temp : intervals) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!rooms.<span class="built_in">empty</span>() &amp;&amp; temp.start &gt;= rooms.<span class="built_in">top</span>()) &#123;</span><br><span class="line">        rooms.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      rooms.<span class="built_in">push</span>(temp.end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rooms.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="哈希表">2. 哈希表</h3><h4 id="思路-1">2.1. 思路</h4><p>看了讨论区，这个解法真的讨巧，O(n)的时间内就可以解决。 把时间拉成一条轴，hash['开始时间']加一，hash['结束时间']减一 最后，我们遍历这个时间轴 <code>rooms += hash['时间']</code>，然后<code>res = max(res, rooms)</code>。很好理解，因为没遇到一个开始时间增加相应房间，遇到结束时间，减少相应的房间 。所以rooms的最大值就是我们的答案。</p><h4 id="代码-1">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; times;</span><br><span class="line">    <span class="keyword">int</span> rooms = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Interval a : intervals) &#123;</span><br><span class="line">      times[a.start]++;</span><br><span class="line">      times[a.end]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : times) &#123;</span><br><span class="line">      rooms += it.second;</span><br><span class="line">      res = <span class="built_in">max</span>(res, rooms);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> priority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238. Product of Array Except Self 除本身之外的数组乘积</title>
      <link href="/posts/1464730773/"/>
      <url>/posts/1464730773/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个长度大于1的数组 <code>nums</code>，返回一个数组 <code>output</code>，其中 <code>output[i]</code> 等于除了 <code>nums[i]</code> 之外的所有元素的乘积。要求：1）不使用除法；2）时间复杂度为 <span class="math inline">\(O(n)\)</span>，空间复杂度为 <span class="math inline">\(O(1)\)</span></p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>当我们遍历到 <code>nums[k]</code> 的时候，我们知道k之前的所有元素，可以轻松得到 <code>nums[k]</code> 之前的乘积结果。那么，如果反向遍历到 <code>nums[k]</code> 的时候，我们就知道k之后的所有元素，可以得到 <code>nums[k]</code> 之后的乘积结果。将这两个结果乘起来，就是我们要的答案。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      result[i] = temp;  <span class="comment">// result[i]保存i之前的乘积结果</span></span><br><span class="line">      temp *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      result[i] *= temp;  <span class="comment">// 之前的乘积结果 * 后半部分</span></span><br><span class="line">      temp *= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="改进">3. 改进</h3><p>上面的代码用了两个for循环，实际上可以压缩到一个for循环中，就可以解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">1</span>, back = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      result[i] *= front;  <span class="comment">// result[i]保存i之前的乘积结果</span></span><br><span class="line">      result[n - <span class="number">1</span> - i] *= back;</span><br><span class="line">      front *= nums[i];</span><br><span class="line">      back *= nums[n - <span class="number">1</span> - i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>224. Basic Calculator 基本计算器</title>
      <link href="/posts/693970184/"/>
      <url>/posts/693970184/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实现一个基本的计算器，表达式中只存在 () 、+、- 和非负整数以及空格</p></blockquote><span id="more"></span><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>这道题为后面的几道实现计算器的题做了铺垫，题目中只要求了括号和加减运算，所以不用考虑符号的优先级。只需要用一个符号栈和一个数字栈来辅助，以及一个sign变量来表示正负。</p><ul><li>如果遇到了数字，由于可能是个多位数，所以我们要用while循环把之后的数字都读进来，然后用sign*num来更新结果res。</li><li>如果遇到了加号，则将sign赋值为1；遇到了减号，则赋值为-1</li><li>如果遇到了 ( ，则将res加入数字栈，sign加入符号栈，并且令res = 0</li><li>如果遇到了 ) ，则res乘以符号栈顶元素，加上数字栈顶元素，2个栈出栈</li></ul><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; nums, ops;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(s[i])) num = num * <span class="number">10</span> + (s[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        res += sign * num;</span><br><span class="line">        --i;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">        nums.<span class="built_in">push</span>(res);</span><br><span class="line">        ops.<span class="built_in">push</span>(sign);</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        sign = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        res *= ops.<span class="built_in">top</span>();</span><br><span class="line">        res += nums.<span class="built_in">top</span>();</span><br><span class="line">        ops.<span class="built_in">pop</span>();</span><br><span class="line">        nums.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 12 ms, faster than 99.32% of C++ online submissions for Basic Calculator. Memory Usage: 10.4 MB, less than 98.58% of C++ online submissions for Basic Calculator.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>200. Number of Islands 岛屿的数量</title>
      <link href="/posts/1391363763/"/>
      <url>/posts/1391363763/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个图，其中上、下、左、右四个方向的1构成岛屿，计算出整个图中岛屿的数目</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>这是一道BFS和DFS的入门题，没什么好说的，直接套用模板就可以了</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (!row) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// 进行bfs</span></span><br><span class="line">          ++num;</span><br><span class="line">          grid[i][j] = <span class="string">&#x27;0&#x27;</span>;  <span class="comment">// 节省visit数组的空间</span></span><br><span class="line">          queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">          q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">          <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 这里一开始用的是auto，经过提交发现时间复杂度上面</span></span><br><span class="line">            <span class="comment">// 慢了4s，还是不要偷懒，用pair吧</span></span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; temp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> r = temp.first, c = temp.second;</span><br><span class="line">            <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">              q.<span class="built_in">push</span>(&#123;r - <span class="number">1</span>, c&#125;);</span><br><span class="line">              grid[r - <span class="number">1</span>][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r + <span class="number">1</span> &lt; row &amp;&amp; grid[r + <span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">              q.<span class="built_in">push</span>(&#123;r + <span class="number">1</span>, c&#125;);</span><br><span class="line">              grid[r + <span class="number">1</span>][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">              q.<span class="built_in">push</span>(&#123;r, c - <span class="number">1</span>&#125;);</span><br><span class="line">              grid[r][c - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; col &amp;&amp; grid[r][c + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">              q.<span class="built_in">push</span>(&#123;r, c + <span class="number">1</span>&#125;);</span><br><span class="line">              grid[r][c + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 16 ms, faster than 70.01% of C++ online submissions for Number of Islands. Memory Usage: 10.7 MB, less than 86.56% of C++ online submissions for Number of Islands.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU Cache 最近最少使用</title>
      <link href="/posts/539281779/"/>
      <url>/posts/539281779/</url>
      
        <content type="html"><![CDATA[<blockquote><p>设计并实现一个 <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a> 的数据结构，支持<code>get</code> and <code>put</code>两种方法。 <code>get(key)</code> - 获得cache中key值的value，如果不存在返回-1，key保证正数 <code>put(key, value)</code> - 将cache中key值对应的数设置为value，如果不存在key则插入(key, value)这个数据 要求：时间复杂度为 <span class="math inline">\(O(1)\)</span></p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = new LRUCache( 2 /* capacity */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // returns 1</span><br><span class="line">cache.put(3, 3);    // evicts key 2</span><br><span class="line">cache.get(2);       // returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    // evicts key 1</span><br><span class="line">cache.get(1);       // returns -1 (not found)</span><br><span class="line">cache.get(3);       // returns 3</span><br><span class="line">cache.get(4);       // returns 4</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>首先我们要明白什么是Least Recently Used (LRU) ，它是内存管理的一种页面置换算法，直白翻译就是<strong>最近最少使用</strong>。因为cache容量有限，所以当我们放入一个元素的时候，需要淘汰一个最长时间没有被使用的元素。</p><p>如何实现元素在cache中的新旧关系呢？最简单的用一个数组按照访问顺序来存放，可是数组移动操作的时间复杂度是 <span class="math inline">\(O(n)\)</span> ，题目中要求的时间复杂度是 <span class="math inline">\(O(1)\)</span> ，这个时候你有没有灵光一闪！<strong>链表！</strong></p><p>可是，链表的移动操作虽然是 <span class="math inline">\(O(1)\)</span> 的，但是查找操作 (get) 是 <span class="math inline">\(O(n)\)</span> 的啊，我们的方法是不是错了呢？这个时候我们就需要转换一下思维了，使用一个hashmap&lt;int, ListNode&gt;就完美解决这个问题了！</p><p>另外一点，因为单向链表删除节点的时候需要前向结点的指针，所以使用<strong>双向链表</strong>更好的解决问题。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) : <span class="built_in">capacity</span>(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) != cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      <span class="built_in">use</span>(key);</span><br><span class="line">      <span class="keyword">return</span> cache[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">use</span>(key);</span><br><span class="line">    cache[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> capacity;                                 <span class="comment">// 容量</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt; recent;                             <span class="comment">// 双向链表</span></span><br><span class="line">  unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cache;                <span class="comment">// 用来表示(key, value)对</span></span><br><span class="line">  unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;::iterator&gt; pos;  <span class="comment">// 用来查找结点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义use函数，如果该节点被使用了，那么放到链表头</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先删除，再添加到表头</span></span><br><span class="line">    <span class="keyword">if</span> (pos.<span class="built_in">find</span>(key) != pos.<span class="built_in">end</span>()) recent.<span class="built_in">erase</span>(pos[key]);</span><br><span class="line">    <span class="comment">// 判断空间是否满了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (recent.<span class="built_in">size</span>() &gt;= capacity) &#123;</span><br><span class="line">      <span class="keyword">int</span> old = recent.<span class="built_in">back</span>();</span><br><span class="line">      recent.<span class="built_in">pop_back</span>();</span><br><span class="line">      cache.<span class="built_in">erase</span>(old);</span><br><span class="line">      pos.<span class="built_in">erase</span>(old);</span><br><span class="line">    &#125;</span><br><span class="line">    recent.<span class="built_in">push_front</span>(key);</span><br><span class="line">    pos[key] = recent.<span class="built_in">begin</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 140 ms, faster than 31.70% of C++ online submissions for LRU Cache. Memory Usage: 40.7 MB, less than 13.82% of C++ online submissions for LRU Cache.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142. Linked List Cycle II 单链表中的环II</title>
      <link href="/posts/618148813/"/>
      <url>/posts/618148813/</url>
      
        <content type="html"><![CDATA[<blockquote><p>检查一个链表是否有环，并且返回环的起点</p></blockquote><span id="more"></span><h3 id="解析">1. 解析</h3><p>这道题与前一道题的区别在于，需要返回环的起始位置。方法依然使用前一道题的快慢指针，现在我们规定链表的起始位置为 <code>Head</code>，快慢指针相遇的结点为 <code>Meeting</code>，环的起始结点为 <code>Begin</code></p><p><code>Head</code> <span class="math inline">\(\to\)</span> <code>Begin</code> 的距离为 <span class="math inline">\(L1\)</span></p><p><code>Begin</code> <span class="math inline">\(\to\)</span> <code>Meeting</code> 的距离为 <span class="math inline">\(L2\)</span></p><p><code>Meeting</code> <span class="math inline">\(\to\)</span> <code>Begin</code> 的距离为 <span class="math inline">\(L3\)</span></p><p>慢指针走过的距离为：<span class="math inline">\(L1 + L2\)</span></p><p>快指针走过的距离为：<span class="math inline">\(L1 + n*(L2 + L3)\)</span></p><p>因为快指针的速度为慢指针的速度的两倍，所以有：<span class="math inline">\(2(L1 + L2) = L1 + n*(L2 + L3)\)</span>，我们令 $C = L2 + L3 $</p><p>化简得到：<span class="math inline">\(L1 - L3 = (n - 1)C\)</span></p><p>这样，我们就可以让 <code>p</code> 和 <code>q</code> 同时从 <code>Head</code> 和 <code>Meeting</code> 出发，这样 <code>p</code> 和 <code>q</code> 一定在 <code>Begin</code> 处相遇。因为如果让它们两个都先走 <span class="math inline">\(L3\)</span> 步，此时 <code>q</code> 到达了 <code>Begin</code> 处，<code>p</code> 距离 <code>Begin</code> 还有 <span class="math inline">\(L1 - L3 = (n - 1)C\)</span> 的距离，显而易见剩下的距离都是环的周长，最终相遇点一定是 <code>Begin</code></p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head, *beg = head;</span><br><span class="line">    <span class="keyword">while</span> (slow &amp;&amp; fast) &#123;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      fast = (fast-&gt;next) ? fast-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (slow &amp;&amp; slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slow != fast) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (beg &amp;&amp; slow) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beg == slow) <span class="keyword">return</span> beg;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      beg = beg-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 12 ms, faster than 75.86% of C++ online submissions for Linked List Cycle II. Memory Usage: 9.6 MB, less than 100.00% of C++ online submissions for Linked List Cycle II.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141. Linked List Cycle 单链表中的环</title>
      <link href="/posts/2856794456/"/>
      <url>/posts/2856794456/</url>
      
        <content type="html"><![CDATA[<blockquote><p>检查一个链表是否有环</p></blockquote><span id="more"></span><p><img src="circularlinkedlist.png" alt="circularlinkedlist" /></p><h3 id="哈希表">1. 哈希表</h3><p>使用 <code>unordered_set</code> 对指针进行哈希，空间复杂度是O(n)的</p><h4 id="代码">1.1. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;ListNode *&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span> &amp;&amp; s.<span class="built_in">find</span>(head) == s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      s.<span class="built_in">insert</span>(head);</span><br><span class="line">      head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (head == <span class="literal">nullptr</span> ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">1.2. 结果</h4><p>Runtime: 20 ms, faster than 29.57% of C++ online submissions for Linked List Cycle. Memory Usage: 11.9 MB, less than 10.00% of C++ online submissions for Linked List Cycle.</p><h3 id="快慢指针">2. 快慢指针</h3><h4 id="思路">2.1. 思路</h4><p>这道题是快慢指针的经典应用。只需要设两个指针，一个每次走一步的慢指针和一个每次走两步的快指针，如果链表里有环的话，两个指针最终肯定会相遇。我们可以想象跳格子游戏，如果存在环，那么游戏就是无限制的。但是快指针每次比慢指针快一个格子，快的只能一个一个格子的去追慢的，最后必然在一个格子相遇！</p><h4 id="代码-1">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">      slow = slow-&gt;next;</span><br><span class="line">      fast = fast-&gt;next-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">2.3. 结果</h4><p>Runtime: 12 ms, faster than 99.40% of C++ online submissions for Linked List Cycle. Memory Usage: 9.8 MB, less than 52.83% of C++ online submissions for Linked List Cycle.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. Copy List with Random Pointer 拷贝带有随机指针的链表</title>
      <link href="/posts/3878943710/"/>
      <url>/posts/3878943710/</url>
      
        <content type="html"><![CDATA[<blockquote><p>带有random指针的链表，做一个深拷贝</p></blockquote><span id="more"></span><p><img src="1470150906153-2yxeznm.png" alt="1470150906153-2yxeznm" /></p><h3 id="解析">1. 解析</h3><p>首先我们要明白什么是深拷贝，下面来介绍一下<strong>深拷贝和浅拷贝</strong>。</p><p>首先这个概念是针对<strong>指针的</strong></p><ul><li>浅拷贝：只拷贝指针地址，意思就是两个指针指向同一个地址</li><li>深拷贝：先new一个新的内存空间，然后把数据复制到新的内存空间中</li></ul><p>所以，如果是简单的列表，那么我们只需要从头到尾遍历下来，new出对应个数的Node，并把它们的连接关系设置好就可以了，但是这道题目中每个节点Node出现了Random属性，也就意味着可能当前结点Node所依赖的那个Random对应的结点还没有被创建出来。</p><h3 id="递归解法">2. 递归解法</h3><h4 id="解析-1">2.1. 解析</h4><p>使用一个map来记录当前Node是否被创建，然后就可以从根节点开始递归拷贝</p><h4 id="代码">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 这里有个小坑，如果使用unordered_map的话，需要用int即val的值作为key</span></span><br><span class="line">  <span class="comment">// 因为指针好像只有less，没有hash</span></span><br><span class="line">  map&lt;Node*, Node*&gt; vis;</span><br><span class="line">  <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (vis.<span class="built_in">find</span>(head) != vis.<span class="built_in">end</span>()) <span class="keyword">return</span> vis[head];</span><br><span class="line">    Node* root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    vis[head] = root;  <span class="comment">// 把head添加到vis</span></span><br><span class="line">    root-&gt;val = head-&gt;val;</span><br><span class="line">    root-&gt;next = <span class="built_in">copyRandomList</span>(head-&gt;next);      <span class="comment">// 递归拷贝next</span></span><br><span class="line">    root-&gt;random = <span class="built_in">copyRandomList</span>(head-&gt;random);  <span class="comment">// 递归拷贝random</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="插入法">3. 插入法</h3><h4 id="解析-2">3.1. 解析</h4><p>上面的递归方法的空间复杂度是 <span class="math inline">\(O(n)\)</span> ，下面这个方法可以把空间复杂度降到 <span class="math inline">\(O(1)\)</span></p><p><img src="221027256064414.jpg" alt="221027256064414" /></p><p>我们来看上面这个图，先遍历一遍list创建每一个node的副本，并且将副本插入到node的后面；然后再遍历一遍来将random的值赋予新创建的结点；最后，遍历把新创建的结点拿出来。</p><p>总共3步，完美的解决的问题，佩服想出这个方法的大神的思维！！！</p><h4 id="代码-1">3.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    Node *p = head, *q, *root;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// Step1 新建结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">      temp-&gt;val = p-&gt;val;</span><br><span class="line">      temp-&gt;next = p-&gt;next;</span><br><span class="line">      p-&gt;next = temp;</span><br><span class="line">      p = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step2 赋值random</span></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      p-&gt;next-&gt;random = (p-&gt;random != <span class="literal">nullptr</span>) ? p-&gt;random-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">      p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step3 拆分</span></span><br><span class="line">    p = head;</span><br><span class="line">    q = head-&gt;next;</span><br><span class="line">    root = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      p-&gt;next = q-&gt;next;</span><br><span class="line">      q-&gt;next = (q-&gt;next != <span class="literal">nullptr</span>) ? q-&gt;next-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>76. Minimum Window Substring 最小窗口子串</title>
      <link href="/posts/813452099/"/>
      <url>/posts/813452099/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给一个字符串S和一个字符串T，在字符串S中寻找一个窗口，要求改窗口包含字符串T中的所有字母，并且窗口最小。如果不存在这样的窗口，则返回""。</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;</span><br><span class="line">Output: &quot;BANC&quot;</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>因为ASCILL编码总共有128个字符，所以使用<code>vector&lt;int&gt; dic(128, 0)</code>来统计T中字符出现的次数，用一个变量<code>count</code>表示T中字符的总数。然后遍历字符串S：</p><ul><li>如果<code>dic[s[i]] &gt; 0</code>，表示当前字母是在T中出现的，所以<code>count--</code></li><li>令 <code>dic[s[i]]--</code> 表示当前字母被访问过了。</li><li>如果<code>count == 0</code> ，表示当前的窗口里面出现了T中的所有字符。此时因为遍历到字母<code>s[i]</code>，所以右边界自然就是i，关键在于左边界的确定。因为之前我们让每一个<code>s[i]</code>对应的<code>dic[s[i]]</code>都进行了减1操作，所以如果<code>s[i]</code>没有出现在字符串T中，那么它的<code>dic[s[i]]</code>一定是一个负数；在T中出现过的字母<code>dic[s[i]] = 0</code>基于这一特点，我们可以寻找到左边界。</li></ul><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dic</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, minLen = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, count = t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : t) dic[ch]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dic[s[i]] &gt; <span class="number">0</span>) count--;</span><br><span class="line">      dic[s[i]]--;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> currentLen = i - left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (currentLen &lt; minLen) &#123;</span><br><span class="line">          minLen = currentLen;</span><br><span class="line">          begin = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dic[s[left]] == <span class="number">0</span>) count++;</span><br><span class="line">        dic[s[left]]++;  <span class="comment">// 因为left移动，所以释放当前字母，恢复它的dic值</span></span><br><span class="line">        left++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (minLen == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(begin, minLen));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 8 ms, faster than 99.50% of C++ online submissions for Minimum Window Substring. Memory Usage: 10 MB, less than 50.00% of C++ online submissions for Minimum Window Substring.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Hard </tag>
            
            <tag> Sliding Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75. Sort Colors 颜色排序</title>
      <link href="/posts/1772571387/"/>
      <url>/posts/1772571387/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有红、白、蓝三种颜色，分别对应0、1、2。给定一个长度为 n 的颜色数组，将其排序。时间复杂度为 <span class="math inline">\(O(n)\)</span>，空间复杂度为 <span class="math inline">\(O(1)\)</span></p></blockquote><span id="more"></span><h3 id="分析">1. 分析</h3><p>题目给的提示可以遍历两遍数组，第一遍统计0、1、2的数目，第二遍更新原数组，按个数分别赋上 0，1，2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) cnt[nums[i]]++;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt[i]; j++) nums[k++] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法虽然是 <span class="math inline">\(O(n)\)</span> 的，但不是最优的，其实只需要遍历一遍就可以了，因为只有3个数，我们只需要确保 0 和 2 的位置是正确的，那么 1 的位置自然就是正确的。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> red = <span class="number">0</span>, blue = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= blue; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">swap</span>(nums[red++], nums[i]);  <span class="comment">// 这里i不需要变，因为red只能是1</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">swap</span>(nums[blue--], nums[i--]);  <span class="comment">// 这里i需要减一，因为可能换来0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Sort Colors. Memory Usage: 8.7 MB, less than 18.21% of C++ online submissions for Sort Colors.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>71. Simplify Path 简化路径</title>
      <link href="/posts/4010517008/"/>
      <url>/posts/4010517008/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这道题的描述非常难懂，通过例子我们可以总结出来规律，中间是 "." 直接去掉，是 ".." 去掉上一级的路径，同时只保留一个 "/"。</p></blockquote><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;/home/&quot;</span><br><span class="line">Output: &quot;/home&quot;</span><br><span class="line"></span><br><span class="line">Input: &quot;/../&quot;</span><br><span class="line">Output: &quot;/&quot;</span><br><span class="line"></span><br><span class="line">Input: &quot;/a//b////c/d//././/..&quot;</span><br><span class="line">Output: &quot;/a/b/c&quot;</span><br><span class="line"></span><br><span class="line">Input: &quot;/a/../../b/../c//.//&quot;</span><br><span class="line">Output: &quot;/c&quot;</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>这道题的关键其实就是分隔符 "/" ，我们将字符串用 "/" 来分隔，然后判断分隔的字符的情况即可。这里有一个知识点就是字符流 (stringstream) ，流处理是一个很重要的知识点，最近在公司的项目中经常要用到流，日后有时间专门写一个关于流的文章总结一下。</p><p>c++中有一个专门处理字符流的函数 <code>istream&amp; getline (istream&amp; is, string&amp; str, char delim);</code> delim是指定的分隔符。这道题中我们可以令 delim 为 "/"</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, path, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (path == <span class="string">&quot;&quot;</span> || path == <span class="string">&quot;.&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (path == <span class="string">&quot;..&quot;</span> &amp;&amp; !v.<span class="built_in">empty</span>())</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (path != <span class="string">&quot;..&quot;</span>)</span><br><span class="line">        v.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (string tmp : v) res += <span class="string">&quot;/&quot;</span> + tmp;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;/&quot;</span> : res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 8 ms, faster than 82.18% of C++ online submissions for Simplify Path. Memory Usage: 10.2 MB, less than 41.98% of C++ online submissions for Simplify Path.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> StringStream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. Merge Intervals 合并区间</title>
      <link href="/posts/717706177/"/>
      <url>/posts/717706177/</url>
      
        <content type="html"><![CDATA[<blockquote><p>合并重叠的区间</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>经典常见题型，考察STL中sort函数的使用</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Interval a, Interval b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.start == b.start) <span class="keyword">return</span> a.end &lt; b.end;</span><br><span class="line">    <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">vector&lt;Interval&gt; <span class="title">merge</span><span class="params">(vector&lt;Interval&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    vector&lt;Interval&gt; result;</span><br><span class="line">    Interval temp;</span><br><span class="line">    temp.start = intervals[<span class="number">0</span>].start;</span><br><span class="line">    temp.end = intervals[<span class="number">0</span>].end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Interval a : intervals) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.start &gt; temp.end) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        temp.start = a.start;</span><br><span class="line">        temp.end = a.end;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp.end = <span class="built_in">max</span>(a.end, temp.end);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 32 ms, faster than 45.79% of C++ online submissions for Merge Intervals. Memory Usage: 9.9 MB, less than 100.00% of C++ online submissions for Merge Intervals.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. Group Anagrams 异序词分组</title>
      <link href="/posts/2374788847/"/>
      <url>/posts/2374788847/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个包含若干个字符串的数组，将含有相同字母但是字母顺序不同的字符串合并到一个数组中，并返回分组结果。</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>遍历字符串，使用sort函数对每个字符串进行排序，得到按照正序排列的temp（具有相同字母的字符串的正序排列一定是相同的），使用一个哈希表记录正序是否出现过。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (string s : strs) &#123;</span><br><span class="line">      string temp = s;</span><br><span class="line">      <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line">      m[temp].<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : m) &#123;</span><br><span class="line">      result.<span class="built_in">push_back</span>(it.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 24 ms, faster than 100.00% of C++ online submissions for Group Anagrams. Memory Usage: 20 MB, less than 59.24% of C++ online submissions for Group Anagrams.</p><h3 id="改进">4. 改进</h3><h4 id="思路-1">4.1. 思路</h4><p>因为字母都是小写的，所以我们可以使用26个字母的哈希表来记录26个字母中都有哪些字母出现了，然后遍历哈希表可以构造出正序的字母。</p><h4 id="代码-1">4.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (string s : strs) &#123;</span><br><span class="line">      string temp = <span class="built_in">helper</span>(s);</span><br><span class="line">      m[temp].<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : m) &#123;</span><br><span class="line">      result.<span class="built_in">push_back</span>(it.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">string <span class="title">helper</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> counter[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> ch : s) &#123;</span><br><span class="line">      counter[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">      res += <span class="built_in">string</span>(counter[i], <span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">4.3. 结果</h4><p>Runtime: 48 ms, faster than 74.15% of C++ online submissions for Group Anagrams. Memory Usage: 20 MB, less than 59.24% of C++ online submissions for Group Anagrams.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water 收集雨水</title>
      <link href="/posts/1049151470/"/>
      <url>/posts/1049151470/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用n个非负的整数来描述一个海拔地图，<code>a[i]</code>的值表示的是高度，根据这个海拔地图，计算出经过下雨之后，能储蓄多少水</p></blockquote><span id="more"></span><p><img src="rainwatertrap1.png" alt="rainwatertrap" /></p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>我的想法是使用栈来解决这个问题，当<code>a[i] &gt; s.top()</code>时，另<code>k = s.top()</code>然后<code>s.pop()</code>，注意s经过pop操作后，s.top、k、i的关系如下图所示。</p><p><img src="rainwatertrap.png" alt="rainwatertrap" /></p><p>计算<code>distance = i - s.top() - 1</code>，这里i是右边界的下标，因为s经过一次pop之后，s.top()就是左边界的下标</p><p>计算<code>h = min(height[i], height[s.top()]) - height[k];</code>，这里是左、右边界中小的一个减去<code>height[k]</code></p><p>考虑这个例子：[3, 1, 1, 4]，假设此时<code>i = 3</code>，<code>k = s.top() = 2</code>，<code>s.pop()</code>之后，<code>s.top() = 1</code>，这时候：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = <span class="built_in">min</span>(height[i], height[s.<span class="built_in">top</span>()]) - height[k];</span><br><span class="line">h = <span class="built_in">min</span>(<span class="number">4</span>, <span class="number">1</span>) - <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>这个例子表明了此时不能形成一个池子，所以需要重复出栈的过程，我们可以使用一个while循环来解决</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">        k = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 如果s变空了，则2个元素无法形成蓄水池</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 此时s.top()代表左边界</span></span><br><span class="line">        <span class="keyword">int</span> distance = i - s.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="built_in">min</span>(height[i], height[s.<span class="built_in">top</span>()]) - height[k];</span><br><span class="line">        res += h * distance;</span><br><span class="line">      &#125;</span><br><span class="line">      s.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态规划解法">3. 动态规划解法</h3><h4 id="解析-1">3.1. 解析</h4><p>我们使用暴力解法的时候，就是对于一个点i，我们找到它的左边界的最大值、右边界的最大值；然后点i所能形成的面积就等于 <code>min(max_left, max_right) - height[i]</code>;</p><p>这里面存在大量的重复运算，所以我们可以使用动态规划的算法， <code>max_left[i]</code>表示点i左边界的最大值； <code>max_right[i]</code>表示右边界的最大值； <code>res += min(max_left[i], max_right[i]) - height[i]</code></p><p>通过下面的图，会有更直观的感受：</p><p><img src="trapping_rain_water.png" alt="trapping_rain_water" /></p><p>我们来看上面这3幅图，左上角的图表示的是，对于一个点i，它的面积是：<code>max(左边界) - height[i]</code> 右上角的图表示的是，对于一个点i，它的面积是：<code>max(右边界) - height[i]</code> 当把两幅图重叠起来，我们就会发现，重叠的部分就是我们要求的答案！！！</p><h4 id="代码-1">3.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, size = height.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left_max</span><span class="params">(size)</span>, <span class="title">right_max</span><span class="params">(size)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    left_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">      left_max[i] = <span class="built_in">max</span>(height[i], left_max[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    right_max[size - <span class="number">1</span>] = height[size - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      right_max[i] = <span class="built_in">max</span>(height[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      ans += <span class="built_in">min</span>(left_max[i], right_max[i]) - height[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="two-pointers-解法最优解">4. two pointers 解法(最优解)</h3><h4 id="解析-2">4.1. 解析</h4><p>动态规划的方法需要遍历2次，那么可以不以缩短到一次呢？</p><p>我们考虑下，如何形成一个蓄水池。假如我们现在遍历到了<span class="math inline">\(i = 5\)</span> 如果这个点可以蓄水，那么它的左边界一定是图中的左圈中，这个时候，其实只要保证右面有一个大于等于 <code>height[3]</code>的边界就可以了，显然<code>height[10]</code>满足这个要求，这就启发我们可以使用两个指针一个指针从左往右遍历，一个指针从右往左遍历。</p><p><img src="rainwatertrap2.png" alt="rainwatertrap2" /></p><h4 id="代码-2">4.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> water = <span class="number">0</span>, lower = <span class="number">0</span>, level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="comment">// lower存储的是矮的边界</span></span><br><span class="line">      <span class="comment">// 如果height[l] &lt; height[r]; 那么lower = height[l++]</span></span><br><span class="line">      <span class="comment">// 反之lower = height[r--];</span></span><br><span class="line">      lower = height[height[l] &lt; height[r] ? l++ : r--];</span><br><span class="line">      <span class="comment">// level存储的是当前能蓄水的高度</span></span><br><span class="line">      level = <span class="built_in">max</span>(level, lower);</span><br><span class="line">      water += level - lower;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
            <tag> Hard </tag>
            
            <tag> Two Pointers </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33. Search in Rotated Sorted Array 在旋转有序数组中搜索</title>
      <link href="/posts/3687396736/"/>
      <url>/posts/3687396736/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在旋转数组中搜索一个给定值，若存在返回坐标，若不存在返回-1。要求时间复杂度为O(logn)</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>这道题的关键点在于寻找到那个旋转点，因为时间复杂度要求为logn，<strong>所以找分割点的过程也要使用二分法</strong>。 换个角度看，分割点就是找到第一个既小于最左边的数，也小于最右边的数。</p><p>示例中，就是找到第一个小于4，并且小于2的数，显然这个数是0。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftnum = nums[<span class="number">0</span>], rightnum = nums[len - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 寻找第一个比leftnum和rightnum小的值</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (r - l) / <span class="number">2</span> + l;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &lt;= leftnum &amp;&amp; nums[mid] &lt;= rightnum)</span><br><span class="line">        r = mid;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> partition = l;</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    r = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &gt;= nums[partition] &amp;&amp; target &lt;= nums[r])</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">biSearch</span>(nums, partition, r, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">biSearch</span>(nums, l, partition, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">      <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Search in Rotated Sorted Array. Memory Usage: 8.8 MB, less than 99.11% of C++ online submissions for Search in Rotated Sorted Array.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31. Next Permutation 下一个排列</title>
      <link href="/posts/2414829996/"/>
      <url>/posts/2414829996/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实现 “下一个全排列” 函数，给定一个全排列的结果，输出基于字典序的下一个全排列的结果。如果这样的重新排列是不可能的，则输出全排列的最低顺序。内存要求为O(1)。</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>首先，我们要明白什么是下一个全排列，来看一个例子： <code>1 5 8 4 7 6 5 3  1</code> 的下一个全排列是 <code>1 5 8 5 1 3 4 6 7</code> 。它是如何生成的呢？</p><ul><li>第一步，我们要从后往前找到第一个下降的数字</li></ul><p><img src="next01.png" alt="next01" /></p><p>在这个例子中，1 <span class="math inline">\(\to\)</span> 3 <span class="math inline">\(\to\)</span> 5 <span class="math inline">\(\to\)</span> 6 <span class="math inline">\(\to\)</span> 7 <span class="math inline">\(\to\)</span> <font color='red'>4</font> ，我们找到4是一个下降的数字</p><ul><li>第二步，在4的后面找到第一个大于4的数，并交换它们的位置</li></ul><p><img src="image-20200419182953106.png" alt="image-20200419182953106" /></p><p>在这个例子中，我们找到5。</p><ul><li>最后，把4后面的数字重新排序，因为4之后的</li></ul><p><img src="image-20200419183038371.png" alt="image-20200419183038371" /></p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = n - <span class="number">2</span>, j = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt;= nums[i]) i--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) j--;</span><br><span class="line">      <span class="built_in">swap</span>(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(nums, i + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[a];</span><br><span class="line">    nums[a] = nums[b];</span><br><span class="line">    nums[b] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">      <span class="built_in">swap</span>(nums, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Next Permutation. Memory Usage: 8.6 MB, less than 100.00% of C++ online submissions for Next Permutation.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30. Substring with Concatenation of All Words 串联所有单词的子串</title>
      <link href="/posts/1185497444/"/>
      <url>/posts/1185497444/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给一个字符串S以及几个长度相同的words，找到S中包含所有words串联的子串的起始位置。</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;barfoothefoobarman&quot;,</span><br><span class="line">  words = [&quot;foo&quot;,&quot;bar&quot;]</span><br><span class="line">Output: [0,9]</span><br><span class="line">Explanation: Substrings starting at index 0 and 9 are &quot;barfoor&quot; and &quot;foobar&quot; respectively.</span><br><span class="line">The output order does not matter, returning [9,0] is fine too.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">  s = &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class="line">  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>使用HashMap统计words中单词出现的次数，然后选定S的起始位置 i ，按照单词去对比。需要注意的是该单词是否出现在words中以及出现的次数。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || words.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), m = words.<span class="built_in">size</span>(), k = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> w : words) ++m1[w];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - m * k; ++i) &#123;</span><br><span class="line">      unordered_map&lt;string, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">      <span class="keyword">int</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        string temp = s.<span class="built_in">substr</span>(i + j * k, k);</span><br><span class="line">        <span class="keyword">if</span> (!m1.<span class="built_in">count</span>(temp) || m1[temp] == cnt[temp]) <span class="keyword">break</span>;</span><br><span class="line">        ++cnt[temp];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (j == m) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 208 ms, faster than 58.94% of C++ online submissions for Substring with Concatenation of All Words.</p><p>Memory Usage: 21.7 MB, less than 54.08% of C++ online submissions for Substring with Concatenation of All Words.</p><h3 id="改进">4. 改进</h3><h4 id="思路-1">4.1. 思路</h4><p>上面的做法是按照起始位置去遍历的。现在我们从词的角度去考虑，题目中S的长度为18，单词长度为3。那么我们能从S中切分得到的词只能为：0，3，6，8，12，15；然后偏移一个字符 1，4，7，9，13，16，然后再偏移一个字符 2，5，8，10，14，17。这样我们就的外循环只需要3次。每次需要判断的单词也是有6个。</p><p>那么问题就转换是否为子串，我们使用两个map：m1和m2 m1表示words中每个词出现的次数，当我们遍历S中的词的时候，如果在m1中出现过，就让m2加1，这个时候要注意如果 <code>m2[t] &gt; m1[t]</code> 就无法构成答案，所以我们需要移动相应的边界。具体结合代码来看。</p><h4 id="代码-1">4.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || words.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), m = words.<span class="built_in">size</span>(), k = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; m1;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> w : words) ++m1[w];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> left = i, cnt = <span class="number">0</span>;</span><br><span class="line">      unordered_map&lt;string, <span class="keyword">int</span>&gt; m2;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n - k; j += k) &#123;</span><br><span class="line">        string t = s.<span class="built_in">substr</span>(j, k);</span><br><span class="line">        <span class="keyword">if</span> (m1.<span class="built_in">count</span>(t)) &#123;</span><br><span class="line">          ++m2[t];</span><br><span class="line">          <span class="keyword">while</span> (m2[t] &gt; m1[t]) &#123;</span><br><span class="line">            string w = s.<span class="built_in">substr</span>(left, k);</span><br><span class="line">            --m2[w];</span><br><span class="line">            --cnt;</span><br><span class="line">            left += k;</span><br><span class="line">          &#125;</span><br><span class="line">          ++cnt;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (cnt == m) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(left);</span><br><span class="line">            --m2[s.<span class="built_in">substr</span>(left, k)];</span><br><span class="line">            --cnt;</span><br><span class="line">            left += k;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          m2.<span class="built_in">clear</span>();</span><br><span class="line">          cnt = <span class="number">0</span>;</span><br><span class="line">          left = j + k;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">4.3. 结果</h4><p>Runtime: 24 ms, faster than 98.33% of C++ online submissions for Substring with Concatenation of All Words.</p><p>Memory Usage: 15 MB, less than 83.91% of C++ online submissions for Substring with Concatenation of All Words.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29. Divide Two Integers 两数相除</title>
      <link href="/posts/3462260807/"/>
      <url>/posts/3462260807/</url>
      
        <content type="html"><![CDATA[<blockquote><p>求两数相除，规定不能用乘法，除法和取余操作</p></blockquote><span id="more"></span><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>不能用乘法和除法，我们要想到一个天然的乘/除操作运算：位运算。左移1位 = 乘2，右移1位 = 除2</p><p>首先用sign来记录结果的正负，两个数同号为正、异号为负，天然满足异或操作。又因为这道题的case很是恶心人，比如-2147483648除以-1这种，所以我们用longlong来表示结果</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a = <span class="built_in">labs</span>(dividend), b = <span class="built_in">labs</span>(divisor), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = dividend &gt; <span class="number">0</span> ^ divisor &gt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &gt;= b) &#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span> t = b, p = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (a &gt;= (t &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">        t &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        p &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      a -= t;</span><br><span class="line">      ans += p;</span><br><span class="line">    &#125;</span><br><span class="line">    ans *= sign;</span><br><span class="line">    <span class="keyword">return</span> ans &gt; INT_MAX ? INT_MAX : ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Divide Two Integers. Memory Usage: 8.3 MB, less than 99.38% of C++ online submissions for Divide Two Integers.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. Reverse Nodes in k-Group 翻转k个节点</title>
      <link href="/posts/1226859380/"/>
      <url>/posts/1226859380/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以每k个为一组来翻转链表</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><h3 id="思路">1. 思路</h3><p>我们可以在链表的前面增加一个root结点，这样可以不用区分头结点与其它结点的区别。</p><p>我们以pre为开头，cur来遍历结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;1-&gt;2-&gt;3 | -&gt;4-&gt;5</span><br><span class="line"> |    |  |</span><br><span class="line">pre  cur t</span><br><span class="line"></span><br><span class="line">root-&gt;2-&gt;1-&gt;3 | -&gt;4-&gt;5</span><br><span class="line"> |       |  |</span><br><span class="line">pre     cur t</span><br><span class="line"></span><br><span class="line">root-&gt;3-&gt;2-&gt;1 | -&gt;4-&gt;5</span><br><span class="line"> |          |     |</span><br><span class="line">pre        cur    t</span><br></pre></td></tr></table></figure><p>这个时候，完成了k个结点的翻转，所以移动pre的位置：<code>pre = cur</code></p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *pre = root, *cur = root;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    root-&gt;next = head;</span><br><span class="line">    <span class="comment">// 统计结点个数</span></span><br><span class="line">    <span class="keyword">while</span> (cur = cur-&gt;next) num++;</span><br><span class="line">    <span class="keyword">while</span> (num &gt;= k) &#123;</span><br><span class="line">      cur = pre-&gt;next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        ListNode *t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = t-&gt;next;</span><br><span class="line">        t-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = t;</span><br><span class="line">      &#125;</span><br><span class="line">      pre = cur;</span><br><span class="line">      num -= k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 20 ms, faster than 98.36% of C++ online submissions for Reverse Nodes in k-Group. Memory Usage: 10 MB, less than 59.96% of C++ online submissions for Reverse Nodes in k-Group.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24. Swap Nodes in Pairs 成对交换节点</title>
      <link href="/posts/1421193349/"/>
      <url>/posts/1421193349/</url>
      
        <content type="html"><![CDATA[<blockquote><p>交换链表的两个相邻节点</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>我自己写的解法是将原来的链表扩展为：<code>X-&gt;1-&gt;2-&gt;3-&gt;4</code> ，这样就可以用三个指针移动来解决这个问题</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *t = root, *p = head, *q = head;</span><br><span class="line">    root-&gt;next = head;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (q &amp;&amp; p) &#123;</span><br><span class="line">      q-&gt;next = p-&gt;next;</span><br><span class="line">      p-&gt;next = q;</span><br><span class="line">      t-&gt;next = p;</span><br><span class="line">      <span class="keyword">if</span> (q-&gt;next &amp;&amp; q-&gt;next-&gt;next) &#123;</span><br><span class="line">        t = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        p = q-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 0 ms, faster than 100.00% of C++ online submissions for Swap Nodes in Pairs. Memory Usage: 8.8 MB, less than 89.04% of C++ online submissions for Swap Nodes in Pairs.</p><h3 id="改进">4. 改进</h3><p>可以使用一个指向指针的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *a, *b, **p = &amp;head;</span><br><span class="line">    <span class="keyword">while</span> ((a = *p) &amp;&amp; (b = a-&gt;next)) &#123;</span><br><span class="line">      a-&gt;next = b-&gt;next;</span><br><span class="line">      b-&gt;next = a;</span><br><span class="line">      *p = b;</span><br><span class="line">      p = &amp;(a-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>膜拜大神的简洁代码，简洁是一种艺术！</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23. Merge k Sorted Lists 合并k个有序链表</title>
      <link href="/posts/1535254555/"/>
      <url>/posts/1535254555/</url>
      
        <content type="html"><![CDATA[<blockquote><p>将k个有序的链表合并为一个链表</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><h3 id="暴力解法">1. 暴力解法</h3><h4 id="思路">1.1. 思路</h4><p>之前有一道题是归并排序的，这道题只要做 k 次归并排序就可以得到最终结果。</p><h4 id="代码">1.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* root = lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lists.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      root = <span class="built_in">merge</span>(root, lists[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> || l2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* p = root;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = l1 ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">1.3. 结果</h4><p>Runtime: 164 ms, faster than 25.50% of C++ online submissions for Merge k Sorted Lists. Memory Usage: 11 MB, less than 73.81% of C++ online submissions for Merge k Sorted Lists.</p><h3 id="优先队列">2. 优先队列</h3><h4 id="思路-1">2.1. 思路</h4><p>上面的算法时间复杂度是 <span class="math inline">\(O(kN)\)</span> ，我们换一个思路，每次比较当前k个链表的表头，选一个最小的，然后把它的指针后移一位。从k个值里面选最小的 <span class="math inline">\(\to\)</span> 最小堆！！！</p><h4 id="代码-1">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123; <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = root;</span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; minHeap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> list : lists) &#123;</span><br><span class="line">      <span class="keyword">if</span> (list != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(list);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!minHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      ListNode* temp = minHeap.<span class="built_in">top</span>();</span><br><span class="line">      minHeap.<span class="built_in">pop</span>();</span><br><span class="line">      p-&gt;next = temp;</span><br><span class="line">      <span class="keyword">if</span> (temp-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        minHeap.<span class="built_in">push</span>(temp-&gt;next);</span><br><span class="line">      &#125;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果-1">3.  结果</h3><p>Runtime: 28 ms, faster than 69.69% of C++ online submissions for Merge k Sorted Lists. Memory Usage: 11.1 MB, less than 69.05% of C++ online submissions for Merge k Sorted Lists.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> priority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. Generate Parentheses 生成括号</title>
      <link href="/posts/1158594046/"/>
      <url>/posts/1158594046/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个数字n，输出所有可能括号结果。</p></blockquote><span id="more"></span><p>For example, given <em>n</em> = 3, a solution set is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>使用递归方法来生成所有的字符串，用left表示当前未匹配的左括号的数量，right表示右括号的数量。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(n, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;string&gt; res;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) res.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) <span class="built_in">dfs</span>(left - <span class="number">1</span>, right + <span class="number">1</span>, s + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (right &gt; <span class="number">0</span>) <span class="built_in">dfs</span>(left, right - <span class="number">1</span>, s + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 8 ms, faster than 97.29% of C++ online submissions for Generate Parentheses. Memory Usage: 17.7 MB, less than 16.81% of C++ online submissions for Generate Parentheses.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. Merge Two Sorted Lists 链表合并</title>
      <link href="/posts/1357582423/"/>
      <url>/posts/1357582423/</url>
      
        <content type="html"><![CDATA[<blockquote><p>将两个排好序的链表合并到一个新的链表（归并排序）</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>归并排序中的一步，很经典，不多说了，直接看代码。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> || l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1 ? l1 : l2;</span><br><span class="line">    ListNode *root = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = root;</span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">        p-&gt;next = l1;</span><br><span class="line">        l1 = l1-&gt;next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;next = l2;</span><br><span class="line">        l2 = l2-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = l1 ? l1 : l2;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 8 ms, faster than 78.34% of C++ online submissions for Merge Two Sorted Lists. Memory Usage: 8.8 MB, less than 98.36% of C++ online submissions for Merge Two Sorted Lists.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. Letter Combinations of a Phone Number 点好号码的字母组合</title>
      <link href="/posts/2728767299/"/>
      <url>/posts/2728767299/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个包含从2-9的字符串，返回根据手机按键分布的所有可能字符串组合。</p></blockquote><span id="more"></span><p><img src="200px-Telephone-keypad2.svg.png" alt="200px-Telephone-keypad2.svg" /></p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure><h3 id="思路">1. 思路</h3><p>两种解法，可以使用迭代或者DFS递归的求解。DFS需要使用一个int变量来表示digits的下标，当 <code>index == digits.size()</code> 的时候到达递归的边界。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  vector&lt;string&gt; dict = &#123;<span class="string">&quot;&quot;</span>,    <span class="string">&quot;&quot;</span>,    <span class="string">&quot;abc&quot;</span>,  <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">                         <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">  vector&lt;string&gt; res;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string digits, <span class="keyword">int</span> x, string t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      res.<span class="built_in">push_back</span>(t);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    string temp = dict[digits[x] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(digits, x + <span class="number">1</span>, t + temp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 4 ms, faster than 100.00% of C++ online submissions for Letter Combinations of a Phone Number.</p><p>Memory Usage: 8.9 MB, less than 22.50% of C++ online submissions for Letter Combinations of a Phone Number.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum 三数之和</title>
      <link href="/posts/310272330/"/>
      <url>/posts/310272330/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个包含n个数的无序数组，寻找所有的三元组[a, b, c]满足：a + b + c = 0</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>a + b + c = 0，换一个形式：a + b = -c，这不就是two sum那道题嘛。先把数组排个序，然后对每个数进行一下two sum的算法，这里要注意的就是重复答案，比如说[0, 0, 0, 0, 0]的答案是[0, 0, 0]，所以要进行一下去重处理，只需要<code>if(a[i] == a[i-1]) continue;</code></p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">int</span> left = i + <span class="number">1</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i] + nums[left] + nums[right];</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="number">0</span>)</span><br><span class="line">          right--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">          left++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          result.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">          <span class="comment">// 因为a[i]是定值，所以left和right都要移动</span></span><br><span class="line">          <span class="comment">// 这里因为排好序，所以前后一样的元素要过滤掉</span></span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">          <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">          left++;</span><br><span class="line">          right--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 104 ms, faster than 81.83% of C++ online submissions for 3Sum. Memory Usage: 14.7 MB, less than 98.90% of C++ online submissions for 3Sum.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer 罗马数字转整数</title>
      <link href="/posts/294791618/"/>
      <url>/posts/294791618/</url>
      
        <content type="html"><![CDATA[<blockquote><p>把罗马数字变成整数</p></blockquote><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IV&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IX&quot;</span><br><span class="line">Output: 9</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;LVIII&quot;</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><p><strong>Example 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;MCMXCIV&quot;</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>这个题就是简单的字符串处理，因为罗马字母是分组的，所以用temp来记录上一组的数值大小，<code>a = symbol[s[i-1]], b = symbol[s[i]];</code> 只需要比较a和b的大小就可以了</p><ul><li>a == b：<code>temp += a;</code></li><li>a &gt; b：<code>num += temp;    temp = b;</code></li><li>a &lt; b：<code>num += (b - temp);    temp = 0;</code></li></ul><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, temp = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; symbol = &#123;&#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,   &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,   &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,  &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;, &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;, &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">    temp = symbol[s[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="keyword">int</span> a = symbol[s[i - <span class="number">1</span>]], b = symbol[s[i]];</span><br><span class="line">      <span class="keyword">if</span> (a == b)</span><br><span class="line">        temp += a;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        num += temp;</span><br><span class="line">        temp = b;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num += (b - temp);</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    num += temp;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="改进">3. 改进</h3><p>看了评论区大佬的解答，发现从后向前遍历，更加简洁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; symbol = &#123;&#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;,   &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;,   &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;,  &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;,</span><br><span class="line">                             &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;, &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;, &#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;&#125;;</span><br><span class="line">    num = symbol[s.<span class="built_in">back</span>()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (symbol[s[i + <span class="number">1</span>]] &gt; symbol[s[i]])</span><br><span class="line">        num -= symbol[s[i]];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        num += symbol[s[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">4. 结果</h4><p>Runtime: 28 ms, faster than 82.85% of C++ online submissions for Roman to Integer. Memory Usage: 10.4 MB, less than 98.40% of C++ online submissions for Roman to Integer.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water 装最多的水</title>
      <link href="/posts/279265382/"/>
      <url>/posts/279265382/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定n个非负的整数 <span class="math inline">\(a_1, a_2, … , a_n\)</span> ，每个整数 <span class="math inline">\(i\)</span> 代表一条长为 <span class="math inline">\(a_i\)</span> 的边。需要找出两个边与x轴组成的矩形的面积最大</p></blockquote><span id="more"></span><p><img src="question_11.jpg" alt="question_11" /></p><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>暴力解 <span class="math inline">\(o(n^2)\)</span> 就不讨论了，这道题我的想法是使用two point来做，left和right初始化为0和n-1，比较 <code>a[left]</code> 和 <code>a[right]</code>的大小，小的移动指针</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>, MAX = INT_MIN;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">int</span> h = <span class="built_in">min</span>(height[left], height[right]);</span><br><span class="line">      MAX = <span class="built_in">max</span>((right - left) * h, MAX);</span><br><span class="line">      <span class="keyword">if</span> (height[left] &lt;= height[right])</span><br><span class="line">        left++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 20 ms, faster than 98.41% of C++ online submissions for Container With Most Water. Memory Usage: 9.7 MB, less than 99.58% of C++ online submissions for Container With Most Water.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> Two Pointers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. Expression Matching 正则表达式</title>
      <link href="/posts/1436657565/"/>
      <url>/posts/1436657565/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定字符串s和字符串p，在p中存在<code>'.'</code>和 <code>'*'</code>，按照正则表达式的规则，来判断s和p是否匹配</p></blockquote><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;.&#x27; Matches any single character.</span><br><span class="line">&#x27;*&#x27; Matches zero or more of the preceding element.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li><li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &#x27;*&#x27; means zero or more of the precedeng element, &#x27;a&#x27;. Therefore, by repeating &#x27;a&#x27; once, it becomes &quot;aa&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.</span><br></pre></td></tr></table></figure><p><strong>Example 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>字符串匹配 + Hard难度，这种题考察的就是DP的能力了。所以拿到题就要考虑状态转移方程的构建。需要注意的是正则表达式中*的作用，表示前一个字符出现的次数，例如：<code>ab*</code></p><ul><li>0次：a</li><li>1次：ab</li><li>5次：abbbbb</li></ul><p>涉及到两个字符串的问题，一般使用 <code>dp[i][j]</code>表示<code>s[0:i-1]</code>是否等于<code>p[0:j-1]</code>，由于i和j表示的是长度，所以在字符串中下标要-1 <code>dp[s.length()][p.length()]</code>即表示字符串s与字符串p是否匹配。</p><p>下面再来看字符串p中出现的字符的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> p的当前字符等于s的当前字符</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> p的当前字符等于<span class="string">&#x27;.&#x27;</span></span><br><span class="line"><span class="comment">// 由于.可以等于任何字符，所以相当于p的当前字符等于s的当前字符</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span> p的当前字符等于<span class="string">&#x27;*&#x27;</span></span><br><span class="line"><span class="comment">// 有两种情况：</span></span><br><span class="line"><span class="comment">// p的前一个字符不等于s的当前字符，此时*号做空上一个字符</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line"><span class="comment">// p的前一个字符等于s的当前字符，或者p的前一个字符等于&#x27;.&#x27;</span></span><br><span class="line"><span class="comment">// 这里又分三种情况</span></span><br><span class="line"><span class="comment">// b* = &#x27;&#x27;，表示*和b都可以忽略</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-2</span>]</span><br><span class="line"><span class="comment">// b* = b，表示*可以忽略</span></span><br><span class="line">dp[i][j] = dp[i][j<span class="number">-1</span>]</span><br><span class="line"><span class="comment">// b* = bbb... 表示匹配多个b</span></span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br></pre></td></tr></table></figure><p>我们来看一个2次及以上的例子</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">S</td><td style="text-align: center;">a</td><td style="text-align: center;">b</td><td style="text-align: center;">b</td><td style="text-align: center;">b</td><td style="text-align: center;">b</td></tr><tr class="even"><td style="text-align: center;">P</td><td style="text-align: center;">a</td><td style="text-align: center;">b</td><td style="text-align: center;">*</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>此时，我们计算<code>dp[3][3]</code>，发现<code>p[2] == '*'</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[3][3] = (s[3-1] == p[3-2]) &amp;&amp; dp[3-1][3]</span><br><span class="line">dp[3][3] = (s[2] == p[2]) &amp;&amp; dp[2][3]</span><br></pre></td></tr></table></figure><p>动手模拟一下，就明白了，一定要弄明白i，j对应的是长度，下标要i-1，j-1</p><p>另外一点需要注意的是，dp的初始化问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一列全部初始化为false，因为空串不可能和长度大于0的字符串匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    dp[i][<span class="number">0</span>] == <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要注意的就是这里，第一行不一定都是false</span></span><br><span class="line"><span class="comment">// 因为空串与&quot;a*b*&quot;也是匹配的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p.<span class="built_in">size</span>(); ++j)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j &gt; <span class="number">1</span> &amp;&amp; p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[<span class="number">0</span>][j<span class="number">-2</span>];</span><br></pre></td></tr></table></figure><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> dp[<span class="number">1010</span>][<span class="number">1010</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) dp[i][<span class="number">0</span>] == <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p.<span class="built_in">size</span>(); ++j)</span><br><span class="line">      dp[<span class="number">0</span>][j] = j &gt; <span class="number">1</span> &amp;&amp; p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> || p[j - <span class="number">1</span>] == s[i - <span class="number">1</span>])</span><br><span class="line">          dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (p[j - <span class="number">2</span>] != s[i - <span class="number">1</span>] &amp;&amp; p[j - <span class="number">2</span>] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][p.<span class="built_in">size</span>()];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 16 ms, faster than 57.31% of C++ online submissions for Regular Expression Matching. Memory Usage: 9.5 MB, less than 99.35% of C++ online submissions for Regular Expression Matching.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> DP </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. Palindrome Number 回文数字</title>
      <link href="/posts/831675236/"/>
      <url>/posts/831675236/</url>
      
        <content type="html"><![CDATA[<blockquote><p>判断一个数字是否是回文数字</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>这道题很简单，只需要用一个int变量res来存储反转过后的数字，然后与原来的数比较一下就好了，但是有一点需要注意的就是越界的情况，因为int型变量的最大值是：2147483647，假如x = 1000000007，那么res = 7000000001，显然越界了，有两种解决方案，一种是将res定义为long long类型；第二种是在while循环中增加一个判断，具体请看代码。</p><h4 id="代码">1.1. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = x, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果res的值大于temp/10，那么一定越界</span></span><br><span class="line">    <span class="comment">// 例如：1000000007，temp/10 = 100000000</span></span><br><span class="line">    <span class="comment">// 那么当res = 700000000，大于temp/10，所以退出while</span></span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp; temp / <span class="number">10</span> &gt;= res) &#123;</span><br><span class="line">      res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">      x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == temp) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="改进">2. 改进</h3><p>看了眼讨论区中的高票解答，茅塞顿开。我们并不需要完全反转，只需要反转一半就可以了，因为回文的性质就是对称的。</p><p>但是需要注意奇数和偶数的情况：</p><h4 id="代码-1">2.1. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x != <span class="number">0</span> &amp;&amp; x % <span class="number">10</span> == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; sum) &#123;</span><br><span class="line">      sum = sum * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">      x = x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里的x == sum/10，对应的奇数情况</span></span><br><span class="line">    <span class="comment">// 如果不理解的话，用笔算一遍121就明白了</span></span><br><span class="line">    <span class="keyword">return</span> (x == sum) || (x == sum / <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">2.2. 结果</h4><p>Runtime: 32 ms, faster than 99.08% of C++ online submissions for Palindrome Number. Memory Usage: 8.3 MB, less than 99.11% of C++ online submissions for Palindrome Number.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. String to Integer 字符串转整数</title>
      <link href="/posts/2447165170/"/>
      <url>/posts/2447165170/</url>
      
        <content type="html"><![CDATA[<blockquote><p>把字符串转换成一个整数</p></blockquote><span id="more"></span><h3 id="解析">1. 解析</h3><p>这道题的描述不是很明确，不是一道很好的算法题，评论区里面被各种怼23333</p><p>我们只需要按照下面的描述，写代码规则就可以了，没什么好分析的~</p><ul><li>开头是空格则跳过所有空格。</li><li>第一个非空格字符是符号+/-，则标记sign的真假。</li><li>下一个字符不是数字，则返回0。</li><li>下一个字符是数字，则转为整形存下来，若接下来再有非数字出现，则返回目前的结果。</li><li>还需要考虑边界问题，如果超过了整形数的范围，则用边界值替代当前值。</li></ul><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, base = <span class="number">0</span>, sign = <span class="number">1</span>, n = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 过滤空格</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; str[i] == <span class="string">&#x27; &#x27;</span>) ++i;</span><br><span class="line">    <span class="comment">// 判断正负</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; n &amp;&amp; (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">      sign = (str[i++] == <span class="string">&#x27;+&#x27;</span>) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 转换数字</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 越界判断</span></span><br><span class="line">      <span class="keyword">if</span> (base &gt; INT_MAX / <span class="number">10</span> || (base == INT_MAX / <span class="number">10</span> &amp;&amp; str[i] &gt; <span class="string">&#x27;7&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> (sign == <span class="number">1</span>) ? INT_MAX : INT_MIN;</span><br><span class="line">      base = base * <span class="number">10</span> + (str[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sign * base;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 4 ms, faster than 75.76% of C++ online submissions for String to Integer (atoi). Memory Usage: 6.2 MB, less than 100.00% of C++ online submissions for String to Integer (atoi).</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. Reverse Integer 翻转整数</title>
      <link href="/posts/3232070825/"/>
      <url>/posts/3232070825/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个32位的有符号整数，把它的数字为翻转</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: <span class="math inline">\([−2^{31}, 2^{31} − 1]\)</span>. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><h3 id="解析">1. 解析</h3><p>这道题起始考察的难点在于对溢出情况的处理，因为题目中描述的是使用一个32位的整数来处理</p><p>我相信大部分人都记得32位整数，即 int 类型的范围是 <span class="math inline">\([−2^{31}, 2^{31} − 1]\)</span>，但是一般不会记得具体的数，没关系，我们通过代码来获取一下就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; INT_MAX &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; INT_MIN &lt;&lt; endl;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2147483647</span></span><br><span class="line"><span class="number">-2147483648</span></span><br></pre></td></tr></table></figure><p>我们先定一下代码的框架：如果反转一个数，那么 x%10 会得到最后一位，我们假设</p><blockquote><p>temp = x % 10</p><p>ans 用来存储翻转过后的数</p></blockquote><p>所以每次，只需要 ans = ans * 10 + temp 就可以得到结果。</p><p>下面，我们来考虑溢出的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">214748364</span> | <span class="number">7</span></span><br><span class="line"><span class="number">-214748364</span>| <span class="number">8</span></span><br></pre></td></tr></table></figure><ul><li>如果 |ans| &gt; 214748364，那么无论temp等于几，都会溢出</li><li>如果 |ans| = 214748364，那么temp &lt; -8 或者 temp &gt; 7，就会溢出</li></ul><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      temp = x % <span class="number">10</span>;</span><br><span class="line">      x /= <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">abs</span>(ans) &gt; INT_MAX / <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">abs</span>(ans) == INT_MAX / <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">-8</span> || temp &gt; <span class="number">7</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ans = ans * <span class="number">10</span> + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 8 ms, faster than 72.81% of C++ online submissions for Reverse Integer. Memory Usage: 8.3 MB, less than 98.18% of C++ online submissions for Reverse Integer.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Easy </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. ZigZag Conversion 之字形转字符串</title>
      <link href="/posts/2613885919/"/>
      <url>/posts/2613885919/</url>
      
        <content type="html"><![CDATA[<blockquote><p>把字符串按照给定的行数进行Z字形打印</p></blockquote><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>我们先来观察下规律</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>我们把这些字母在原string中的下标写出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0   4   8    12</span><br><span class="line">1 3 5 7 9 11 13</span><br><span class="line">2   6   10</span><br></pre></td></tr></table></figure><p>我们注意观察第0行的字母：PAHN，他们在原字符串中的下标是0，4，8，12</p><p>很容易想到周期 T = 6，那么这个周期该如何计算得到呢？</p><p>我们捋一下第一行的第二个字母是怎么得到的，首先从P开始向下走2格，再斜着走2格。更一般地，向下走numRows - 1格，斜着走numRows - 1格。</p><blockquote><p>T = 2 * numRows - 2</p></blockquote><p>为了找到规律，我们将另一个示例也表示成上面的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0     6      12</span><br><span class="line">1   5 7   11 13</span><br><span class="line">2 4   8 10</span><br><span class="line">3     9</span><br></pre></td></tr></table></figure><blockquote><p>T = 2 * 4 - 2 = 6</p></blockquote><p>通过这两个例子，我们可以看到，只要我们确定了竖线的前半部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0   | 4   8    12</span><br><span class="line">1 3 | 5 7 9 11 13</span><br><span class="line">2   | 6   10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0     | 6      12</span><br><span class="line">1   5 | 7   11 13</span><br><span class="line">2 4   | 8 10</span><br><span class="line">3     | 9</span><br></pre></td></tr></table></figure><p>其余部分就可以通过周期得到，那么如何求前半部分呢？</p><p>我们注意到，第一行和最后一行是确定的，0和numRows - 1</p><p>第二行：1 + 5 = 6；第三行：2 + 4 = 6；</p><blockquote><p>第 i 行，第二个元素的下标 = t - i</p><p>我们设第一个元素和第二个元素的差值为：t - i - i</p></blockquote><p>完美的规律，下面就来Codeing吧</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="function">string <span class="title">result</span><span class="params">(s.size(), <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, t = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> p = t - i - i;  <span class="comment">// 第一个元素和第二个元素的差值</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += t) &#123;</span><br><span class="line">        result[k++] = s[j];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; numRows - <span class="number">1</span> &amp;&amp; j + p &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">          result[k++] = s[j + p];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 12 ms, faster than 99.34% of C++ online submissions for ZigZag Conversion. Memory Usage: 10.1 MB, less than 100.00% of C++ online submissions for ZigZag Conversion.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. Longest Palindromic Substring 最长回文子串</title>
      <link href="/posts/3070749106/"/>
      <url>/posts/3070749106/</url>
      
        <content type="html"><![CDATA[<blockquote><p>求一个字符串的最长回文子串</p></blockquote><span id="more"></span><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;babad&quot;</span><br><span class="line">Output: &quot;bab&quot;</span><br><span class="line">Note: &quot;aba&quot; is also a valid answer.</span><br></pre></td></tr></table></figure><h3 id="暴力解法">1. 暴力解法</h3><p>最长的回文子串，只需要从每个位置 i 开始看它的左右两边的字符是否相等</p><p>但是，由于奇偶的问题，我们需要考虑两种情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a b b a</span><br><span class="line">0 1 2 3假如当前下标在1，奇数情况需要考虑abb；偶数情况需要考虑abba</span><br></pre></td></tr></table></figure><p>具体做法请看代码：</p><h4 id="代码">1.1. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MAX表示最大长度，index表示中心坐标；例如abba，index = 1</span></span><br><span class="line">    <span class="keyword">int</span> len = s.<span class="built_in">size</span>(), MAX = <span class="number">0</span>, index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// 先以当前点为中心，看它的奇数情况</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j &lt; len); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i - j] != s[i + j]) <span class="keyword">break</span>;</span><br><span class="line">        temp += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp &gt; MAX) &#123;</span><br><span class="line">        MAX = temp;</span><br><span class="line">        index = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 再以当前点为中心，看它的偶数情况</span></span><br><span class="line">      temp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (i - j &gt;= <span class="number">0</span>) &amp;&amp; (i + j + <span class="number">1</span> &lt; len); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i - j] != s[i + j + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        temp += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (temp &gt; MAX) &#123;</span><br><span class="line">        MAX = temp;</span><br><span class="line">        index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (MAX % <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> s.<span class="built_in">substr</span>(index - MAX / <span class="number">2</span>, MAX);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s.<span class="built_in">substr</span>(index - MAX / <span class="number">2</span> + <span class="number">1</span>, MAX);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果">1.2. 结果</h4><p>Runtime: 28 ms, faster than 67.12% of C++ online submissions for Longest Palindromic Substring. Memory Usage: 8.6 MB, less than 100.00% of C++ online submissions for Longest Palindromic Substring.</p><h3 id="马拉车manacher算法">2. 马拉车(Manacher)算法</h3><p>这个算法，把 <span class="math inline">\(O(n^2)\)</span> 的时间复杂度，降到了逆天的 <span class="math inline">\(O(n)\)</span> 级别</p><p>首先，上面让我们棘手的奇偶问题，被这位大神用了一个巧妙的办法解决了：在字符串中每个字符的两边插入一个字符“#”。</p><blockquote><p>abba 插入字符#变为 # a # b # b # a #</p></blockquote><p>一个长度为4的字符串，摇身一变变成了长度为9的字符串；2*N + 1 永远为一个奇数！！！</p><p>然后，我们使用一个数组p[i]来记录以字符s[i]为中心的最长回文子串的半径（包括s[i]本身）</p><blockquote><p>S：# a # b # b # a #</p><p>p：1 2 1 2 5 2 1 2 1</p></blockquote><p>p的最大值是5，我们发现 5-1 = 4 正好是原字符串满足回文的最大长度（具体证明方法略过）</p><blockquote><p>maxLen = max(p[i]) - 1</p></blockquote><p>我们知道的最大长度，所以我们只要求出取得最大长度的字符串的起始位置就完美的解决问题啦，马拉车算法的起始位置的公式为：</p><blockquote><p>begin = ( max(p[i])的下标 i - 半径p[i] ) / 2</p></blockquote><p>但是，使用上面的例子，就会发现 4 - 5 = -1 ，这个马拉车算法出错了？非也，针对这种边界情况，我们还需要在首尾添加两个字符来避免越界，通常在首部添加 “$”，由于尾部有 “\0” 所以可以不添加。</p><blockquote><p>S：$ # a # b # b # a #</p><p>p：1 1 2 1 2 5 2 1 2 1</p></blockquote><p>这时候，begin = (5 - 5) / 2 = 0。所以，最后问题变成了如何<strong>求p数组</strong></p><h4 id="求解p数组">2.1 求解p数组</h4><p>我们再一次观察abba这个例子，可以发现不光S是对称的，P也是对称的。根据对称原则，计算数组p的运算量将会直接缩短了一半！！！</p><p>Manacher算法增加两个辅助变量id和mx，其中id表示最大回文子串中心的位置，mx则为id+P[id]，即最大回文子串的边界。另外 j 是 i 关于id的对称点。</p><p><img src="Manacher1.png" alt="Manacher1" /></p><p>当 mx - i &gt; P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有 P[i] = P[j]。</p><p>当 P[j] &gt;= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] = mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了。</p><p><img src="Manacher2.png" alt="Manacher2" /></p><p>对于 mx &lt;= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。</p><h4 id="代码-1">2.2. 代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Insert &#x27;#&#x27;</span></span><br><span class="line">    string result = <span class="string">&quot;$#&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      result += s[i];</span><br><span class="line">      result += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// calculate p</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(result.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, maxP = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      p[i] = mx &gt; i ? <span class="built_in">min</span>(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (result[i + p[i]] == result[i - p[i]]) ++p[i];</span><br><span class="line">      <span class="keyword">if</span> (p[i] + i &gt; mx) &#123;</span><br><span class="line">        mx = p[i] + i;</span><br><span class="line">        id = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (p[i] &gt; maxP) &#123;</span><br><span class="line">        maxP = p[i];</span><br><span class="line">        index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>((index - maxP) / <span class="number">2</span>, maxP - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="结果-1">2.3. 结果</h4><p>Runtime: 8 ms, faster than 100.00% of C++ online submissions for Longest Palindromic Substring. Memory Usage: 10.5 MB, less than 56.45% of C++ online submissions for Longest Palindromic Substring.</p><p>再次膜拜大神，从20ms的时间复杂度直接优化到8ms</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> Medium </tag>
            
            <tag> Palindromic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. Median of Two Sorted Arrays 两个有序数组的中位数</title>
      <link href="/posts/2726523652/"/>
      <url>/posts/2726523652/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有两个排好序的数组nums1和nums2，它们的长度分别为m和n。返回这两个数组的中位数，时间复杂度需要为 <span class="math inline">\(O(log (m+n))\)</span>。</p></blockquote><span id="more"></span><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>看到这道题，首先想到的就是two pointers算法来合并两个数组，然而这样做的时间复杂度是 <span class="math inline">\(O(max(m,n))\)</span> ，由于时间复杂度要求是 <span class="math inline">\(O(log (m+n))\)</span>，虽然你这么做了之后提交也能通过LeetCode的检测，但是违背了我们的初衷。</p><p>如何才能将时间复杂度降低到 log 的级别呢，你一定会想到二分法。所以我们就用二分法去试一试吧，二分法的两个关键点：1）二分区间；2）判断条件。</p><h4 id="二分区间">1.1. 二分区间</h4><p>这道题，还有下一道最长回文子串的题，都有一个共同的非常棘手的问题，就是长度的奇偶问题，这两种情况需要不同的处理，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2，3 / 5，7]mid = (3 + 5) / 2 = 4</span><br></pre></td></tr></table></figure><p>对于奇数情况，我们换一个角度思考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2，3，(4/4)，5，7]mid = (4 + 4) / 2 = 4</span><br></pre></td></tr></table></figure><p>总结一下，result = (左半部分最大值 + 右半部分最小值）/ 2</p><p>偶数情况是两个不一样的值，奇数情况左半部分最大值等于右半部分最小值。 <span class="math display">\[\begin{align}   leftMax &amp;= \frac{N-1}{2} \\   rightMin &amp;= \frac{N}{2}\end{align}\]</span></p><p>接下来，我们对原数组做一些小小的改变，给每个间隔加一个字符#</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">13</span> <span class="number">18</span>]  -&gt;   [# <span class="number">6</span> # <span class="number">9</span> # <span class="number">13</span> # <span class="number">18</span> #]    (N = <span class="number">4</span>)</span><br><span class="line">position index     <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>  <span class="number">6</span> <span class="number">7</span>  <span class="number">8</span>     (N_Position = <span class="number">9</span>)</span><br><span class="line">  </span><br><span class="line">[<span class="number">6</span> <span class="number">9</span> <span class="number">11</span> <span class="number">13</span> <span class="number">18</span>]-&gt;   [# <span class="number">6</span> # <span class="number">9</span> # <span class="number">11</span> # <span class="number">13</span> # <span class="number">18</span> #]   (N = <span class="number">5</span>)</span><br><span class="line">position index      <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>  <span class="number">6</span> <span class="number">7</span>  <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>    (N_Position = <span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>我们可以看到，无论N是奇数还是偶数，最后一定有2N+1个位置，并且最重要的我们切分的位置的下标为N，并且左半部分有N个元素，右半部分有N个元素，这一点很重要！！！理解了这里，才能理解后面C1和C2的取值。</p><blockquote><p>我们用index(L)表示leftMax元素的下标，index(R)表示rightMin元素的下标</p><p>另外，我们还有注意#号并没有真的加到数组中，是我们为了辅助我们算出L和R的位置</p></blockquote><p>然后我们会发现一个神奇的现象，<strong>index(L) = (N-1)/2，index(R) = N/2</strong>。具体的数学证明，我也不是很清楚，此刻真的深深膜拜想出这个算法的大神。</p><p>我们将上面的描述做一个推广，因为N是切割点，所以使用 CutPosition 来替换它，得到：</p><p><strong>index(L) = (CutPosition-1)/2</strong></p><p><strong>index(R) = (CutPosition)/2</strong></p><p>由于我们有2个数组，所以经过加#变换，一个有2<em>N1 + 2</em>N2 + 2个位置，然后用2个位置作为分割，将元素分为左右都为N1+N2个元素的两部分。所以，在数组A2中，C2 = k 的时候，我们可以立即得到 C1 = N1 + N2 - k。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]  假设为 [# <span class="number">1</span> # <span class="number">2</span> # <span class="number">3</span> # <span class="number">4</span> # <span class="number">5</span> #]  </span><br><span class="line">                      切割为 [# <span class="number">1</span> # <span class="number">2</span> # <span class="number">3</span> # / # <span class="number">5</span> #] </span><br><span class="line">A2 = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]     假设为 [# <span class="number">1</span> # <span class="number">1</span> # <span class="number">1</span> # <span class="number">1</span> #]</span><br><span class="line">                      切割为 [# <span class="number">1</span> / <span class="number">1</span> # <span class="number">1</span> # <span class="number">1</span> #]</span><br><span class="line">下标从<span class="number">0</span>开始</span><br></pre></td></tr></table></figure><p>上面这个例子，我们另C2 = 2，则 C1 = 5 + 4 - 2 = 7，将下标为2和7的元素换位/代表从这里切开</p><p>然后在原数组中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L1 = A1[(<span class="number">7</span><span class="number">-1</span>)/<span class="number">2</span>] = A1[<span class="number">3</span>] = <span class="number">4</span>;      R1 = A1[<span class="number">7</span>/<span class="number">2</span>] = A1[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">L2 = A2[(<span class="number">2</span><span class="number">-1</span>)/<span class="number">2</span>] = A2[<span class="number">0</span>] = <span class="number">1</span>;      R2 = A1[<span class="number">2</span>/<span class="number">2</span>] = A1[<span class="number">1</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">划分结果为：A1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, (<span class="number">4</span>/<span class="number">4</span>), <span class="number">5</span>]</span><br><span class="line">A2 = [<span class="number">1</span> / <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>小结一下，划分区间为：[0, 2N]</p><h4 id="判断条件">1.2. 判断条件</h4><p>有了上面的区间和划分准则，我们就可以进行二分了</p><p>划分条件就是保证划分后的两部分是有序的，只需要保证 L1 &lt;= R1 &amp;&amp; L1 &lt;= R2 &amp;&amp; L2 &lt;= R1 &amp;&amp; L2 &lt;= R2，由于L1 &lt;= R1 和 L2 &lt;= R2 天然成立，所以简化为 L1 &lt;= R2 and L2 &lt;= R1</p><blockquote><p>回顾之前，result = (左半部分最大值 + 右半部分最小值）/ 2</p><p>左半部分最大值 = max(L1, L2)</p><p>右半部分最小值 = min(R1, R2)</p><p>Result = (max(L1,L2) + min(R1, R2)) / 2</p></blockquote><p>所以二分条件为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (L1 &gt; R2) <span class="comment">// 我们需要C1的位置左移来缩小L1的值，可以通过增加C2的值来减小C1的值</span></span><br><span class="line">    left = mid2 + <span class="number">1</span>；</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(L2 &gt; R1) <span class="comment">// 我们需要减小L2的值，即减小C2的值</span></span><br><span class="line">right = mid2 - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">max</span>(L1,L2) + <span class="built_in">min</span>(R1, R2)) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>但需要注意两点：</p><ul><li><p>由于C1和C2的划分关系，我们只需要对一个数组进行二分就可以，所以我们选择短的数组进行划分。</p></li><li><p>另外，需要注意边界条件，如果C2 = 0，index(L2) = (0-1)/2 = -1；C2 = 2N2，index(R2) = N2，由于最后要求L1和L2中的最大值，R1和R2中的最小值。所以我们可以另 A[-1] = INT_MIN；A[N2] = INT_MAX</p></li></ul><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N1 = nums1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> N2 = nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (N1 &lt; N2)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);  <span class="comment">// 保证nums2是短的</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = N2 * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">int</span> mid2 = (left + right) / <span class="number">2</span>;  <span class="comment">// nums2的划分点</span></span><br><span class="line">      <span class="keyword">int</span> mid1 = N1 + N2 - mid2;      <span class="comment">// nums1的划分点</span></span><br><span class="line">      <span class="keyword">double</span> L1 = (mid1 == <span class="number">0</span>) ? INT_MIN : nums1[(mid1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">double</span> L2 = (mid2 == <span class="number">0</span>) ? INT_MIN : nums2[(mid2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">double</span> R1 = (mid1 == N1 * <span class="number">2</span>) ? INT_MAX : nums1[(mid1) / <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">double</span> R2 = (mid2 == N2 * <span class="number">2</span>) ? INT_MAX : nums2[(mid2) / <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">if</span> (L1 &gt; R2)</span><br><span class="line">        left = mid2 + <span class="number">1</span>;  <span class="comment">// 增加mid2的值来减小L1的值</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (L2 &gt; R1)</span><br><span class="line">        right = mid2 - <span class="number">1</span>;  <span class="comment">// 减小mid2的值来减小L2的值</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (<span class="built_in">max</span>(L1, L2) + <span class="built_in">min</span>(R1, R2)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 24 ms, faster than 98.87% of C++ online submissions for Median of Two Sorted Arrays. Memory Usage: 9.7 MB, less than 99.14% of C++ online submissions for Median of Two Sorted Arrays.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> Binary Search </tag>
            
            <tag> Divide and Conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. Longest Substring Without Repeating Characters 最长不重复子串</title>
      <link href="/posts/3970654589/"/>
      <url>/posts/3970654589/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个字符串，返回一个没有重复字母的最长子串</p></blockquote><span id="more"></span><p><strong>Example :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3. </span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>这道题求最长无重复子串，自然会想到维护一个窗口，在这个窗口内的字符串一定都不是重复的。所以，只需要移动窗口的右边界来遍历字符串，使用一个数据结构来记录当前字母是否出现过，假如a出现过，就说明我们需要移动做窗口到它第一次出现的下一个位置。这样窗口内才只会有1个a。</p><p>所以我们可以通过初始化一个数组dict（初始值为-1）来记录字母s[i]最后一次出现的位置，start表示窗口的左边界，我们维护一个左开右闭区间。所以start的初始值为-1</p><p>如果<code>dict[s[i]] &gt; start</code>，说明s[i]已经出现在窗口内了，所以需要调整窗口。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dict</span><span class="params">(<span class="number">256</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>, start = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dict[s[i]] &gt; start) start = dict[s[i]];</span><br><span class="line">      dict[s[i]] = i;</span><br><span class="line">      maxLen = <span class="built_in">max</span>(maxLen, i - start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 12 ms, faster than 99.54% of C++ online submissions for Longest Substring Without Repeating Characters.</p><p>Memory Usage: 10.6 MB, less than 98.92% of C++ online submissions for Longest Substring Without Repeating Characters.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash Table </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. Add Two Numbers 链表数相加</title>
      <link href="/posts/4082904401/"/>
      <url>/posts/4082904401/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用两个非空的链表来表示两个整数，整数被逆向存储在链表中，返回两个整数的和</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><p>第一眼看到这道题，首先想到的是按照归并排序的逻辑，使用3个while循环去求解。提交过了之后，看了Discuss中大神的简短代码。充分利用了if的三元表达式，认真学习。</p><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>), *p = head;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l1 || l2 || c) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + c;</span><br><span class="line">      c = sum / <span class="number">10</span>;</span><br><span class="line">      p-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      l1 = l1 ? l1-&gt;next : l1;</span><br><span class="line">      l2 = l2 ? l2-&gt;next : l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 28 ms, faster than 96.98% of C++ online submissions for Add Two Numbers. Memory Usage: 10.6 MB, less than 96.95% of C++ online submissions for Add Two Numbers.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Medium </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum 两数之和</title>
      <link href="/posts/1457356929/"/>
      <url>/posts/1457356929/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给一个数组和一个整数target，返回数组中相加等于target的下标。</p></blockquote><span id="more"></span><p><strong>Example:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h3 id="解析">1. 解析</h3><ol type="1"><li>这道题可以有多种解法，容易想到的就是双重 for 循环，<span class="math inline">\(O(n^2)\)</span> 的时间复杂度显然是可以优化的</li><li>使用 Hash 的技巧，最开始我想到的是声明一个 Hash 数组，不过由于存在负数例子的情况，所以需要使用 map</li></ol><h3 id="代码">2. 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">      <span class="keyword">if</span> (m.<span class="built_in">find</span>(t) != m.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;m[t], i&#125;;</span><br><span class="line">      m[nums[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结果">3. 结果</h3><p>Runtime: 4 ms, faster than 99.78% of C++ online submissions for Two Sum. Memory Usage: 10.1 MB, less than 45.17% of C++ online submissions for Two Sum.</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> Hash Table </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建</title>
      <link href="/posts/2520382662/"/>
      <url>/posts/2520382662/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用Hexo来搭建自己的个人博客</p></blockquote><span id="more"></span><h3 id="配置github">1. 配置github</h3><h4 id="git">1.1. git</h4><p>首先要给电脑安装git，由于我使用的是MacBook Pro，所以可以很简单的使用homebrew来安装git</p><p>然后就是配置git的账户名称，以及设置配置SSH密匙</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>执行如下命令，能查看是否配置成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .gitconfig</span><br></pre></td></tr></table></figure><h4 id="ssh密匙">1.2. ssh密匙</h4><p>终端中执行如下命令，进入.ssh文件夹，查看是否已经有了ssh密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><p>生成密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>打开Github — Setting — SSH and GPG key — new SSH Key</p><p>Title为标题，任意填即可，将刚刚复制的id_rsa.pub内容粘贴进去，最后点击Add SSH key。</p><p>在Terminal中检测GitHub公钥设置是否成功，输入 <code>ssh git@github.com</code> ，出现下图，则成功配置。</p><p><img src="success.png" alt="success" /></p><h3 id="配置环境">2. 配置环境</h3><h4 id="node.js">2.1. Node.js</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><h4 id="hexo">2.2. hexo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装完成后，初始化我们的博客，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><h3 id="配置">3. 配置</h3><p>使用经典的 <a href="https://github.com/theme-next/hexo-theme-next">hexo-theme-next</a> 主题，为了方便以后的更新，我们 fork 一份代码到我们自己的仓库，然后 clone 下来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yourname/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><h4 id="配置hexo的config">3.1. 配置hexo的config</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Cooker&#x27;s</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">Cooking</span> <span class="string">&amp;</span> <span class="string">Coding</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">C++、程序员、技术笔记、算法分析</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Cooker</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://deepcooking.cn</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ... 不作修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment"># npm install hexo-deployer-git --save</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:iceice/iceice.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Generated static post link based on post titles</span></span><br><span class="line"><span class="comment"># npm install hexo-abbrlink --save</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">dec</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Symbols count and time to read of articles plugin</span></span><br><span class="line"><span class="comment"># npm install hexo-symbols-count-time --save</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate search data</span></span><br><span class="line"><span class="comment"># npm install hexo-generator-search --save</span></span><br><span class="line"><span class="comment"># next: local_search: enable: true</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="添加页面">3.2. 添加页面</h4><p>添加3个页面（标签、分类、关于）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-hexo-site</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page about</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>然后到source文件夹中找到这三个页面的index.md，做出如下修改</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-01-01 21:25:33</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014-12-22 12:39:04</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014-12-22 12:39:04</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h4 id="设置模板">3.3. 设置模板</h4><p><code>scaffolds</code> 文件夹下面有三个模板，我们修改其中的 <code>post</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">more</span> <span class="string">--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加图片">3.4. 添加图片</h4><p>在hexo的官方文档<a href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹章节</a>上，其提供了一种插入图片的方法，设置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">根目录：_config.yml</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样当我们使用命令：<code>hexo new post test_name</code> 的时候，会产生一个 Markdown 文件以及一个同名的文件夹。推荐使用 <code>Typora</code> 这个软件来进行 Mardown 的编写，通过我们上面设置的 post 模板。当我们插入一个图片的时候，自动插入到了我们 new 出来的文件夹中。另外在 Typora 的设置中勾选 “优先使用相对路径”</p><p>这样我们就可以在文档中通过：<code>![](test_name/example.jpg)</code> 命令来插入图片。</p><p>虽然在 Typora 里面图片显示的是正常的，但是 hexo 会将文件夹中的图片拷贝到与 Markdown 文件同级目录下面，这样生成的 HTML 中图片的路径为 <code>test_name/example.jpg</code> ，所以就会加载不出来。</p><p>解决方法是安装 <code>hexo-typora-image</code> 插件来帮我们修改成正确的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-typora-image --save</span><br></pre></td></tr></table></figure><p>修改 <code>hexo-typora-image.js</code> 源码，添加以下语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.content = data.content.replace(<span class="regexp">/^\&lt;img src=+\&quot;(.+\/)(.+)\&gt;/gm</span>, <span class="function">(<span class="params">str, dir</span>) =&gt;</span> str.replace(dir, <span class="string">&#x27;&#x27;</span>));</span><br></pre></td></tr></table></figure><h4 id="文章结尾">3.5 文章结尾</h4><p>在文章的结尾添加打赏二维码，并且添加"本文已经结束"的提示</p><p><img src="image-20210518173318760.png" alt="image-20210518173318760" style="zoom:50%;" /></p><p>首先，在 <code>next/layout/_macro</code> 文件夹下新建 <code>post-end-tag.swig</code> ，内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;</span>-------------本文已经结束 <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-paw&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> 感谢您的阅读-------------<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，修改 <code>next/layout/_macro/post.swig</code> 文件，修改以下位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if not is_index %&#125;</span><br><span class="line">    &#123;&#123;- next_inject(&#x27;postBodyEnd&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &#123;&#123; partial(&#x27;_macro/post-end-tag.swig&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &#123;%- if post.reward_settings.enable %&#125;</span><br><span class="line">    &#123;&#123; partial(&#x27;_partials/post/post-reward.swig&#x27;) &#125;&#125;</span><br><span class="line">    &#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><p>二维码添加到 <code>next/source/images</code> 中，并且修改 config。</p><h4 id="mathjax">3.6 Mathjax</h4><p>首先安装 <code>npm install hexo-renderer-pandoc --save</code></p><p>并且卸载 <code>npm un hexo-renderer-marked --save</code></p><p>https://theme-next.js.org/docs/third-party-services/math-equations.html?highlight=math <span class="math display">\[\begin{equation} \label{eq1}e=mc^2\end{equation}\]</span> <span class="math inline">\(2^n = abcd\)</span></p><p>使用pandoc会造成<a href="https://github.com/wzpan/hexo-renderer-pandoc/issues/34">图片的解析错误</a>，需要在 Hexo 的 _config.yml 中加入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pandoc:</span></span><br><span class="line">  <span class="attr">extensions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;-implicit_figures&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="评论系统">3.7 评论系统</h4><p>对于评论系统的选择可以参考 <a href="https://www.zhihu.com/question/267598518">知乎 : Hexo（NexT 主题）评论系统哪个好？</a>。目前我的个人站点用的是<a href="https://valine.js.org/">Valine</a> 。</p><p>首先，去LeanCloud网站注册账号，注册完成后，进入控制台创建一个应用，然后进入应用管理界面，创建两个 Comment 和 Counter 两个 Class，用来存储我们的评论以及网页的访问数量。</p><p><img src="image-20210519125013939.png" alt="image-20210519125013939" style="zoom:50%;" /></p><p>另外，我们需要选择左下角的设置&gt;应用Key，然后就能看到你的 <code>APP ID</code> 和 <code>APP Key</code> 了：</p><p><img src="5d0c997a60baa24436.jpg" alt="img" style="zoom:70%;" /></p><p>接下来，我们需要修改 Next 主题的 _config.yml 文件，将 <code>active</code> 设置为 <code>true</code> 。并将我们的 <code>APP ID</code> 和 <code>APP Key</code> 填入。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Multiple Comment System Support</span></span><br><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Available values: tabs | buttons</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">tabs</span></span><br><span class="line">  <span class="comment"># Choose a comment system to be displayed by default.</span></span><br><span class="line">  <span class="comment"># Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">valine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">true</span> <span class="comment"># Mail notifier</span></span><br><span class="line"></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="comment"># &lt;your app id&gt;</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="comment"># &lt;your app key&gt;</span></span><br></pre></td></tr></table></figure><p>最后，我们修改Valine的CDN地址，到 https://www.jsdelivr.com/package/npm/valine 这个地址选择最新版本的Valine，复制CDN地址。</p><p><img src="image-20210519130442396.png" alt="image-20210519130442396" style="zoom:50%;" /></p><p>在 <code>_config.yml</code> 中搜索一下 <code>Valine.min.js</code>，修改即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Valine</span><br><span class="line">valine: https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js</span><br></pre></td></tr></table></figure><h4 id="支持google搜索">3.8 支持Google搜索</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h3 id="新机">4. 新机</h3><p>首先配置Iterm2，安装oh my zsh，配置p10k</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><p>执行完上述命令，会将我们写好的Blog转为对应的HTML，接下来我们需要将其上传到GitHub。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br><span class="line">GitHub Username</span><br><span class="line">GitHub Token</span><br></pre></td></tr></table></figure><p><a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">Creating a personal access token - GitHub Docs</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
